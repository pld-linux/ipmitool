diff --git a/README b/README
index 39e5e8b..d815c3f 100644
--- a/README
+++ b/README
@@ -131,6 +131,109 @@ no problems.  The IPMIv1.5 interface will attempt to use OpenSSL for MD5
 hash function at compile time but if that is not found it will use an
 internal library.
 
+IPMB Dual Bridging in  IPMITOOL
+-------------------------------
+
+IPMI offers a standard messaging interface.
+
+The following concepts are related to this messaging interface:
+
+Channel type     : Communication channel type (SMS/KCS, IPMB, LAN) 
+Channel number   : Channel descriptor
+Requester        : Address of the requester
+Responder        : Address of the responder
+NetFN            : The logical function  for the request/response.
+Command          : The command number 
+Sequence         : An ID identifiying the request/response pair
+Message tracking : The ability to match request/response pair.
+
+When a communication is issued through any of the channels, an application 
+formats a request and expect a response. 
+
+Direct Command
+--------------
+The simplest form of communication is a "direct command" using SMS/KCS
+
+Example:
+ ipmitool raw 6 4
+  55 00
+
+This send raw command 4 (selftest) from netfn 6(application) to KCS, the driver 
+takes care of 'message tracking' and provides the answer.
+
+Hopefully, the application also includes a "human readable" instance of the API:
+ ipmitool mc selftest
+ Selftest: passed
+
+Bridged Command
+---------------
+One slightly more complicated communication mode is the so-called 
+"bridged command" using IPMB. 
+
+Example:
+ ipmitool -m 0x94 -t 0x9a raw 6 4
+ 55 00
+ 
+ or
+ 
+ ipmitool -m 0x94 -t 0x9a mc selftest
+ Selftest: passed
+ 
+
+This still sends the same command  4 (selftest) from netfn 6(application) to 
+the target. However, to do so, the command is encapsulated (by the driver) and
+sent using the command 0x34 (send message) from netfn 6(application) to KCS. 
+Then KCS is polled by the driver until a message has been received, then the
+driver uses command 0x33 (get message). The driver also tracks the message 
+and makes sure the response matches the request. Then it decapsultates the
+message and gives the response back to the application.
+
+Dual Bridged Command
+--------------------
+Things get a little more ugly when the application needs to reach a management
+controller sitting on an interface (or channel) not directly connected to the 
+BMC/IPMC. In the case the application must encapsulate its message itself and 
+request the IPMC to deal with message tracking itself.
+
+Its been working well with IPMITOOL on the LAN interface with:
+ ipmitool -H <ip> -U <user> -P <password> -B 0 -T 0x8a  -m 0x20 -t 0x7a -b 7  
+    mc selftest
+
+However, trying to dual bridge commands locally with :
+ ipmitool -B 0 -T 0x9a -m 0x94 -t 0x7a -b 7 mc selftest didn't work 
+ (it returned the same data as  ipmitool -m 0x20 -t 0x7a -b 7 mc selftest )
+ 
+The reason was that the "openipmi" interface pluging didn't 
+encapsulate/decapsulate the message and didn't even detect the intent
+to double bridge the request.
+
+ ./src/ipmitool -B 0 -T 0x8a -m 0x94 -t 0x7a -b 7 mc selftest
+ 
+-B    0  : transit channel for first bridge level (channel 0: IPMB-0) 
+-T 0x8a  : transit destination address (remote IPMC address)
+-m 0x94  : source address (local IPMC address on IPMB-0)
+-t 0x7a  : remote target (AMC IPMB-L address)
+-b    7  : remote channel (channel 7: IPMB-L)
+
+The transit source address (remote IPMC address on remote channel) is 
+automatically assigned by the remote IPMC.
+
+Payload Size Limit
+------------------
+Because some commands return a lot of data (fru read/get sdr) and because 2 
+levels of encapsulation are used, some command will fail.
+
+For instance this works.
+
+ipmitool -H <ip> -U <user> -P <password>  -B 0 -T 0x8a  -m 0x94 -t 0x7a -b 7 
+    mc selftest
+
+but this does not:
+    
+ipmitool -H <ip> -U <user> -P <password>  -B 0 -T 0x8a  -m 0x94 -t 0x7a -b 7 
+    fru print.
+
+
 
 Usage
 =====
diff --git a/configure.in b/configure.in
index 1dd3499..01e7dfb 100644
--- a/configure.in
+++ b/configure.in
@@ -83,7 +83,7 @@ solaris*)
 	enable_intf_bmc=no
 	enable_ipmishell=no
 	;;
-*darwin*)
+*darwin*|aix*)
 	# disable the linux and solaris-specific interfaces
 	enable_intf_imb=no
 	enable_intf_open=no
@@ -256,7 +256,7 @@ dnl Determine if you got the right FreeIPMI version
                            0,
                            NULL,
                            0);
-    ], ac_free_version_0_3_0=yes,ac_free_version_0_3_0=no)
+    ], ac_free_version_0_3_0=yes, ac_free_version_0_3_0=no)
     AC_MSG_RESULT($ac_free_version_0_3_0)
     AC_MSG_CHECKING([for libfreeipmi version 0.4.0])
     AC_TRY_COMPILE([
@@ -275,7 +275,7 @@ dnl Determine if you got the right FreeIPMI version
                           0,
                           NULL,
                           0);
-    ], ac_free_version_0_4_0=yes,ac_free_version_0_4_0=no)
+    ], ac_free_version_0_4_0=yes, ac_free_version_0_4_0=no)
     AC_MSG_RESULT($ac_free_version_0_4_0)
     AC_MSG_CHECKING([for libfreeipmi version 0.5.0])
     AC_TRY_COMPILE([
@@ -295,7 +295,7 @@ dnl Determine if you got the right FreeIPMI version
                           NULL,
                           0,
                           0);
-    ], ac_free_version_0_5_0=yes,ac_free_version_0_5_0=no)
+    ], ac_free_version_0_5_0=yes, ac_free_version_0_5_0=no)
     AC_MSG_RESULT($ac_free_version_0_5_0)
 
     AC_MSG_CHECKING([for libfreeipmi version 0.6.0])
@@ -314,7 +314,7 @@ dnl Determine if you got the right FreeIPMI version
                               NULL,
                               0,
                               0);
-    ], ac_free_version_0_6_0=yes,ac_free_version_0_6_0=no)
+    ], ac_free_version_0_6_0=yes, ac_free_version_0_6_0=no)
     AC_MSG_RESULT($ac_free_version_0_6_0)
 
     if test "x$ac_free_version_0_3_0" = "xyes" \
@@ -340,6 +340,10 @@ dnl Determine if you got the right FreeIPMI version
     else
        enable_intf_free=no
     fi
+
+    AC_CHECK_LIB(freeipmi,
+	         ipmi_cmd_raw_ipmb, 
+		 AC_DEFINE(IPMI_INTF_FREE_BRIDGING, [1], [Define to 1 to enable FreeIPMI Bridging Support.]))
 fi
 
 dnl look for termios header file
diff --git a/doc/ipmitool.1 b/doc/ipmitool.1
index 78c7fd6..7bce9f5 100644
--- a/doc/ipmitool.1
+++ b/doc/ipmitool.1
@@ -26,7 +26,7 @@ ipmitool [\fB\-c\fR|\fB\-h\fR|\fB\-v\fR|\fB\-V\fR]
          [\fB\-o\fR <\fIoemtype\fP>]
          [\fB\-O\fR <\fIsel oem\fP>]
          [\fB\-C\fR <\fIciphersuite\fP>]
-         [\fB\-K\fR|\fB\-k\fR <\fIkg_key\fP>]
+         [\fB\-Y\fR|[\fB\-K\fR|\fB\-k\fR <\fIkg_key\fP>]
          [\fB\-y\fR <\fIhex_kg_key\fP>]
          [\fB\-e\fR <\fIesc_char\fP>]
          <\fIcommand\fP>
@@ -62,6 +62,9 @@ This is not available with all commands.
 Use supplied character for SOL session escape character.  The default
 is to use \fI~\fP but this can conflict with ssh sessions.
 .TP
+\fB\-K\fR
+Read Kg key from IPMI_KGKEY environment variable.
+.TP
 \fB\-k\fR <\fIkey\fP>
 Use supplied Kg key for IPMIv2 authentication.  The default is not to
 use any Kg key.
@@ -72,6 +75,9 @@ hexadecimal format and can be used to specify keys with non-printable
 characters. E.g. '-k PASSWORD' and '-y 50415353574F5244' are
 equivalent.
 The default is not to use any Kg key.
+.TP
+\fB\-Y\fR
+Prompt for the Kg key for IPMIv2 authentication.
 .TP 
 \fB\-C\fR <\fIciphersuite\fP>
 The remote server authentication, integrity, and encryption algorithms
@@ -219,8 +225,13 @@ Commands:
         shell        Launch interactive IPMI shell
         exec         Run list of commands from file
         set          Set runtime variable for shell and exec
+	delloem      Manage Dell OEM Extensions
         echo         Used to echo lines to stdout in scripts
         ekanalyzer   run FRU-Ekeying analyzer using FRU files
+        ime          Upgrade/Query Intel ME firmware
+        hpm          Update HPM components using PICMG HPM.1 file
+        fwum         Update IPMC using Kontron OEM Firmware Update Manager
+
 
 ipmitool chassis help
 .br 
@@ -822,6 +833,241 @@ cards or two modules.
 .RE
 .RE
 .TP 
+\fIime\fP
+.RS
+.TP 
+\fIhelp\fP
+.br 
+
+Print usage information
+.TP 
+\fIinfo\fP
+
+Displays information about the Manageability Engine (ME)
+.TP 
+\fIupdate\fP <\fBfile\fR>
+.br
+
+Upgrade the ME firmware with the specified image file
+.br
+\fBWARNING\fR You MUST use a supported image provided by your board vendor
+.br
+.TP
+\fIrollback\fP
+
+Perform manual rollback of the ME firmware
+
+.RE
+.RE
+
+.TP
+\fIdelloem\fP
+.RS
+.br
+
+The delloem commands provide information on Dell-specific features.
+.TP
+\fIlcd\fP 
+.RS
+.br
+\fBset {mode}\fR|
+.br
+\fB{lcdqualifier}\fR|\fB{errordisplay}\fR
+.RS
+.br
+
+Allows you to set the LCD mode and user-defined string.
+.RE
+.TP
+\fIlcd set mode\fP
+.RS
+.br
+\fB{none}\fR|\fB{modelname}\fR|
+.br
+\fB{ipv4address}\fR|\fB{macaddress}\fR|
+.br
+\fB{systemname}\fR|\fB{servicetag}\fR|
+.br
+\fB{ipv6address}\fR|\fB{ambienttemp}\fR|
+.br
+\fB{systemwatt}\fR|\fB{assettag}\fR|
+.br
+\fB{userdefined}<text>\fR
+.RS
+.br
+
+Allows you to set the LCD display mode to any of the preceding parameters.
+.RE
+.RE
+.TP
+\fIlcd set lcdqualifier\fP
+.RS
+.br
+\fB{watt}\fR|\fB{btuphr}\fR|
+.br
+\fB{celsius}\fR|\fB{fahrenheit}\fR
+.RS
+.br
+
+Allows you to set the unit for the system ambient temperature mode.
+.RE
+.RE
+.TP
+\fIlcd set errordisplay\fP
+.RS
+.br
+\fB{sel}\fR|\fB{simple}\fR
+.RS
+.br
+
+Allows you to set the error display.
+.RE
+.RE
+.RE
+.TP
+\fIlcd info\fP
+.RS
+.br
+
+Displays the LCD screen information.
+.RE
+.TP
+\fIlcd set vkvm\fP
+.RS
+\fB{active}\fR|\fB{inactive}\fR
+.RS
+.br
+
+Allows you to set the vKVM status to active or inactive. When it is active and session is in progress, a message appears on LCD.
+.RE
+.RE
+.TP
+\fIlcd status\fP
+.RS
+.br
+
+Displays the LCD status for vKVM display active or inactive and Front Panel access mode (viewandmodify, view-only or disabled).
+.RE
+.TP
+\fImac\fP
+.RS
+.br
+
+Displays the information about the system NICs.
+.TP
+\fImac list\fP
+.RS
+.br
+
+Displays the NIC MAC address and status of all NICs. It also displays the DRAC/iDRAC MAC address.
+.RE
+.TP
+\fImac get\fP
+.RS
+\fB<NIC number>\fR
+.RS
+.br
+
+Displays the selected NICs MAC address and status.
+.RE
+.RE
+.RE
+.TP
+\fIlan set\fP
+.RS
+\fB<Mode>\fR
+.br
+
+Sets the NIC selection mode (dedicated, shared, shared with failover LOM2, shared with failover all LOMs).
+.RE
+.TP
+\fIlan get\fP
+.br
+
+Returns the current NIC selection mode (dedicated, shared, shared with failover LOM2, shared with failover all LOMs).
+.TP
+\fIlan get active\fP
+.br
+
+Returns the current active NIC (dedicated, LOM1, LOM2, LOM3 or LOM4).
+.TP
+\fIpowermonitor\fP
+.RS
+.br
+
+Displays power tracking statistics.
+.RE
+.TP
+\fIpowermonitor clear cumulativepower\fP
+.RS
+.br
+
+Reset cumulative power reading.
+.RE
+.TP
+\fIpowermonitor clear peakpower\fP
+.RS
+.br
+
+Reset peak power reading.
+.RE
+.TP
+\fIpowermonitor powerconsumption\fP
+.RS
+\fB<watt>\fR|\fB<btuphr>\fR
+.RS
+.br
+
+Displays the power consumption in watt or btuphr.
+.RE
+.RE
+.TP
+\fIpowermonitor powerconsumptionhistory\fP
+.RS
+\fB<watt>\fR|\fB<btuphr>\fR
+.RS
+.br
+
+Displays the power consumption history in watt or btuphr.
+.RE
+.RE
+.TP
+\fIpowermonitor getpowerbudget\fP
+.RS
+\fB<watt>\fR|\fB<btuphr>\fR
+.RS
+.br
+
+Displays the power cap in watt or btuphr.
+.RE
+.RE
+.TP
+\fIpowermonitor setpowerbudget\fP
+.RS
+\fB<val>\fR\fB<watt|btuphr|percent>\fR
+.RS
+.br
+
+Allows you to set the  power cap in watt, BTU/hr or percentage.
+.RE
+.RE
+.TP
+\fIpowermonitor enablepowercap\fP
+.RS
+.br
+
+Enables set power cap.
+.RE
+.TP
+\fIpowermonitor disablepowercap\fP
+.RS
+.br
+
+Disables set power cap.
+.RE
+.RE
+
+.TP 
 \fIevent\fP
 .RS
 .TP 
@@ -1133,7 +1379,156 @@ where all commands and command sub-functions are enabled.
 
 .RE
 
-.TP 
+.TP
+\fIfwum\fP
+.RS
+Update IPMC using Kontron OEM Firmware Update Manager.
+.TP
+\fIinfo\fR
+.br
+Show information about current firmware.
+
+.TP
+\fIstatus\fR
+.br
+Show status of each firmware bank present in the hardware.
+
+.TP
+\fIdownload\fP <\fBfilename\fR>
+.br
+
+Download specified firmware.
+
+.TP
+\fIupgrade\fP [\fBfilename\fR]
+.br
+
+Install firmware upgrade. If the filename is specified, the file is downloaded
+first, otherwise the last firmware downloaded is used.
+
+.TP
+\fIrollback\fP
+.br
+
+Ask IPMC to rollback to previous version.
+
+.TP
+\fItracelog\fP
+.br
+
+Show firmware upgrade log.
+
+.RE
+
+.TP
+\fIhpm\fP
+.RS
+PICMG HPM.1 Upgrade Agent
+.TP
+\fIcheck\fR
+.br
+Check the target information.
+
+.TP
+\fIcheck\fP <\fBfilename\fR>
+.br
+Display both the existing target version and image version on the screen.
+
+.TP
+\fIdownload\fP <\fBfilename\fR>
+.br
+
+Download specified firmware.
+
+.TP
+\fIupgrade\fP <\fBfilename\fR> [\fBall\fR] [\fBcomponent <x>\fR] [\fBactivate\fR]
+.br
+Upgrade the firmware using a valid HPM.1 image file. If no option is specified,
+the firmware versions are checked first and the firmware is upgraded only if they
+are different.
+
+.RS
+.TP
+\fIall\fR
+.br
+Upgrade all components even if the firmware versions are the same
+(use this only after using "check" command).
+
+.TP
+\fIcomponent\fP <\fBx\fR>
+.br
+Upgrade only given component from the given file.
+.br
+component 0 - BOOT
+.br
+component 1 - RTK
+
+.TP
+\fIactivate\fR
+.br
+Activate new firmware right away.
+
+.RE
+
+.TP
+\fIactivate\fR
+.br
+
+Activate the newly uploaded firmware.
+
+.TP
+\fItargetcap\fR
+.br
+
+Get the target upgrade capabilities.
+
+.TP
+\fIcompprop\fP <\fBid\fR> <\fBselect\fR>
+.br
+Get the specified component properties. Valid component \fBid\fR: 0-7.
+\fBSelect\fR can be one of following:
+.br
+0 - General properties
+.br
+1 - Current firmware version
+.br
+2 - Description string
+.br
+3 - Rollback firmware version
+.br
+4 - Deferred firmware version
+
+.TP
+\fIabort\fR
+.br
+
+Abort the on-going firmware upgrade.
+
+.TP
+\fIupgstatus\fR
+.br
+Show status of the last long duration command.
+
+.TP
+\fIrollback\fR
+.br
+Perform manual rollback on the IPM Controller firmware.
+
+.TP
+\fIrollbackstatus\fR
+.br
+
+Show the rollback status.
+
+.TP
+\fIselftestresult\fR
+.br
+
+Query the self test results.
+
+.RE
+
+.TP
 \fIi2c\fP <\fBi2caddr\fR> <\fBread bytes\fR> [<\fBwrite data\fR>]
 .br 
 
diff --git a/include/ipmitool/Makefile.am b/include/ipmitool/Makefile.am
index b5a1c97..04a9305 100644
--- a/include/ipmitool/Makefile.am
+++ b/include/ipmitool/Makefile.am
@@ -37,5 +37,5 @@ noinst_HEADERS = log.h bswap.h helper.h ipmi.h ipmi_cc.h ipmi_intf.h \
 	ipmi_strings.h ipmi_constants.h ipmi_user.h ipmi_pef.h \
 	ipmi_oem.h ipmi_isol.h ipmi_sunoem.h ipmi_picmg.h \
 	ipmi_fwum.h ipmi_main.h ipmi_tsol.h ipmi_firewall.h \
-	ipmi_kontronoem.h ipmi_ekanalyzer.h ipmi_gendev.h
-
+	ipmi_kontronoem.h ipmi_ekanalyzer.h ipmi_gendev.h ipmi_ime.h \
+	ipmi_delloem.h
diff --git a/include/ipmitool/helper.h b/include/ipmitool/helper.h
index 031da22..7033766 100644
--- a/include/ipmitool/helper.h
+++ b/include/ipmitool/helper.h
@@ -57,7 +57,7 @@ struct valstr {
 	const char * str;
 };
 struct oemvalstr {
-	uint16_t oem;
+	uint32_t oem;
    uint16_t val;
 	const char * str;
 };
diff --git a/include/ipmitool/ipmi.h b/include/ipmitool/ipmi.h
index 2e43793..d8e17b1 100644
--- a/include/ipmitool/ipmi.h
+++ b/include/ipmitool/ipmi.h
@@ -41,6 +41,9 @@
 #include <ipmitool/helper.h>
 #include <ipmitool/ipmi_cc.h>
 
+#if HAVE_CONFIG_H
+# include <config.h>
+#endif
 
 #define IPMI_BUF_SIZE 1024
 
diff --git a/include/ipmitool/ipmi_channel.h b/include/ipmitool/ipmi_channel.h
index 00fda96..7833ee3 100644
--- a/include/ipmitool/ipmi_channel.h
+++ b/include/ipmitool/ipmi_channel.h
@@ -54,6 +54,9 @@
  * The Get Authentication Capabilities response structure
  * From table 22-15 of the IPMI v2.0 spec
  */
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct get_channel_auth_cap_rsp {
 	uint8_t channel_number;
 #if WORDS_BIGENDIAN
@@ -93,7 +96,10 @@ struct get_channel_auth_cap_rsp {
 #endif
 	uint8_t oem_id[3];    /* IANA enterprise number for auth type */
 	uint8_t oem_aux_data; /* Additional OEM specific data for oem auths */
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 
 
@@ -101,6 +107,9 @@ struct get_channel_auth_cap_rsp {
  * The Get Channel Info response structure
  * From table 22-29 of the IPMI v2.0 spec
  */
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct get_channel_info_rsp {
 #if WORDS_BIGENDIAN
 	uint8_t __reserved1       : 4; 
@@ -132,7 +141,10 @@ struct get_channel_info_rsp {
 #endif
 	uint8_t vendor_id[3]; /* For OEM that specified the protocol */
 	uint8_t aux_info[2];  /* Not used*/
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 
 
@@ -140,6 +152,9 @@ struct get_channel_info_rsp {
  * The Get Channel Access response structure
  * From table 22-28 of the IPMI v2.0 spec
  */
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct get_channel_access_rsp {
 #if WORDS_BIGENDIAN
 	uint8_t __reserved1        : 2;
@@ -161,9 +176,14 @@ struct get_channel_access_rsp {
 	uint8_t channel_priv_limit : 4; /* Channel privilege level limit */
 	uint8_t __reserved2        : 4;
 #endif
-} __attribute__ ((packed));
-
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct get_user_access_rsp {
 #if WORDS_BIGENDIAN
 	uint8_t __reserved1        : 2;
@@ -190,8 +210,14 @@ struct get_user_access_rsp {
 	uint8_t callin_callback    : 1;
 	uint8_t __reserved4        : 1;
 #endif
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct set_user_access_data {
 #if WORDS_BIGENDIAN
 	uint8_t change_bits        : 1;
@@ -218,7 +244,10 @@ struct set_user_access_data {
 	uint8_t session_limit      : 4;
 	uint8_t __reserved3        : 4;
 #endif
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 uint8_t ipmi_get_channel_medium(struct ipmi_intf * intf, uint8_t channel);
 uint8_t ipmi_current_channel_medium(struct ipmi_intf * intf);
diff --git a/include/ipmitool/ipmi_delloem.h b/include/ipmitool/ipmi_delloem.h
new file mode 100644
index 0000000..956febf
--- /dev/null
+++ b/include/ipmitool/ipmi_delloem.h
@@ -0,0 +1,318 @@
+/****************************************************************************
+Copyright (c) 2008, Dell Inc
+All rights reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+- Redistributions of source code must retain the above copyright notice,
+this list of conditions and the following disclaimer.
+
+- Redistributions in binary form must reproduce the above copyright notice,
+this list of conditions and the following disclaimer in the documentation
+and/or other materials provided with the distribution. 
+- Neither the name of Dell Inc nor the names of its contributors
+may be used to endorse or promote products derived from this software 
+without specific prior written permission. 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE. 
+
+
+*****************************************************************************/
+#ifndef IPMI_DELLOEM_H
+#define IPMI_DELLOEM_H
+
+#if HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#pragma pack(1)
+
+#define MIN(a,b) ((a) < (b) ? (a) : (b))
+#define MAX(a,b) ((a) > (b) ? (a) : (b))
+
+
+/* IPMI 2.0 command for system information*/
+#define IPMI_SET_SYS_INFO                  0x58
+#define IPMI_GET_SYS_INFO                  0x59
+
+/* Dell selector for LCD control - get and set unless specified */
+#define IPMI_DELL_LCD_STRING_SELECTOR       0xC1        /* RW get/set the user string */
+#define IPMI_DELL_LCD_CONFIG_SELECTOR       0xC2        /* RW set to user/default/none */
+#define IPMI_DELL_LCD_GET_CAPS_SELECTOR     0xCF        /* RO use when available*/
+#define IPMI_DELL_LCD_STRINGEX_SELECTOR     0xD0        /* RW get/set the user string use first when available*/
+#define IPMI_DELL_LCD_STATUS_SELECTOR       0xE7        /* LCD string when config set to default.*/
+#define IPMI_DELL_PLATFORM_MODEL_NAME_SELECTOR 0xD1    /* LCD string when config set to default.*/
+
+/* Dell defines for picking which string to use */
+#define IPMI_DELL_LCD_CONFIG_USER_DEFINED   0x00 /* use string set by user*/
+#define IPMI_DELL_LCD_CONFIG_DEFAULT        0x01 /* use platform model name*/
+#define IPMI_DELL_LCD_CONFIG_NONE           0x02 /* blank*/
+#define IPMI_DELL_LCD_iDRAC_IPV4ADRESS      0x04 /* use string set by user*/
+#define IPMI_DELL_LCD_IDRAC_MAC_ADDRESS     0x08 /* use platform model name*/
+#define IPMI_DELL_LCD_OS_SYSTEM_NAME        0x10 /* blank*/
+
+#define IPMI_DELL_LCD_SERVICE_TAG           0x20  /* use string set by user*/
+#define IPMI_DELL_LCD_iDRAC_IPV6ADRESS      0x40  /* use string set by user*/
+#define IPMI_DELL_LCD_AMBEINT_TEMP          0x80  /* use platform model name*/
+#define IPMI_DELL_LCD_SYSTEM_WATTS          0x100 /* blank*/
+#define IPMI_DELL_LCD_ASSET_TAG             0x200
+
+#define IPMI_DELL_LCD_ERROR_DISP_SEL        0x01  /* use platform model name*/
+#define IPMI_DELL_LCD_ERROR_DISP_VERBOSE    0x02  /* blank*/
+
+#define IPMI_DELL_IDRAC_VALIDATOR           0xDD    
+#define IPMI_DELL_POWER_CAP_STATUS          0xBA   
+
+#define btuphr              0x01
+#define watt                0x00
+#define IPMI_DELL_POWER_CAP 0xEA
+#define percent             0x03 
+
+/* Not on all Dell servers. If there, use it.*/
+typedef struct _tag_ipmi_dell_lcd_caps
+{
+       uint8_t parm_rev;                                       /* 0x11 for IPMI 2.0 */
+        uint8_t char_set;                                       /* always 1 for printable ASCII 0x20-0x7E */
+   uint8_t number_lines;                           /* 0-4, 1 for 9G. 10G tbd */
+   uint8_t max_chars[4];                           /* 62 for triathlon, 0 if not present (glacier) */
+                                                                             /* [0] is max chars for line 1 */
+}IPMI_DELL_LCD_CAPS;
+
+#define IPMI_DELL_LCD_STRING_LENGTH_MAX 62      /* Valid for 9G. Glacier ??. */
+#define IPMI_DELL_LCD_STRING1_SIZE      14
+#define IPMI_DELL_LCD_STRINGN_SIZE      16
+
+
+
+typedef struct _tag_ipmi_dell_lcd_string
+{
+     uint8_t parm_rev;                       /* 0x11 for IPMI 2.0 */
+     uint8_t data_block_selector;            /* 16-byte data block number to access, 0 based.*/
+     union 
+     {
+          struct 
+          {
+                uint8_t encoding : 4;                     /* 0 is printable ASCII 7-bit */
+                uint8_t length;                           /* 0 to max chars from lcd caps */
+                uint8_t data[IPMI_DELL_LCD_STRING1_SIZE]; /* not zero terminated.  */
+          }selector_0_string;
+          uint8_t selector_n_data[IPMI_DELL_LCD_STRINGN_SIZE];
+     }lcd_string;
+} __attribute__ ((packed)) IPMI_DELL_LCD_STRING;
+
+/* Only found on servers with more than 1 line. Use if available. */
+typedef struct _tag_ipmi_dell_lcd_stringex
+{
+      uint8_t parm_rev;                       /* 0x11 for IPMI 2.0 */
+      uint8_t line_number;                    /* LCD line number 1 to 4 */
+      uint8_t data_block_selector;            /* 16-byte data block number to access, 0 based.*/
+      union 
+      {
+           struct  
+           {
+                uint8_t encoding : 4;                     /* 0 is printable ASCII 7-bit */
+                uint8_t length;                           /* 0 to max chars from lcd caps */
+                uint8_t data[IPMI_DELL_LCD_STRING1_SIZE]; /* not zero terminated.  */
+           } selector_0_string;
+           uint8_t selector_n_data[IPMI_DELL_LCD_STRINGN_SIZE];
+   } lcd_string;
+} __attribute__ ((packed)) IPMI_DELL_LCD_STRINGEX;
+
+
+typedef struct _lcd_status
+{
+      char vKVM_status;
+      char lock_status;
+      char Resv1;
+      char Resv;
+} __attribute__ ((packed)) LCD_STATUS;
+
+typedef struct _lcd_mode
+{
+    uint8_t parametersel;
+    uint32_t lcdmode;
+    uint16_t lcdquallifier;
+    uint32_t capabilites;
+    uint8_t error_display;
+    uint8_t Resv;
+} __attribute__ ((packed)) LCD_MODE;
+
+#define PARAM_REV_OFFSET                    (uint8_t)(0x1)
+
+#define LOM_MACTYPE_ETHERNET 0
+#define LOM_MACTYPE_ISCSI 1
+#define LOM_MACTYPE_RESERVED 3
+
+#define LOM_ETHERNET_ENABLED 0
+#define LOM_ETHERNET_DISABLED 1
+#define LOM_ETHERNET_PLAYINGDEAD 2
+#define LOM_ETHERNET_RESERVED 3
+
+#define LOM_ACTIVE 1
+#define LOM_INACTIVE 0
+
+#define MACADDRESSLENGH 6
+#define MAX_LOM 8
+
+
+#define APP_NETFN                   (uint8_t)(0x6)
+
+
+#define GET_SYSTEM_INFO_CMD         (uint8_t)(0x59)
+#define EMB_NIC_MAC_ADDRESS_11G     (uint8_t)(0xDA)
+#define EMB_NIC_MAC_ADDRESS_9G_10G  (uint8_t)(0xCB)
+
+#define IMC_IDRAC_10G               (uint8_t) (0x08) 
+#define IMC_CMC                     (uint8_t) (0x09)
+#define IMC_IDRAC_11G_MONOLITHIC    (uint8_t) (0x0A)
+#define IMC_IDRAC_11G_MODULAR       (uint8_t) (0x0B)
+#define IMC_UNUSED                  (uint8_t) (0x0C)
+#define IMC_MASER_LITE_BMC          (uint8_t) (0x0D)
+
+
+
+typedef struct
+{
+     unsigned int BladSlotNumber : 4;
+     unsigned int MacType : 2;
+     unsigned int EthernetStatus : 2;
+     unsigned int NICNumber : 5;
+     unsigned int Reserved : 3;
+     uint8_t MacAddressByte[MACADDRESSLENGH];
+} LOMMacAddressType;
+
+
+typedef struct
+{
+     LOMMacAddressType LOMMacAddress [MAX_LOM];
+} EmbeddedNICMacAddressType;
+
+typedef struct
+{
+     uint8_t MacAddressByte[MACADDRESSLENGH];
+} MacAddressType;
+
+typedef struct
+{
+   MacAddressType MacAddress [MAX_LOM];
+} EmbeddedNICMacAddressType_10G;
+
+
+
+#define TRANSPORT_NETFN             (uint8_t)(0xc)
+#define GET_LAN_PARAM_CMD           (uint8_t)(0x02)
+#define MAC_ADDR_PARAM              (uint8_t)(0x05)
+#define LAN_CHANNEL_NUMBER          (uint8_t)(0x01)
+
+#define IDRAC_NIC_NUMBER            (uint8_t)(0x8)
+
+#define TOTAL_N0_NICS_INDEX         (uint8_t)(0x1)
+
+#define SET_NIC_SELECTION_CMD       (uint8_t)(0x24)
+#define GET_NIC_SELECTION_CMD       (uint8_t)(0x25)
+#define GET_ACTIVE_NIC_CMD          (uint8_t)(0xc1)
+
+#define POWER_SUPPLY_INFO           (uint8_t)(0xb0)
+#define IPMI_ENTITY_ID_POWER_SUPPLY (uint8_t)(0x0a)
+#define SENSOR_STATE_STR_SIZE       (uint8_t)(64)
+#define SENSOR_NAME_STR_SIZE        (uint8_t)(64)
+
+#define GET_PWRMGMT_INFO_CMD	    (uint8_t)(0x9C)
+#define CLEAR_PWRMGMT_INFO_CMD	    (uint8_t)(0x9D)
+#define GET_PWR_HEADROOM_CMD	    (uint8_t)(0xBB)
+#define GET_PWR_CONSUMPTION_CMD	    (uint8_t)(0xB3)
+
+typedef struct _ipmi_power_monitor
+{
+    uint32_t        cumStartTime;
+    uint32_t        cumReading;
+    uint32_t        maxPeakStartTime;
+    uint32_t        ampPeakTime;
+    uint16_t        ampReading;
+    uint32_t        wattPeakTime;
+    uint16_t        wattReading;
+} __attribute__ ((packed)) IPMI_POWER_MONITOR;
+
+
+typedef struct ipmi_power_consumption_data
+{
+    uint16_t actualpowerconsumption;
+    uint16_t powerthreshold;
+    uint16_t warningthreshold;
+    uint8_t throttlestate;
+    uint16_t maxpowerconsumption;
+    uint16_t throttlepowerconsumption;
+    uint16_t Resv;
+} __attribute__ ((packed)) IPMI_POWER_CONSUMPTION_DATA;
+
+
+typedef struct ipmi_inst_power_consumption_data
+{
+    uint16_t instanpowerconsumption;
+    uint16_t instanApms;
+    uint16_t resv1;
+    uint8_t resv;
+} __attribute__ ((packed)) IPMI_INST_POWER_CONSUMPTION_DATA;
+
+typedef struct _ipmi_avgpower_consump_histroy
+{
+    uint8_t parameterselector;  
+    uint16_t lastminutepower;
+    uint16_t lasthourpower;
+    uint16_t lastdaypower;
+    uint16_t lastweakpower;  
+                          
+} __attribute__ ((packed)) IPMI_AVGPOWER_CONSUMP_HISTORY;
+
+typedef struct _ipmi_power_consump_histroy
+{
+    uint8_t parameterselector;   
+    uint16_t lastminutepower;
+    uint16_t lasthourpower;
+    uint16_t lastdaypower;
+    uint16_t lastweakpower; 
+    uint32_t lastminutepowertime;
+    uint32_t lasthourpowertime;
+    uint32_t lastdaypowertime;
+    uint32_t lastweekpowertime;
+} __attribute__ ((packed)) IPMI_POWER_CONSUMP_HISTORY;
+
+
+typedef struct _ipmi_delloem_power_cap
+{     
+    uint8_t parameterselector;      
+    uint16_t PowerCap;
+    uint8_t unit;
+    uint16_t MaximumPowerConsmp;
+    uint16_t MinimumPowerConsmp;
+    uint16_t totalnumpowersupp;
+    uint16_t AvailablePower ;
+    uint16_t SystemThrottling;
+    uint16_t Resv;
+} __attribute__ ((packed)) IPMI_POWER_CAP;       
+
+typedef struct _power_headroom
+{ 
+    uint16_t instheadroom;
+    uint16_t peakheadroom;
+} __attribute__ ((packed)) POWER_HEADROOM;
+
+
+typedef struct _SensorReadingType
+{
+    uint8_t sensorReading;
+    uint8_t sensorFlags;
+    uint16_t sensorState;
+}SensorReadingType;
+
+int ipmi_delloem_main(struct ipmi_intf * intf, int argc, char ** argv);
+
+#endif /*IPMI_DELLOEM_H*/
diff --git a/include/ipmitool/ipmi_entity.h b/include/ipmitool/ipmi_entity.h
index 29f44d2..6e5198c 100644
--- a/include/ipmitool/ipmi_entity.h
+++ b/include/ipmitool/ipmi_entity.h
@@ -33,6 +33,9 @@
 #ifndef IPMI_ENTITY_H
 #define IPMI_ENTITY_H
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct entity_id {
 	uint8_t	id;			/* physical entity id */
 #if WORDS_BIGENDIAN
@@ -42,6 +45,9 @@ struct entity_id {
 	uint8_t	instance    : 7;	/* instance number */
 	uint8_t	logical     : 1;	/* physical/logical */
 #endif
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 #endif /* IPMI_ENTITY_H */
diff --git a/include/ipmitool/ipmi_event.h b/include/ipmitool/ipmi_event.h
index e78d453..2ba2fa5 100644
--- a/include/ipmitool/ipmi_event.h
+++ b/include/ipmitool/ipmi_event.h
@@ -41,6 +41,9 @@
 #define EVENT_DIR_ASSERT	0
 #define EVENT_DIR_DEASSERT	1
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct platform_event_msg {
 	uint8_t evm_rev;
 	uint8_t sensor_type;
@@ -53,7 +56,10 @@ struct platform_event_msg {
 	uint8_t event_dir  : 1;
 #endif
 	uint8_t event_data[3];
-} __attribute__((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 int  ipmi_event_main(struct ipmi_intf *, int, char **);
 
diff --git a/include/ipmitool/ipmi_fru.h b/include/ipmitool/ipmi_fru.h
index 4bebfc9..11ed9d9 100644
--- a/include/ipmitool/ipmi_fru.h
+++ b/include/ipmitool/ipmi_fru.h
@@ -63,8 +63,11 @@ enum {
 struct fru_info {
 	uint16_t size;
 	uint8_t access:1;
-} __attribute__ ((packed));
+};
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct fru_header {
 	uint8_t version;
 	struct {
@@ -76,7 +79,10 @@ struct fru_header {
 	} offset;
 	uint8_t pad;
 	uint8_t checksum;
-} __attribute__ ((packed));
+}ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 struct fru_area_chassis {
 	uint8_t area_ver;
@@ -111,6 +117,9 @@ struct fru_area_product {
 	char * fru;
 };
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct fru_multirec_header {
 #define FRU_RECORD_TYPE_POWER_SUPPLY_INFORMATION 0x00
 #define FRU_RECORD_TYPE_DC_OUTPUT 0x01
@@ -124,8 +133,14 @@ struct fru_multirec_header {
 	uint8_t len;
 	uint8_t record_checksum;
 	uint8_t header_checksum;
-} __attribute__ ((packed));
+}ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct fru_multirec_powersupply {
 #if WORDS_BIGENDIAN
 	uint16_t capacity;
@@ -168,11 +183,17 @@ struct fru_multirec_powersupply {
 #endif
 	uint16_t combined_capacity;
 	uint8_t rps_threshold;
-} __attribute__ ((packed));
+}ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 static const char * combined_voltage_desc[] __attribute__((unused)) = {
 "12 V", "-12 V", "5 V", "3.3 V"};
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct fru_multirec_dcoutput {
 #if WORDS_BIGENDIAN
 	uint8_t standby:1;
@@ -189,8 +210,14 @@ struct fru_multirec_dcoutput {
 	uint16_t ripple_and_noise;
 	uint16_t min_current;
 	uint16_t max_current;
-} __attribute__ ((packed));
+}ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct fru_multirec_dcload {
 #if WORDS_BIGENDIAN
 	uint8_t __reserved:4;
@@ -205,8 +232,14 @@ struct fru_multirec_dcload {
 	uint16_t ripple_and_noise;
 	uint16_t min_current;
 	uint16_t max_current;
-} __attribute__ ((packed));
+}ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct fru_multirec_oem_header {
 	unsigned char mfg_id[3];
 #define FRU_PICMG_BACKPLANE_P2P			0x04
@@ -236,12 +269,24 @@ struct fru_multirec_oem_header {
 #define FRU_PICMG_CLK_CONFIG			0x2D
 	unsigned char record_id;
 	unsigned char record_version;
-} __attribute__ ((packed));
+}ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct fru_picmgext_guid {
 	unsigned char guid[16];
-} __attribute__ ((packed));
+}ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct fru_picmgext_link_desc {
 #ifndef WORDS_BIGENDIAN
 	unsigned int desig_channel:6;
@@ -268,7 +313,10 @@ struct fru_picmgext_link_desc {
 	unsigned int desig_if:2;
 	unsigned int desig_channel:6;
 #endif
-} __attribute__ ((packed));
+}ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 
 #define FRU_PICMGEXT_AMC_LINK_TYPE_RESERVED			 	  0x00
@@ -280,11 +328,20 @@ struct fru_picmgext_link_desc {
 #define FRU_PICMGEXT_AMC_LINK_TYPE_RAPIDIO              0x06
 #define FRU_PICMGEXT_AMC_LINK_TYPE_STORAGE              0x07
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 /* This is used in command, not in FRU */
 struct fru_picmgext_amc_link_info {
    unsigned char linkInfo[3];
-} __attribute__ ((packed));
+}ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct fru_picmgext_amc_link_desc_core {
 #ifndef WORDS_BIGENDIAN
 	unsigned int designator:12;
@@ -297,8 +354,14 @@ struct fru_picmgext_amc_link_desc_core {
 	unsigned int type:8;
 	unsigned int designator:12;
 #endif
-} __attribute__ ((packed));
+}ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct fru_picmgext_amc_link_desc_extra {
 #ifndef WORDS_BIGENDIAN
 	unsigned char asymetricMatch:2;
@@ -307,9 +370,15 @@ struct fru_picmgext_amc_link_desc_extra {
 	unsigned char reserved:6;
 	unsigned char asymetricMatch:2;
 #endif
-} __attribute__ ((packed));
+}ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct fru_picmgext_amc_link_desc {
 #ifndef WORDS_BIGENDIAN
    struct fru_picmgext_amc_link_desc_core  core;/* lsb */
@@ -318,14 +387,19 @@ struct fru_picmgext_amc_link_desc {
    struct fru_picmgext_amc_link_desc_extra extra;
    struct fru_picmgext_amc_link_desc_core  core;/* lsb */
 #endif
-} __attribute__ ((packed));
+}ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 
 #define FRU_PICMGEXT_OEM_SWFW 0x03
 #define OEM_SWFW_NBLOCK_OFFSET 0x05
 #define OEM_SWFW_FIELD_START_OFFSET 0x06
 
-
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct fru_picmgext_chn_desc {
 #ifndef WORDS_BIGENDIAN
 	unsigned char remote_slot:8;
@@ -338,36 +412,66 @@ struct fru_picmgext_chn_desc {
 	unsigned char remote_chn:5;
 	unsigned char remote_slot:8;
 #endif
-} __attribute__ ((packed));
+}ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct fru_picmgext_slot_desc {
 	unsigned char chan_type;
 	unsigned char slot_addr;
 	unsigned char chn_count;
-} __attribute__ ((packed));
+}ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 #define FRU_PICMGEXT_DESIGN_IF_BASE				0x00
 #define FRU_PICMGEXT_DESIGN_IF_FABRIC			0x01
 #define FRU_PICMGEXT_DESIGN_IF_UPDATE_CHANNEL	0x02
 #define FRU_PICMGEXT_DESIGN_IF_RESERVED			0x03
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct fru_picmgext_carrier_activation_record {
 	unsigned short max_internal_curr;
 	unsigned char  allowance_for_readiness;
    unsigned char  module_activation_record_count;
-} __attribute__ ((packed));
+}ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct fru_picmgext_activation_record {
 	unsigned char ibmb_addr;
 	unsigned char max_module_curr;
 	unsigned char reserved;
-} __attribute__ ((packed));
+}ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct fru_picmgext_carrier_p2p_record {
 	unsigned char resource_id;
 	unsigned char p2p_count;
-} __attribute__ ((packed));
+}ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct fru_picmgext_carrier_p2p_descriptor {
 #ifndef WORDS_BIGENDIAN
 	unsigned char  remote_resource_id;
@@ -380,8 +484,14 @@ struct fru_picmgext_carrier_p2p_descriptor {
 	unsigned short remote_port:5;
 	unsigned char  remote_resource_id;
 #endif
-} __attribute__ ((packed));
+}ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct fru_picmgext_amc_p2p_record {
 #ifndef WORDS_BIGENDIAN
 	unsigned char resource_id         :4;
@@ -392,8 +502,14 @@ struct fru_picmgext_amc_p2p_record {
 	unsigned char /* reserved */      :3;
 	unsigned char resource_id         :4;
 #endif 
-} __attribute__ ((packed));
+}ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct fru_picmgext_amc_channel_desc_record {
 #ifndef WORDS_BIGENDIAN
 	unsigned char lane0port           :5;
@@ -408,8 +524,14 @@ struct fru_picmgext_amc_channel_desc_record {
 	unsigned char lane1port           :5;
 	unsigned char lane0port           :5;
 #endif 
-} __attribute__ ((packed));
+}ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct fru_picmgext_amc_link_desc_record {
 	#define FRU_PICMGEXT_AMC_LINK_TYPE_PCIE		0x02
 	#define FRU_PICMGEXT_AMC_LINK_TYPE_PCIE_AS1	0x03
@@ -452,7 +574,11 @@ struct fru_picmgext_amc_link_desc_record {
 	unsigned short port_flag_0         :1;
 	unsigned short channel_id          :8;
 #endif 
-} __attribute__ ((packed));
+}ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
+
 /* FRU Board manufacturing date */
 static const uint64_t secs_from_1970_1996 = 820450800;
 static const char * chassis_type_desc[] __attribute__((unused)) = {
@@ -463,7 +589,10 @@ static const char * chassis_type_desc[] __attribute__((unused)) = {
 	    "Docking Station", "All in One", "Sub Notebook",
 	    "Space-saving", "Lunch Box", "Main Server Chassis",
 	    "Expansion Chassis", "SubChassis", "Bus Expansion Chassis",
-	    "Peripheral Chassis", "RAID Chassis", "Rack Mount Chassis"};
+	    "Peripheral Chassis", "RAID Chassis", "Rack Mount Chassis",
+	    "Sealed-case PC", "Multi-system Chassis", "CompactPCI",
+	    "AdvancedTCA", "Blade", "Blade Enclosure"
+};
 
 int ipmi_fru_main(struct ipmi_intf *intf, int argc, char **argv);
 int ipmi_fru_print(struct ipmi_intf *intf, struct sdr_record_fru_locator *fru);
diff --git a/include/ipmitool/ipmi_ime.h b/include/ipmitool/ipmi_ime.h
new file mode 100755
index 0000000..734ddb3
--- /dev/null
+++ b/include/ipmitool/ipmi_ime.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2007 Kontron Canada, Inc.  All Rights Reserved.
+ *
+ * Base on code from
+ * Copyright (c) 2003 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * Redistribution of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *
+ * Redistribution in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * Neither the name of Sun Microsystems, Inc. or the names of
+ * contributors may be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * This software is provided "AS IS," without a warranty of any kind.
+ * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES,
+ * INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A
+ * PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY EXCLUDED.
+ * SUN MICROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL NOT BE LIABLE
+ * FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING
+ * OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.  IN NO EVENT WILL
+ * SUN OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA,
+ * OR FOR DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR
+ * PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF
+ * LIABILITY, ARISING OUT OF THE USE OF OR INABILITY TO USE THIS SOFTWARE,
+ * EVEN IF SUN HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#ifndef IPMI_IME_H
+#define IPMI_IME_H
+
+#include <inttypes.h>
+#include <ipmitool/ipmi.h>
+
+
+int ipmi_ime_main(struct ipmi_intf *, int, char **);
+
+#endif /* IPMI_IME_H */
diff --git a/include/ipmitool/ipmi_intf.h b/include/ipmitool/ipmi_intf.h
index 78caad7..894d2a0 100644
--- a/include/ipmitool/ipmi_intf.h
+++ b/include/ipmitool/ipmi_intf.h
@@ -175,6 +175,7 @@ struct ipmi_intf {
 	uint8_t target_channel;
 	uint32_t transit_addr;
 	uint8_t transit_channel;
+	uint8_t channel_buf_size;
 
 	uint8_t devnum;
 
diff --git a/include/ipmitool/ipmi_kontronoem.h b/include/ipmitool/ipmi_kontronoem.h
index 40793c5..d3925df 100644
--- a/include/ipmitool/ipmi_kontronoem.h
+++ b/include/ipmitool/ipmi_kontronoem.h
@@ -41,5 +41,6 @@
 
 
 int ipmi_kontronoem_main(struct ipmi_intf *, int, char **);
+int ipmi_kontronoem_set_large_buffer(struct ipmi_intf *, unsigned char size);
 
 #endif /* IPMI_KONTRONOEM_H */
diff --git a/include/ipmitool/ipmi_mc.h b/include/ipmitool/ipmi_mc.h
index c05f3d1..7640ba5 100644
--- a/include/ipmitool/ipmi_mc.h
+++ b/include/ipmitool/ipmi_mc.h
@@ -1,21 +1,21 @@
 /*
  * Copyright (c) 2003 Sun Microsystems, Inc.  All Rights Reserved.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
- * 
+ *
  * Redistribution of source code must retain the above copyright
  * notice, this list of conditions and the following disclaimer.
- * 
+ *
  * Redistribution in binary form must reproduce the above copyright
  * notice, this list of conditions and the following disclaimer in the
  * documentation and/or other materials provided with the distribution.
- * 
+ *
  * Neither the name of Sun Microsystems, Inc. or the names of
  * contributors may be used to endorse or promote products derived
  * from this software without specific prior written permission.
- * 
+ *
  * This software is provided "AS IS," without a warranty of any kind.
  * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES,
  * INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A
@@ -48,10 +48,13 @@
 
 int ipmi_mc_main(struct ipmi_intf *, int, char **);
 
-/* 
+/*
  * Response data from IPM Get Device ID Command (IPMI rev 1.5, section 17.1)
- * The following really apply to any IPM device, not just BMCs... 
+ * The following really apply to any IPM device, not just BMCs...
  */
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct ipm_devid_rsp {
 	uint8_t device_id;
 	uint8_t device_revision;
@@ -62,10 +65,13 @@ struct ipm_devid_rsp {
 	uint8_t manufacturer_id[3];
 	uint8_t product_id[2];
 	uint8_t aux_fw_rev[4];
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 #define IPM_DEV_DEVICE_ID_SDR_MASK     (0x80)	/* 1 = provides SDRs      */
-#define IPM_DEV_DEVICE_ID_REV_MASK     (0x07)	/* BCD-enoded             */
+#define IPM_DEV_DEVICE_ID_REV_MASK     (0x0F)	/* BCD-enoded             */
 
 #define IPM_DEV_FWREV1_AVAIL_MASK      (0x80)	/* 0 = normal operation   */
 #define IPM_DEV_FWREV1_MAJOR_MASK      (0x3f)	/* Major rev, BCD-encoded */
@@ -83,10 +89,16 @@ struct ipm_devid_rsp {
 
 #define IPM_DEV_ADTL_SUPPORT_BITS      (8)
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct ipm_selftest_rsp {
 	unsigned char code;
 	unsigned char test;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 #define IPM_SFT_CODE_OK			0x55
 #define IPM_SFT_CODE_NOT_IMPLEMENTED	0x56
@@ -103,6 +115,9 @@ struct ipm_selftest_rsp {
 #define IPM_SELFTEST_FW_BOOTBLOCK	0x02
 #define IPM_SELFTEST_FW_CORRUPTED	0x01
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct ipm_get_watchdog_rsp {
 	unsigned char timer_use;
 	unsigned char timer_actions;
@@ -112,7 +127,10 @@ struct ipm_get_watchdog_rsp {
 	unsigned char initial_countdown_msb;
 	unsigned char present_countdown_lsb;
 	unsigned char present_countdown_msb;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 #define IPM_WATCHDOG_RESET_ERROR	0x80
 
diff --git a/include/ipmitool/ipmi_pef.h b/include/ipmitool/ipmi_pef.h
index 904a2ac..cdea4ec 100644
--- a/include/ipmitool/ipmi_pef.h
+++ b/include/ipmitool/ipmi_pef.h
@@ -50,6 +50,9 @@ typedef enum {
 	P_ABLE,
 } flg_e;
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_table_entry {
 #define PEF_CONFIG_ENABLED 0x80
 #define PEF_CONFIG_PRECONFIGURED 0x40
@@ -90,7 +93,10 @@ struct pef_table_entry {
 	uint8_t event_data_3_AND_mask;
 	uint8_t event_data_3_compare_1;
 	uint8_t event_data_3_compare_2;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 struct desc_map {						/* maps a description to a value/mask */
 	const char *desc;
@@ -324,6 +330,9 @@ pef_b2s_generic_ER[] __attribute__((unused)) = {
 #define PEF_B2S_GENERIC_ER_ENTRIES \
 			(sizeof(pef_b2s_generic_ER) / sizeof(pef_b2s_generic_ER[0]))
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_policy_entry {
 #define PEF_POLICY_ID_MASK 0xf0
 #define PEF_POLICY_ID_SHIFT 4
@@ -341,7 +350,10 @@ struct pef_policy_entry {
 	uint8_t chan_dest;
 #define PEF_POLICY_EVENT_SPECIFIC 0x80
 	uint8_t alert_string_key;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 static struct bit_desc_map
 pef_b2s_policies __attribute__((unused)) = {
@@ -384,6 +396,9 @@ BIT_DESC_MAP_LIST,
 	{NULL}
 }	};
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_cfgparm_selector {
 #define PEF_CFGPARM_ID_REVISION_ONLY_MASK 0x80
 #define PEF_CFGPARM_ID_SET_IN_PROGRESS 0
@@ -403,21 +418,36 @@ struct pef_cfgparm_selector {
 	uint8_t id;
 	uint8_t set;
 	uint8_t block;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_cfgparm_set_in_progress {
 #define PEF_SET_IN_PROGRESS_COMMIT_WRITE 0x02 
 #define PEF_SET_IN_PROGRESS 0x01
 	uint8_t data1;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_cfgparm_control {
 #define PEF_CONTROL_ENABLE_ALERT_STARTUP_DELAY 0x08
 #define PEF_CONTROL_ENABLE_STARTUP_DELAY 0x04
 #define PEF_CONTROL_ENABLE_EVENT_MESSAGES 0x02
 #define PEF_CONTROL_ENABLE 0x01
 	uint8_t data1;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 static struct bit_desc_map
 pef_b2s_control __attribute__((unused)) = {
@@ -429,6 +459,9 @@ BIT_DESC_MAP_ALL,
 	{NULL}
 }	};
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_cfgparm_action {
 #define PEF_ACTION_ENABLE_DIAGNOSTIC_INTERRUPT 0x20
 #define PEF_ACTION_ENABLE_OEM 0x10
@@ -437,54 +470,114 @@ struct pef_cfgparm_action {
 #define PEF_ACTION_ENABLE_POWER_DOWN 0x02
 #define PEF_ACTION_ENABLE_ALERT 0x01
 	uint8_t data1;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_cfgparm_startup_delay {
 	uint8_t data1;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_cfgparm_alert_startup_delay {
 	uint8_t data1;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_cfgparm_filter_table_size {
 #define PEF_FILTER_TABLE_SIZE_MASK 0x7f
 	uint8_t data1;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_cfgparm_filter_table_entry {
 #define PEF_FILTER_TABLE_ID_MASK 0x7f
 	uint8_t data1;
 	struct pef_table_entry entry;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_cfgparm_filter_table_data_1 {
 	uint8_t data1;
 	uint8_t data2;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_cfgparm_policy_table_size {
 #define PEF_POLICY_TABLE_SIZE_MASK 0x7f
 	uint8_t data1;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_cfgparm_policy_table_entry {
 #define PEF_POLICY_TABLE_ID_MASK 0x7f
 	uint8_t data1;
 	struct pef_policy_entry entry;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_cfgparm_system_guid {
 #define PEF_SYSTEM_GUID_USED_IN_PET 0x01
 	uint8_t data1;
 	uint8_t guid[16];
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_cfgparm_alert_string_table_size {
 #define PEF_ALERT_STRING_TABLE_SIZE_MASK 0x7f
 	uint8_t data1;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_cfgparm_alert_string_keys {
 #define PEF_ALERT_STRING_ID_MASK 0x7f
 	uint8_t data1;
@@ -492,16 +585,27 @@ struct pef_cfgparm_alert_string_keys {
 	uint8_t data2;
 #define PEF_ALERT_STRING_SET_ID_MASK 0x7f
 	uint8_t data3;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_cfgparm_alert_string_table_entry {
 	uint8_t id;
 	uint8_t blockno;
 	uint8_t block[16];
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 /* PEF - LAN */
-
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_lan_cfgparm_selector {
 #define PEF_LAN_CFGPARM_CH_REVISION_ONLY_MASK 0x80
 #define PEF_LAN_CFGPARM_CH_MASK 0x0f
@@ -513,13 +617,25 @@ struct pef_lan_cfgparm_selector {
 	uint8_t id;
 	uint8_t set;
 	uint8_t block;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_lan_cfgparm_dest_size {
 #define PEF_LAN_DEST_TABLE_SIZE_MASK 0x0f
 	uint8_t data1;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_lan_cfgparm_dest_type {
 #define PEF_LAN_DEST_TYPE_ID_MASK 0x0f
 	uint8_t dest;
@@ -532,7 +648,10 @@ struct pef_lan_cfgparm_dest_type {
 	uint8_t alert_timeout;
 #define PEF_LAN_RETRIES_MASK 0x07
 	uint8_t retries;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 static struct bit_desc_map
 pef_b2s_lan_desttype __attribute__((unused)) = {
@@ -544,6 +663,9 @@ BIT_DESC_MAP_LIST,
 	{NULL}
 }	};
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_lan_cfgparm_dest_info {
 #define PEF_LAN_DEST_MASK 0x0f
 	uint8_t dest;
@@ -555,10 +677,15 @@ struct pef_lan_cfgparm_dest_info {
 	uint8_t gateway;
 	uint8_t ip[4];
 	uint8_t mac[6];
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 /* PEF - Serial/PPP */
-
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_serial_cfgparm_selector {
 #define PEF_SERIAL_CFGPARM_CH_REVISION_ONLY_MASK 0x80
 #define PEF_SERIAL_CFGPARM_CH_MASK 0x0f
@@ -573,13 +700,25 @@ struct pef_serial_cfgparm_selector {
 	uint8_t id;
 	uint8_t set;
 	uint8_t block;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_serial_cfgparm_dest_size {
 #define PEF_SERIAL_DEST_TABLE_SIZE_MASK 0x0f
 	uint8_t data1;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_serial_cfgparm_dest_info {
 #define PEF_SERIAL_DEST_MASK 0x0f
 	uint8_t dest;
@@ -608,7 +747,10 @@ struct pef_serial_cfgparm_dest_info {
 #define PEF_SERIAL_CALLBACK_IPADDR_ID_SHIFT 4
 #define PEF_SERIAL_CALLBACK_ACCT_ID_MASK 0xf0
 	uint8_t data5;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 static struct bit_desc_map
 pef_b2s_serial_desttype __attribute__((unused)) = {
@@ -623,31 +765,58 @@ BIT_DESC_MAP_LIST,
 	{NULL}
 }	};
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_serial_cfgparm_dial_string_count {
 #define PEF_SERIAL_DIAL_STRING_COUNT_MASK 0x0f
 	uint8_t data1;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_serial_cfgparm_dial_string {
 #define PEF_SERIAL_DIAL_STRING_MASK 0x0f
 	uint8_t data1;
 	uint8_t data2;
 	uint8_t data3;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_serial_cfgparm_tap_acct_count {
 #define PEF_SERIAL_TAP_ACCT_COUNT_MASK 0x0f
 	uint8_t data1;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_serial_cfgparm_tap_acct_info {
 	uint8_t data1;
 #define PEF_SERIAL_TAP_ACCT_INFO_DIAL_STRING_ID_MASK 0xf0
 #define PEF_SERIAL_TAP_ACCT_INFO_DIAL_STRING_ID_SHIFT 4
 #define PEF_SERIAL_TAP_ACCT_INFO_SVC_SETTINGS_ID_MASK 0x0f
 	uint8_t data2;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct pef_serial_cfgparm_tap_svc_settings {
 	uint8_t data1;
 #define PEF_SERIAL_TAP_CONFIRMATION_ACK_AFTER_ETX 0x0
@@ -658,7 +827,10 @@ struct pef_serial_cfgparm_tap_svc_settings {
 	uint8_t escape_mask[4];
 	uint8_t timeout_parms[3];
 	uint8_t retry_parms[2];
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 static struct bit_desc_map
 pef_b2s_tap_svc_confirm __attribute__((unused)) = {
@@ -685,7 +857,7 @@ BIT_DESC_MAP_LIST,
 		struct pef_cfgparm_alert_string_table_size;
 		struct pef_cfgparm_alert_string_keys;
 		struct pef_cfgparm_alert_string_table_entry;
-	} __attribute__ ((packed));
+	} ATTRIBUTE_PACKING;
 
 	struct pef_lan_config_parms {							/* LAN */
 		struct pef_lan_cfgparm_set_in_progress;
@@ -708,7 +880,7 @@ BIT_DESC_MAP_LIST,
 		struct pef_lan_cfgparm_destination_count;
 		struct pef_lan_cfgparm_destination_type;
 		struct pef_lan_cfgparm_destination_ipaddr;
-	} __attribute__ ((packed));
+	} ATTRIBUTE_PACKING;
 
 	struct pef_serial_config_parms {						/* Serial/PPP */
 		struct pef_serial_cfgparm_set_in_progress;
@@ -760,7 +932,7 @@ BIT_DESC_MAP_LIST,
 		struct pef_serial_cfgparm_ppp_udp_proxy_xmit_bufsize;
 		struct pef_serial_cfgparm_ppp_udp_proxy_recv_bufsize;
 		struct pef_serial_cfgparm_ppp_remote_console_ipaddr;
-	} __attribute__ ((packed));
+	} ATTRIBUTE_PACKING;
 #endif
 
 #define IPMI_CMD_GET_PEF_CAPABILITIES 0x10
diff --git a/include/ipmitool/ipmi_picmg.h b/include/ipmitool/ipmi_picmg.h
index 18f6f46..5f73be2 100644
--- a/include/ipmitool/ipmi_picmg.h
+++ b/include/ipmitool/ipmi_picmg.h
@@ -8,6 +8,11 @@
 
 #include <ipmitool/ipmi.h>
 
+/* PICMG version */
+#define PICMG_CPCI_MAJOR_VERSION                   1
+#define PICMG_ATCA_MAJOR_VERSION                   2
+#define PICMG_AMC_MAJOR_VERSION                    4
+
 /* PICMG commands */
 #define PICMG_GET_PICMG_PROPERTIES_CMD             0x00
 #define PICMG_GET_ADDRESS_INFO_CMD                 0x01
@@ -53,11 +58,38 @@
 #define PICMG_PMC                                  0x08
 #define PICMG_RTM                                  0x09
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct picmg_set_fru_activation_cmd {
    unsigned char  picmg_id;      /* always 0*/
    unsigned char  fru_id;        /* threshold setting mask */
    unsigned char  fru_state;     /* fru activation/deactivation */
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
+
+typedef enum picmg_busres_board_cmd_types {
+	PICMG_BUSRES_BOARD_CMD_QUERY =0,
+	PICMG_BUSRES_BOARD_CMD_RELEASE,
+	PICMG_BUSRES_BOARD_CMD_FORCE,
+	PICMG_BUSRES_BOARD_CMD_BUS_FREE
+} t_picmg_busres_board_cmd_types ;
+
+typedef enum picmg_busres_shmc_cmd_types {
+	PICMG_BUSRES_SHMC_CMD_REQUEST =0,
+	PICMG_BUSRES_SHMC_CMD_RELINQUISH,
+	PICMG_BUSRES_SHMC_CMD_NOTIFY
+} t_picmg_busres_shmc_cmd_types ;
+
+typedef enum picmg_busres_resource_id {
+	PICMG_BUSRES_METAL_TEST_BUS_1=0,
+	PICMG_BUSRES_METAL_TEST_BUS_2,
+	PICMG_BUSRES_SYNC_CLOCK_GROUP_1,
+	PICMG_BUSRES_SYNC_CLOCK_GROUP_2,
+	PICMG_BUSRES_SYNC_CLOCK_GROUP_3
+} t_picmg_busres_resource_id;
 
 /* the LED color capabilities */
 static const char* led_color_str[] __attribute__((unused)) = {
diff --git a/include/ipmitool/ipmi_sdr.h b/include/ipmitool/ipmi_sdr.h
index f84700e..34c5a82 100644
--- a/include/ipmitool/ipmi_sdr.h
+++ b/include/ipmitool/ipmi_sdr.h
@@ -105,6 +105,9 @@ enum {
 #define GET_SENSOR_READING      0x2d
 #define GET_SENSOR_TYPE         0x2f
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct sdr_repo_info_rs {
 	uint8_t version;	/* SDR version (51h) */
 	uint16_t count;		/* number of records */
@@ -112,20 +115,39 @@ struct sdr_repo_info_rs {
 	uint32_t add_stamp;	/* last add timestamp */
 	uint32_t erase_stamp;	/* last del timestamp */
 	uint8_t op_support;	/* supported operations */
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 /* builtin (device) sdrs support */
 struct sdr_device_info_rs {
 	unsigned char count;	/* number of records */
 	unsigned char flags;	/* flags */
 	unsigned char popChangeInd[3];	/* free space in SDR */
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 #define GET_SDR_RESERVE_REPO	0x22
 struct sdr_reserve_repo_rs {
 	uint16_t reserve_id;	/* reservation ID */
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
+
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 #define GET_SDR		0x23
 struct sdr_get_rq {
 	uint16_t reserve_id;	/* reservation ID */
@@ -133,8 +155,14 @@ struct sdr_get_rq {
 	uint8_t offset;		/* offset into SDR */
 #define GET_SDR_ENTIRE_RECORD	0xff
 	uint8_t length;		/* length to read */
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct sdr_get_rs {
 	uint16_t next;		/* next record id */
 	uint16_t id;		/* record ID */
@@ -152,15 +180,21 @@ struct sdr_get_rs {
 #define SDR_RECORD_TYPE_OEM			0xc0
 	uint8_t type;		/* record type */
 	uint8_t length;		/* remaining record bytes */
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct sdr_record_mask {
 	union {
 		struct {
 			uint16_t assert_event;	/* assertion event mask */
 			uint16_t deassert_event;	/* de-assertion event mask */
 			uint16_t read;	/* discrete reading mask */
-		} discrete;
+		} ATTRIBUTE_PACKING discrete;
 		struct {
 #if WORDS_BIGENDIAN
 			uint16_t reserved:1;
@@ -254,7 +288,7 @@ struct sdr_record_mask {
 					uint16_t unr:1;
 					uint16_t reserved:2;
 #endif
-				} set;
+				} ATTRIBUTE_PACKING set;
 				struct {
 #if WORDS_BIGENDIAN			/* readable threshold mask */
 					/* padding upper 8 bits */
@@ -276,12 +310,18 @@ struct sdr_record_mask {
 					uint16_t reserved:2;
 					uint16_t settable:8;
 #endif
-				} read;
-			};
-		} threshold;
-	} type;
-} __attribute__ ((packed));
+				} ATTRIBUTE_PACKING read;
+			} ATTRIBUTE_PACKING;
+		} ATTRIBUTE_PACKING threshold;
+	} ATTRIBUTE_PACKING type;
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct sdr_record_compact_sensor {
 	struct {
 		uint8_t owner_id;
@@ -295,7 +335,7 @@ struct sdr_record_compact_sensor {
 		uint8_t channel:4;	/* channel number */
 #endif
 		uint8_t sensor_num;	/* unique sensor number */
-	} keys;
+	} ATTRIBUTE_PACKING keys;
 
 	struct entity_id entity;
 
@@ -320,7 +360,7 @@ struct sdr_record_compact_sensor {
 			uint8_t scanning:1;
 			uint8_t __reserved:1;
 #endif
-		} init;
+		} ATTRIBUTE_PACKING init;
 		struct {
 #if WORDS_BIGENDIAN
 			uint8_t ignore:1;
@@ -335,9 +375,9 @@ struct sdr_record_compact_sensor {
 			uint8_t rearm:1;
 			uint8_t ignore:1;
 #endif
-		} capabilities;
+		} ATTRIBUTE_PACKING capabilities;
 		uint8_t type;	/* sensor type */
-	} sensor;
+	} ATTRIBUTE_PACKING sensor;
 
 	uint8_t event_type;	/* event/reading type code */
 
@@ -358,8 +398,8 @@ struct sdr_record_compact_sensor {
 		struct {
 			uint8_t base;
 			uint8_t modifier;
-		} type;
-	} unit;
+		} ATTRIBUTE_PACKING type;
+	} ATTRIBUTE_PACKING unit;
 
 	struct {
 #if WORDS_BIGENDIAN
@@ -378,21 +418,27 @@ struct sdr_record_compact_sensor {
 		uint8_t mod_offset:7;
 		uint8_t entity_inst:1;
 #endif
-	} share;
+	} ATTRIBUTE_PACKING share;
 
 	struct {
 		struct {
 			uint8_t positive;
 			uint8_t negative;
-		} hysteresis;
-	} threshold;
+		} ATTRIBUTE_PACKING hysteresis;
+	} ATTRIBUTE_PACKING threshold;
 
 	uint8_t __reserved[3];
 	uint8_t oem;		/* reserved for OEM use */
 	uint8_t id_code;	/* sensor ID string type/length code */
 	uint8_t id_string[16];	/* sensor ID string bytes, only if id_code != 0 */
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct sdr_record_eventonly_sensor {
 	struct {
 		uint8_t owner_id;
@@ -406,7 +452,7 @@ struct sdr_record_eventonly_sensor {
 		uint8_t channel:4;	/* channel number */
 #endif
 		uint8_t sensor_num;	/* unique sensor number */
-	} keys;
+	} ATTRIBUTE_PACKING keys;
 
 	struct entity_id entity;
 
@@ -430,15 +476,21 @@ struct sdr_record_eventonly_sensor {
 		uint8_t mod_offset:7;
 		uint8_t entity_inst:1;
 #endif
-	} share;
+	} ATTRIBUTE_PACKING share;
 
 	uint8_t __reserved;
 	uint8_t oem;		/* reserved for OEM use */
 	uint8_t id_code;	/* sensor ID string type/length code */
 	uint8_t id_string[16];	/* sensor ID string bytes, only if id_code != 0 */
 
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct sdr_record_full_sensor {
 	struct {
 		uint8_t owner_id;
@@ -452,7 +504,7 @@ struct sdr_record_full_sensor {
 		uint8_t channel:4;	/* channel number */
 #endif
 		uint8_t sensor_num;	/* unique sensor number */
-	} keys;
+	} ATTRIBUTE_PACKING keys;
 
 	struct entity_id entity;
 
@@ -477,7 +529,7 @@ struct sdr_record_full_sensor {
 			uint8_t scanning:1;
 			uint8_t __reserved:1;
 #endif
-		} init;
+		} ATTRIBUTE_PACKING init;
 		struct {
 #if WORDS_BIGENDIAN
 			uint8_t ignore:1;
@@ -492,9 +544,9 @@ struct sdr_record_full_sensor {
 			uint8_t rearm:1;
 			uint8_t ignore:1;
 #endif
-		} capabilities;
+		} ATTRIBUTE_PACKING capabilities;
 		uint8_t type;
-	} sensor;
+	} ATTRIBUTE_PACKING sensor;
 
 	uint8_t event_type;	/* event/reading type code */
 
@@ -515,8 +567,8 @@ struct sdr_record_full_sensor {
 		struct {
 			uint8_t base;
 			uint8_t modifier;
-		} type;
-	} unit;
+		} ATTRIBUTE_PACKING type;
+	} ATTRIBUTE_PACKING unit;
 
 #define SDR_SENSOR_L_LINEAR     0x00
 #define SDR_SENSOR_L_LN         0x01
@@ -548,7 +600,7 @@ struct sdr_record_full_sensor {
 		uint8_t normal_min:1;	/* normal min field specified */
 		uint8_t __reserved:5;
 #endif
-	} analog_flag;
+	} ATTRIBUTE_PACKING analog_flag;
 
 	uint8_t nominal_read;	/* nominal reading, raw value */
 	uint8_t normal_max;	/* normal maximum, raw value */
@@ -561,23 +613,29 @@ struct sdr_record_full_sensor {
 			uint8_t non_recover;
 			uint8_t critical;
 			uint8_t non_critical;
-		} upper;
+		} ATTRIBUTE_PACKING upper;
 		struct {
 			uint8_t non_recover;
 			uint8_t critical;
 			uint8_t non_critical;
-		} lower;
+		} ATTRIBUTE_PACKING lower;
 		struct {
 			uint8_t positive;
 			uint8_t negative;
-		} hysteresis;
-	} threshold;
+		} ATTRIBUTE_PACKING hysteresis;
+	} ATTRIBUTE_PACKING threshold;
 	uint8_t __reserved[2];
 	uint8_t oem;		/* reserved for OEM use */
 	uint8_t id_code;	/* sensor ID string type/length code */
 	uint8_t id_string[16];	/* sensor ID string bytes, only if id_code != 0 */
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct sdr_record_mc_locator {
 	uint8_t dev_slave_addr;
 #if WORDS_BIGENDIAN
@@ -602,7 +660,10 @@ struct sdr_record_mc_locator {
 	uint8_t oem;
 	uint8_t id_code;
 	uint8_t id_string[16];
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 struct sdr_record_fru_locator {
 	uint8_t dev_slave_addr;
@@ -632,8 +693,14 @@ struct sdr_record_fru_locator {
 	uint8_t oem;
 	uint8_t id_code;
 	uint8_t id_string[16];
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct sdr_record_generic_locator {
 	uint8_t dev_access_addr;
 	uint8_t dev_slave_addr;
@@ -660,8 +727,14 @@ struct sdr_record_generic_locator {
 	uint8_t oem;
 	uint8_t id_code;
 	uint8_t id_string[16];
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct sdr_record_entity_assoc {
 	struct entity_id entity;	/* container entity ID and instance */
 	struct {
@@ -685,7 +758,10 @@ struct sdr_record_entity_assoc {
 	uint8_t entity_inst_3;	/* entity inst 3  |  range 2 first instance */
 	uint8_t entity_id_4;	/* entity ID 4    |  range 2 entity */
 	uint8_t entity_inst_4;	/* entity inst 4  |  range 2 last instance */
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 struct sdr_record_oem {
 	uint8_t *data;
@@ -696,6 +772,9 @@ struct sdr_record_oem {
  * The Get SDR Repository Info response structure
  * From table 33-3 of the IPMI v2.0 spec
  */
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct get_sdr_repository_info_rsp {
 	uint8_t sdr_version;
 	uint8_t record_count_lsb;
@@ -720,7 +799,10 @@ struct get_sdr_repository_info_rsp {
 	uint8_t modal_update_support:2;
 	uint8_t overflow_flag:1;
 #endif
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 struct ipmi_sdr_iterator {
 	uint16_t reservation;
@@ -729,6 +811,9 @@ struct ipmi_sdr_iterator {
 	int use_built_in;
 };
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct sdr_record_list {
 	uint16_t id;
 	uint8_t version;
@@ -745,8 +830,12 @@ struct sdr_record_list {
 		struct sdr_record_mc_locator *mcloc;
 		struct sdr_record_entity_assoc *entassoc;
 		struct sdr_record_oem *oem;
-	} record;
-};
+	} ATTRIBUTE_PACKING  record;
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
+
 
 /* unit description codes (IPMI v1.5 section 37.16) */
 #define UNIT_MAX	0x90
@@ -800,6 +889,9 @@ uint8_t *ipmi_sdr_get_record(struct ipmi_intf *intf, struct sdr_get_rs *header,
 			     struct ipmi_sdr_iterator *i);
 void ipmi_sdr_end(struct ipmi_intf *intf, struct ipmi_sdr_iterator *i);
 int ipmi_sdr_print_sdr(struct ipmi_intf *intf, uint8_t type);
+
+int ipmi_sdr_print_name_from_rawentry(struct ipmi_intf *intf,uint16_t id, 
+                                      uint8_t type,uint8_t * raw);
 int ipmi_sdr_print_rawentry(struct ipmi_intf *intf, uint8_t type, uint8_t * raw,
 			    int len);
 int ipmi_sdr_print_listentry(struct ipmi_intf *intf,
diff --git a/include/ipmitool/ipmi_sel.h b/include/ipmitool/ipmi_sel.h
index d71b7bc..817eaed 100644
--- a/include/ipmitool/ipmi_sel.h
+++ b/include/ipmitool/ipmi_sel.h
@@ -57,12 +57,18 @@ enum {
 	IPMI_EVENT_CLASS_OEM,
 };
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct sel_get_rq {
 	uint16_t	reserve_id;
 	uint16_t	record_id;
 	uint8_t	offset;
 	uint8_t	length;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 struct standard_spec_sel_rec{
 	uint32_t	timestamp;
@@ -95,6 +101,9 @@ struct oem_nots_spec_sel_rec{
 	uint8_t oem_defined[SEL_OEM_NOTS_DATA_LEN];
 };
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct sel_event_record {
 	uint16_t	record_id;
 	uint8_t	record_type;
@@ -103,7 +112,10 @@ struct sel_event_record {
 		struct oem_ts_spec_sel_rec oem_ts_type;
 		struct oem_nots_spec_sel_rec oem_nots_type;
 	} sel_type;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 struct ipmi_event_sensor_types {
 	uint8_t	code;
@@ -559,15 +571,61 @@ static struct ipmi_event_sensor_types sensor_specific_types[] __attribute__((unu
 	{ 0x29, 0x02, 0xff, IPMI_EVENT_CLASS_DISCRETE, "Battery", "Presence Detected" },
 
 	{ 0x2b, 0x00, 0xff, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Hardware change detected" },
-	{ 0x2b, 0x01, 0xff, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change detected" },
+	{ 0x2b, 0x01, 0x00, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change detected" },
+    { 0x2b, 0x01, 0x01, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change detected, Mngmt Ctrl Dev Id" },
+    { 0x2b, 0x01, 0x02, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change detected, Mngmt Ctrl Firm Rev" },
+    { 0x2b, 0x01, 0x03, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change detected, Mngmt Ctrl Dev Rev" },
+    { 0x2b, 0x01, 0x04, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change detected, Mngmt Ctrl Manuf Id" },
+    { 0x2b, 0x01, 0x05, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change detected, Mngmt Ctrl IPMI Vers" },
+    { 0x2b, 0x01, 0x06, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change detected, Mngmt Ctrl Aux Firm Id" },
+    { 0x2b, 0x01, 0x07, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change detected, Mngmt Ctrl Firm Boot Block" },
+    { 0x2b, 0x01, 0x08, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change detected, Mngmt Ctrl Other" },
+    { 0x2b, 0x01, 0x09, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change detected, BIOS/EFI change" },
+    { 0x2b, 0x01, 0x0A, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change detected, SMBIOS change" },
+    { 0x2b, 0x01, 0x0B, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change detected, O/S change" },
+    { 0x2b, 0x01, 0x0C, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change detected, O/S loader change" },
+    { 0x2b, 0x01, 0x0D, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change detected, Service Diag change" },
+    { 0x2b, 0x01, 0x0E, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change detected, Mngmt SW agent change" },
+    { 0x2b, 0x01, 0x0F, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change detected, Mngmt SW App change" },
+    { 0x2b, 0x01, 0x10, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change detected, Mngmt SW Middle" },
+    { 0x2b, 0x01, 0x11, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change detected, Prog HW Change (FPGA)" },
+    { 0x2b, 0x01, 0x12, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change detected, board/FRU module change" },
+    { 0x2b, 0x01, 0x13, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change detected, board/FRU component change" },
+    { 0x2b, 0x01, 0x14, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change detected, board/FRU replace equ ver" },
+    { 0x2b, 0x01, 0x15, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change detected, board/FRU replace new ver" },
+    { 0x2b, 0x01, 0x16, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change detected, board/FRU replace old ver" },
+    { 0x2b, 0x01, 0x17, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change detected, board/FRU HW conf change" },
 	{ 0x2b, 0x02, 0xff, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Hardware incompatibility detected" },
 	{ 0x2b, 0x03, 0xff, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software incompatibility detected" },
 	{ 0x2b, 0x04, 0xff, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Invalid or unsupported hardware version" },
 	{ 0x2b, 0x05, 0xff, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Invalid or unsupported firmware or software version" },
 	{ 0x2b, 0x06, 0xff, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Hardware change success" },
-	{ 0x2b, 0x07, 0xff, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change success" },
-
-	{ 0x2c, 0x00, 0xff, IPMI_EVENT_CLASS_DISCRETE, "FRU State", "Not Installed" },
+    { 0x2b, 0x07, 0x00, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change success" },
+    { 0x2b, 0x07, 0x01, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change success, Mngmt Ctrl Dev Id" },
+    { 0x2b, 0x07, 0x02, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change success, Mngmt Ctrl Firm Rev" },
+    { 0x2b, 0x07, 0x03, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change success, Mngmt Ctrl Dev Rev" },
+    { 0x2b, 0x07, 0x04, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change success, Mngmt Ctrl Manuf Id" },
+    { 0x2b, 0x07, 0x05, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change success, Mngmt Ctrl IPMI Vers" },
+    { 0x2b, 0x07, 0x06, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change success, Mngmt Ctrl Aux Firm Id" },
+    { 0x2b, 0x07, 0x07, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change success, Mngmt Ctrl Firm Boot Block" },
+    { 0x2b, 0x07, 0x08, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change success, Mngmt Ctrl Other" },
+    { 0x2b, 0x07, 0x09, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change success, BIOS/EFI change" },
+    { 0x2b, 0x07, 0x0A, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change success, SMBIOS change" },
+    { 0x2b, 0x07, 0x0B, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change success, O/S change" },
+    { 0x2b, 0x07, 0x0C, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change success, O/S loader change" },
+    { 0x2b, 0x07, 0x0D, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change success, Service Diag change" },
+    { 0x2b, 0x07, 0x0E, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change success, Mngmt SW agent change" },
+    { 0x2b, 0x07, 0x0F, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change success, Mngmt SW App change" },
+    { 0x2b, 0x07, 0x10, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change success, Mngmt SW Middle" },
+    { 0x2b, 0x07, 0x11, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change success, Prog HW Change (FPGA)" },
+    { 0x2b, 0x07, 0x12, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change success, board/FRU module change" },
+    { 0x2b, 0x07, 0x13, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change success, board/FRU component change" },
+    { 0x2b, 0x07, 0x14, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change success, board/FRU replace equ ver" },
+    { 0x2b, 0x07, 0x15, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change success, board/FRU replace new ver" },
+    { 0x2b, 0x07, 0x16, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change success, board/FRU replace old ver" },
+    { 0x2b, 0x07, 0x17, IPMI_EVENT_CLASS_DISCRETE, "Version Change", "Firmware or software change success, board/FRU HW conf change" },
+
+    { 0x2c, 0x00, 0xff, IPMI_EVENT_CLASS_DISCRETE, "FRU State", "Not Installed" },
 	{ 0x2c, 0x01, 0xff, IPMI_EVENT_CLASS_DISCRETE, "FRU State", "Inactive" },
 	{ 0x2c, 0x02, 0xff, IPMI_EVENT_CLASS_DISCRETE, "FRU State", "Activation Requested" },
 	{ 0x2c, 0x03, 0xff, IPMI_EVENT_CLASS_DISCRETE, "FRU State", "Activation in Progress" },
diff --git a/include/ipmitool/ipmi_sensor.h b/include/ipmitool/ipmi_sensor.h
index 359d7c8..78f1c6e 100644
--- a/include/ipmitool/ipmi_sensor.h
+++ b/include/ipmitool/ipmi_sensor.h
@@ -65,6 +65,9 @@
 #define STATE_13_ASSERTED  0x20
 #define STATE_14_ASSERTED  0x40
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct sensor_set_thresh_rq {
 	uint8_t	sensor_num;     	/* sensor # */
 	uint8_t	set_mask;       	/* threshold setting mask */
@@ -74,7 +77,10 @@ struct sensor_set_thresh_rq {
 	uint8_t	upper_non_crit;	        /* new upper non critical threshold*/
 	uint8_t	upper_crit;	        /* new upper critical threshold*/
 	uint8_t	upper_non_recov;	/* new upper non recoverable threshold*/
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 
 int ipmi_sensor_main(struct ipmi_intf *, int, char **);
diff --git a/include/ipmitool/ipmi_session.h b/include/ipmitool/ipmi_session.h
index ad7a09c..21ff12f 100644
--- a/include/ipmitool/ipmi_session.h
+++ b/include/ipmitool/ipmi_session.h
@@ -43,6 +43,9 @@
 /*
  * From table 22.25 of the IPMIv2 specification
  */
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct get_session_info_rsp
 {
 	uint8_t session_handle;
@@ -116,7 +119,10 @@ struct get_session_info_rsp
 			uint16_t console_port;        /* LSBF */
 		} modem_data;
 	} channel_data;
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 
 
diff --git a/include/ipmitool/ipmi_strings.h b/include/ipmitool/ipmi_strings.h
index 818a8bb..10ec430 100644
--- a/include/ipmitool/ipmi_strings.h
+++ b/include/ipmitool/ipmi_strings.h
@@ -53,6 +53,18 @@ extern const struct valstr ipmi_integrity_algorithms[];
 extern const struct valstr ipmi_encryption_algorithms[];
 extern const struct valstr ipmi_oem_info[];
 
+extern const struct valstr picmg_frucontrol_vals[];
+extern const struct valstr picmg_clk_family_vals[];
+extern const struct oemvalstr picmg_clk_accuracy_vals[];
+extern const struct oemvalstr picmg_clk_resource_vals[];
+extern const struct oemvalstr picmg_clk_id_vals[];
+
+extern const struct valstr picmg_busres_id_vals[];
+extern const struct valstr picmg_busres_board_cmd_vals[];
+extern const struct valstr picmg_busres_shmc_cmd_vals[];
+extern const struct oemvalstr picmg_busres_board_status_vals[];
+extern const struct oemvalstr picmg_busres_shmc_status_vals[];
+
 /* these are similar, expect that the lookup takes the IANA number
    as first parameter */
 extern const struct oemvalstr ipmi_oem_product_info[];
diff --git a/include/ipmitool/ipmi_user.h b/include/ipmitool/ipmi_user.h
index 8c1d8c7..4a8e481 100644
--- a/include/ipmitool/ipmi_user.h
+++ b/include/ipmitool/ipmi_user.h
@@ -67,6 +67,9 @@ struct user_access_rsp {
 	uint8_t __reserved3      : 2;
 #endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 #if WORDS_BIGENDIAN
 	uint8_t __reserved4             : 1;
 	uint8_t no_callin_access        : 1;
@@ -80,7 +83,10 @@ struct user_access_rsp {
 	uint8_t no_callin_access        : 1;
 	uint8_t __reserved4             : 1;
 #endif
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 
 
diff --git a/lib/Makefile.am b/lib/Makefile.am
index 8441e1d..9edac6a 100644
--- a/lib/Makefile.am
+++ b/lib/Makefile.am
@@ -38,7 +38,8 @@ libipmitool_la_SOURCES	= helper.c ipmi_sdr.c ipmi_sel.c ipmi_sol.c ipmi_pef.c \
 				  ipmi_session.c ipmi_strings.c ipmi_user.c ipmi_raw.c             \
 				  ipmi_oem.c ipmi_isol.c ipmi_sunoem.c ipmi_fwum.c ipmi_picmg.c    \
 				  ipmi_main.c ipmi_tsol.c ipmi_firewall.c ipmi_kontronoem.c        \
-				  ipmi_hpmfwupg.c ipmi_sdradd.c ipmi_ekanalyzer.c ipmi_gendev.c
+				  ipmi_hpmfwupg.c ipmi_sdradd.c ipmi_ekanalyzer.c ipmi_gendev.c    \
+				  ipmi_ime.c ipmi_delloem.c
 
 libipmitool_la_LDFLAGS		= -export-dynamic
 libipmitool_la_LIBADD		= -lm
diff --git a/lib/dimm_spd.c b/lib/dimm_spd.c
index f5fa42d..1ec5419 100644
--- a/lib/dimm_spd.c
+++ b/lib/dimm_spd.c
@@ -60,6 +60,37 @@ const struct valstr spd_memtype_vals[] = {
 	{ 0x06, "DDR SGRAM" },
 	{ 0x07, "DDR SDRAM" },
 	{ 0x08, "DDR2 SDRAM" },
+	{ 0x09, "DDR2 SDRAM FB-DIMM" },
+	{ 0x0A, "DDR2 SDRAM FB-DIMM Probe" },
+	{ 0x0B, "DDR3 SDRAM" },
+	{ 0x00, NULL },
+};
+
+const struct valstr ddr3_density_vals[] = 
+{
+	{ 0, "256 Mb" },
+	{ 1, "512 Mb" },
+	{ 2, "1 Gb" },
+	{ 3, "2 Gb" },
+	{ 4, "4 Gb" },
+	{ 5, "8 Gb" },
+	{ 6, "16 Gb" },
+	{ 0x00, NULL },
+};
+
+const struct valstr ddr3_banks_vals[] =
+{
+	{ 0, "3 (8 Banks)" },
+	{ 1, "4 (16 Banks)" },
+	{ 2, "5 (32 Banks)" },
+	{ 3, "6 (64 Banks)" },
+	{ 0x00, NULL },
+};
+
+const struct valstr ddr3_ecc_vals[] =
+{
+	{ 0, "0 bits" },
+	{ 1, "8 bits" },
 	{ 0x00, NULL },
 };
 
@@ -693,51 +724,128 @@ ipmi_spd_print(uint8_t *spd_data, int len)
 	if (len < 92)
 		return -1; /* we need first 91 bytes to do our thing */
 
-	size = spd_data[5] * (spd_data[31] << 2);
-	printf(" Memory Size           : %d MB\n", size);
 	printf(" Memory Type           : %s\n",
 	       val2str(spd_data[2], spd_memtype_vals));
-	printf(" Voltage Intf          : %s\n",
-	       val2str(spd_data[8], spd_voltage_vals));
-	printf(" Error Detect/Cor      : %s\n",
-	       val2str(spd_data[11], spd_config_vals));
-
-	/* handle jedec table bank continuation values */
-	printf(" Manufacturer          : ");
-	if (spd_data[64] != 0x7f)
-		printf("%s\n",
-		       val2str(spd_data[64], jedec_id1_vals));
-	else {
-		if (spd_data[65] != 0x7f)
+	
+	if (spd_data[2] == 0x0B)	/* DDR3 SDRAM */
+	{
+		int iPN;
+		char *pchPN = spd_data+128;
+		int sdram_cap = 0;
+		int pri_bus_width = 0;
+		int sdram_width = 0;
+		int ranks = 0;
+		int mem_size = 0;
+
+		if (len < 148)
+			return -1; /* we need first 91 bytes to do our thing */
+	
+
+		sdram_cap = ldexp(256,(spd_data[4]&15));
+		pri_bus_width = ldexp(8,(spd_data[8]&7));
+		sdram_width = ldexp(4,(spd_data[7]&7));
+		ranks = ldexp(1,((spd_data[7]&0x3F)>>3));
+		mem_size = (sdram_cap/8) * (pri_bus_width/sdram_width) * ranks;
+		printf(" SDRAM Capacity        : %d MB\n", sdram_cap );
+		printf(" Memory Banks          : %s\n", val2str(spd_data[4]>>4, ddr3_banks_vals));
+		printf(" Primary Bus Width     : %d bits\n", pri_bus_width );
+		printf(" SDRAM Device Width    : %d bits\n", sdram_width );
+		printf(" Number of Ranks       : %d\n", ranks );
+		printf(" Memory size           : %d MB\n", mem_size );
+		
+		/* printf(" Memory Density        : %s\n", val2str(spd_data[4]&15, ddr3_density_vals)); */
+		printf(" 1.5 V Nominal Op      : %s\n", (((spd_data[6]&1) != 0) ? "No":"Yes" ) );
+		printf(" 1.35 V Nominal Op     : %s\n", (((spd_data[6]&2) != 0) ? "No":"Yes" ) );
+		printf(" 1.2X V Nominal Op     : %s\n", (((spd_data[6]&4) != 0) ? "No":"Yes" ) );
+		printf(" Error Detect/Cor      : %s\n", val2str(spd_data[8]>>3, ddr3_ecc_vals));
+
+		printf(" Manufacturer          : ");
+		switch (spd_data[117]&127)
+		{
+		case	0:
+			printf("%s\n", val2str(spd_data[118], jedec_id1_vals));
+			break;
+
+		case	1:
+			printf("%s\n", val2str(spd_data[118], jedec_id2_vals));
+			break;
+
+		case	2:
+			printf("%s\n", val2str(spd_data[118], jedec_id3_vals));
+			break;
+
+		case	3:
+			printf("%s\n", val2str(spd_data[118], jedec_id4_vals));
+			break;
+
+		case	4:
+			printf("%s\n", val2str(spd_data[118], jedec_id5_vals));
+			break;
+
+		default:
+			printf("%s\n", "JEDEC JEP106 update required" );
+
+		}
+
+		printf(" Manufacture Date      : year %c%c week %c%c\n", 
+		'0'+(spd_data[120]>>4), '0'+(spd_data[120]&15), '0'+(spd_data[121]>>4), '0'+(spd_data[121]&15) );
+	
+		printf(" Serial Number         : %02x%02x%02x%02x\n",
+		spd_data[122], spd_data[123], spd_data[124], spd_data[125]);
+	
+		printf(" Part Number           : ");
+		for (iPN=0; iPN < 19; iPN++)
+		{	
+			printf( "%c", *pchPN++ );
+		}
+		printf("\n");
+	}
+	else
+	{
+		size = spd_data[5] * (spd_data[31] << 2);
+		printf(" Memory Size           : %d MB\n", size);
+		printf(" Voltage Intf          : %s\n",
+		val2str(spd_data[8], spd_voltage_vals));
+		printf(" Error Detect/Cor      : %s\n",
+		val2str(spd_data[11], spd_config_vals));
+	
+		/* handle jedec table bank continuation values */
+		printf(" Manufacturer          : ");
+		if (spd_data[64] != 0x7f)
 			printf("%s\n",
-			       val2str(spd_data[65], jedec_id2_vals));
+			val2str(spd_data[64], jedec_id1_vals));
 		else {
-			if (spd_data[66] != 0x7f)
+			if (spd_data[65] != 0x7f)
 				printf("%s\n",
-				       val2str(spd_data[66], jedec_id3_vals));
+				val2str(spd_data[65], jedec_id2_vals));
 			else {
-				if (spd_data[67] != 0x7f)
-					printf("%s\n",
-					       val2str(spd_data[67],
-						       jedec_id4_vals));
-				else
+				if (spd_data[66] != 0x7f)
 					printf("%s\n",
-					       val2str(spd_data[68],
-						       jedec_id5_vals));
+					val2str(spd_data[66], jedec_id3_vals));
+				else {
+					if (spd_data[67] != 0x7f)
+						printf("%s\n",
+						val2str(spd_data[67],
+							jedec_id4_vals));
+					else
+						printf("%s\n",
+						val2str(spd_data[68],
+							jedec_id5_vals));
+				}
 			}
 		}
-	}
 
-	if (spd_data[73]) {
-		char part[19];
-		memcpy(part, spd_data+73, 18);
-		part[18] = 0;
-		printf(" Part Number           : %s\n", part);
+		if (spd_data[73]) {
+			char part[19];
+			memcpy(part, spd_data+73, 18);
+			part[18] = 0;
+			printf(" Part Number           : %s\n", part);
+		}
+	
+		printf(" Serial Number         : %02x%02x%02x%02x\n",
+		spd_data[95], spd_data[96], spd_data[97], spd_data[98]);
 	}
 
-	printf(" Serial Number         : %02x%02x%02x%02x\n",
-	       spd_data[95], spd_data[96], spd_data[97], spd_data[98]);
-
 	if (verbose) {
 		printf("\n");
 		printbuf(spd_data, len, "SPD DATA");
diff --git a/lib/helper.c b/lib/helper.c
index 3109dfe..369d897 100644
--- a/lib/helper.c
+++ b/lib/helper.c
@@ -130,7 +130,7 @@ const char * oemval2str(uint32_t oem, uint16_t val,
 	static char un_str[32];
 	int i;
 
-	for (i = 0; vs[i].oem != 0x00 &&  vs[i].str != NULL; i++) {
+	for (i = 0; vs[i].oem != 0xffffff &&  vs[i].str != NULL; i++) {
       /* FIXME: for now on we assume PICMG capability on all IANAs */
       if
       ( 
diff --git a/lib/ipmi_delloem.c b/lib/ipmi_delloem.c
new file mode 100644
index 0000000..9e4aeca
--- /dev/null
+++ b/lib/ipmi_delloem.c
@@ -0,0 +1,4225 @@
+/******************************************************************
+Copyright (c) 2008, Dell Inc
+All rights reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+- Redistributions of source code must retain the above copyright notice,
+this list of conditions and the following disclaimer.
+
+- Redistributions in binary form must reproduce the above copyright notice,
+this list of conditions and the following disclaimer in the documentation
+and/or other materials provided with the distribution. 
+- Neither the name of Dell Inc nor the names of its contributors
+may be used to endorse or promote products derived from this software 
+without specific prior written permission. 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE. 
+
+
+******************************************************************/
+/*
+* Thursday Oct 7 17:30:12 2009
+* <deepaganesh_paulraj@dell.com>
+*
+* This code implements a dell OEM proprietary commands.
+*/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <unistd.h>
+#include <signal.h>
+#include <ctype.h>
+#include <limits.h>
+#include <ipmitool/ipmi.h>
+#include <ipmitool/ipmi_intf.h>
+#include <ipmitool/helper.h>
+#include <ipmitool/log.h>
+#include <ipmitool/ipmi_sel.h>
+#include <ipmitool/ipmi_delloem.h>
+#include <ipmitool/ipmi_fru.h>
+#include <ipmitool/ipmi_sdr.h>
+#include <ipmitool/ipmi_mc.h>
+#include <ipmitool/ipmi_sensor.h>
+#include <ipmitool/ipmi_sel.h>
+#include <ipmitool/bswap.h>
+#include <ipmitool/ipmi_sdr.h>
+#include <ipmitool/ipmi_entity.h>
+#include <ipmitool/ipmi_fru.h>
+#include <ipmitool/ipmi_sensor.h>
+/*------------ipmi headers------------------*/
+
+
+
+/*--------------time header-----------------*/
+#include <time.h>
+
+#define DELL_OEM_NETFN             (uint8_t)(0x30)
+#define GET_IDRAC_VIRTUAL_MAC      (uint8_t)(0xC9)
+#define INVALID -1
+#define SHARED 0
+#define SHARED_WITH_FAILOVER_LOM2 1
+#define DEDICATED 2
+#define SHARED_WITH_FAILOVER_ALL_LOMS 3
+
+static int current_arg =0;
+uint8_t iDRAC_FLAG=0;
+LCD_MODE lcd_mode;
+static uint8_t LcdSupported=0;
+
+
+volatile uint8_t IMC_Type = IMC_IDRAC_10G;
+
+
+POWER_HEADROOM powerheadroom;
+
+uint8_t PowercapSetable_flag=0;
+uint8_t PowercapstatusFlag=0;
+
+static void usage(void);
+
+static int ipmi_delloem_lcd_main (struct ipmi_intf * intf, int argc, char ** argv);
+static int ipmi_lcd_get_platform_model_name (struct ipmi_intf * intf,char* lcdstring,
+                        uint8_t max_length,uint8_t field_type);
+static int ipmi_idracvalidator_command (struct ipmi_intf * intf);
+static int ipmi_lcd_get_configure_command_wh (struct ipmi_intf * intf);
+static int ipmi_lcd_get_configure_command (struct ipmi_intf * intf,uint8_t *command);
+static int ipmi_lcd_set_configure_command (struct ipmi_intf * intf, int command);
+static int ipmi_lcd_set_configure_command_wh (struct ipmi_intf * intf, uint32_t  mode,
+                        uint16_t lcdquallifier,uint8_t errordisp);
+static int ipmi_lcd_get_single_line_text (struct ipmi_intf * intf, char* lcdstring, uint8_t max_length);
+static int ipmi_lcd_get_info_wh(struct ipmi_intf * intf);
+static int ipmi_lcd_get_info(struct ipmi_intf * intf);
+static int ipmi_lcd_get_status_val(struct ipmi_intf * intf, LCD_STATUS* lcdstatus);
+static int IsLCDSupported ();
+static void CheckLCDSupport(struct ipmi_intf * intf);
+static void ipmi_lcd_status_print( LCD_STATUS lcdstatus);
+static int ipmi_lcd_get_status(struct ipmi_intf * intf );
+static int ipmi_lcd_set_kvm(struct ipmi_intf * intf, char status);
+static int ipmi_lcd_set_lock(struct ipmi_intf * intf,  char lock);
+static int ipmi_lcd_set_single_line_text (struct ipmi_intf * intf, char * text);
+static int ipmi_lcd_set_text(struct ipmi_intf * intf, char * text, int line_number);
+static int ipmi_lcd_configure_wh (struct ipmi_intf * intf, uint32_t  mode ,
+                       uint16_t lcdquallifier, uint8_t errordisp, 
+                       int8_t line_number, char * text);
+static int ipmi_lcd_configure (struct ipmi_intf * intf, int command, 
+                    int8_t line_number, char * text);
+static void ipmi_lcd_usage(void);
+
+static int ipmi_delloem_mac_main (struct ipmi_intf * intf, int argc, char ** argv);
+static int make_int(const char *str, int *value);
+static void InitEmbeddedNICMacAddressValues ();
+static int ipmi_macinfo_drac_idrac_virtual_mac(struct ipmi_intf* intf,uint8_t NicNum);
+static int ipmi_macinfo_drac_idrac_mac(struct ipmi_intf* intf,uint8_t NicNum);
+static int ipmi_macinfo_10g (struct ipmi_intf* intf, uint8_t NicNum);
+static int ipmi_macinfo_11g (struct ipmi_intf* intf, uint8_t NicNum);
+static int ipmi_macinfo (struct ipmi_intf* intf, uint8_t NicNum);
+static void ipmi_mac_usage(void);
+
+static int ipmi_delloem_lan_main (struct ipmi_intf * intf, int argc, char ** argv);
+static int IsLANSupported ();
+static int get_nic_selection_mode (int current_arg, char ** argv);
+static int ipmi_lan_set_nic_selection (struct ipmi_intf* intf, uint8_t nic_selection);
+static int ipmi_lan_get_nic_selection (struct ipmi_intf* intf);
+static int ipmi_lan_get_active_nic (struct ipmi_intf* intf);
+static void ipmi_lan_usage(void);
+
+static int ipmi_delloem_powermonitor_main (struct ipmi_intf * intf, int argc, char ** argv);
+static void ipmi_time_to_str(time_t rawTime, char* strTime);
+static int ipmi_get_sensor_reading(struct ipmi_intf *intf ,
+            unsigned char sensorNumber, 
+                        SensorReadingType* pSensorReadingData);
+static int ipmi_get_power_capstatus_command (struct ipmi_intf * intf);
+static int ipmi_set_power_capstatus_command (struct ipmi_intf * intf,uint8_t val);
+static int ipmi_powermgmt(struct ipmi_intf* intf);
+static int ipmi_powermgmt_clear(struct ipmi_intf* intf,uint8_t clearValue);
+static uint64_t watt_to_btuphr_conversion(uint32_t powerinwatt);
+static uint32_t btuphr_to_watt_conversion(uint64_t powerinbtuphr);
+static int ipmi_get_power_headroom_command (struct ipmi_intf * intf,uint8_t unit);
+static int ipmi_get_power_consumption_data(struct ipmi_intf* intf,uint8_t unit);
+static int ipmi_get_instan_power_consmpt_data(struct ipmi_intf* intf,
+                        IPMI_INST_POWER_CONSUMPTION_DATA* instpowerconsumptiondata);
+static void ipmi_print_get_instan_power_Amps_data(IPMI_INST_POWER_CONSUMPTION_DATA instpowerconsumptiondata);
+static int ipmi_print_get_power_consmpt_data(struct ipmi_intf* intf,uint8_t  unit);
+static int ipmi_get_avgpower_consmpt_history(struct ipmi_intf* intf,IPMI_AVGPOWER_CONSUMP_HISTORY* pavgpower );
+static int ipmi_get_peakpower_consmpt_history(struct ipmi_intf* intf,IPMI_POWER_CONSUMP_HISTORY * pstPeakpower);
+static int ipmi_get_minpower_consmpt_history(struct ipmi_intf* intf,IPMI_POWER_CONSUMP_HISTORY * pstMinpower);
+static int ipmi_print_power_consmpt_history(struct ipmi_intf* intf,int unit );
+static int ipmi_get_power_cap(struct ipmi_intf* intf,IPMI_POWER_CAP* ipmipowercap );
+static int ipmi_print_power_cap(struct ipmi_intf* intf,uint8_t unit );
+static int ipmi_set_power_cap(struct ipmi_intf* intf,int unit,int val );
+static int getpowersupplyfruinfo(struct ipmi_intf *intf, uint8_t id, 
+                       struct fru_header header, struct fru_info fru);
+static void ipmi_powermonitor_usage(void);
+
+
+/*****************************************************************
+* Function Name:       ipmi_delloem_main
+*
+* Description:         This function processes the delloem command
+* Input:               intf    - ipmi interface
+                       argc    - no of arguments
+                       argv    - argument string array
+* Output:        
+*
+* Return:              return code     0 - success
+*                                      -1 - failure
+*
+******************************************************************/
+
+int
+ipmi_delloem_main(struct ipmi_intf * intf, int argc, char ** argv)
+{
+    int rc = 0;
+
+    ipmi_idracvalidator_command(intf);
+    CheckLCDSupport (intf);
+
+    if (argc == 0 || strncmp(argv[0], "help\0", 5) == 0) 
+    {
+        usage();
+        return 0;
+    }
+
+    if (IsLCDSupported() && (0 ==strncmp(argv[current_arg], "lcd\0", 4)) ) 
+    {
+        ipmi_delloem_lcd_main (intf,argc,argv);
+    }
+    /* mac address*/
+    else if (strncmp(argv[current_arg], "mac\0", 4) == 0) 
+    {
+        ipmi_delloem_mac_main (intf,argc,argv);
+    }
+    /* lan address*/
+    else if (IsLANSupported() && strncmp(argv[current_arg], "lan\0", 4) == 0) 
+    {
+        ipmi_delloem_lan_main (intf,argc,argv);
+    }       
+    /*Powermanagement report processing*/
+    else if (strncmp(argv[current_arg], "powermonitor\0", 13) == 0) 
+    {
+        ipmi_delloem_powermonitor_main (intf,argc,argv);
+    }       
+    else
+    {
+        usage();
+        return -1;
+    }
+    return rc;
+}
+
+/*****************************************************************
+* Function Name:     usage
+*
+* Description:       This function prints help message for delloem command
+* Input:           
+* Output:       
+*
+* Return:              
+*
+******************************************************************/
+
+static void usage(void)
+{
+    lprintf(LOG_NOTICE, "");
+    lprintf(LOG_NOTICE, "usage: delloem <command> [option...]");
+    lprintf(LOG_NOTICE, "");
+    lprintf(LOG_NOTICE, "commands:");
+    if (IsLCDSupported())
+        lprintf(LOG_NOTICE, "    lcd"); 
+    lprintf(LOG_NOTICE, "    mac");         
+    if (IsLANSupported())
+        lprintf(LOG_NOTICE, "    lan");         
+    lprintf(LOG_NOTICE, "    powermonitor");        
+    lprintf(LOG_NOTICE, "");
+    lprintf(LOG_NOTICE, "For help on individual commands type:");
+    lprintf(LOG_NOTICE, "delloem <command> help");
+
+}
+
+/*****************************************************************
+* Function Name:       ipmi_delloem_lcd_main
+*
+* Description:         This function processes the delloem lcd command
+* Input:               intf    - ipmi interface
+                       argc    - no of arguments
+                       argv    - argument string array
+* Output:        
+*
+* Return:              return code     0 - success
+*                         -1 - failure
+*
+******************************************************************/
+
+static int ipmi_delloem_lcd_main (struct ipmi_intf * intf, int argc, char ** argv)
+{
+    int rc = 0;
+
+    current_arg++;
+    if (argc < current_arg) 
+    {
+        usage();
+        return -1;
+    }
+
+
+    /* ipmitool delloem lcd info*/
+    if (argc == 1) 
+    {
+        ipmi_lcd_usage();
+    }
+    else if (strncmp(argv[current_arg], "info\0", 5) == 0) 
+    {
+        if(iDRAC_FLAG==1)            
+            rc = ipmi_lcd_get_info_wh(intf);
+        else
+            rc = ipmi_lcd_get_info(intf);
+    }
+    else if (strncmp(argv[current_arg], "status\0", 7) == 0)
+    {
+        rc = ipmi_lcd_get_status(intf);
+    }
+    /* ipmitool delloem lcd set*/
+    else if (strncmp(argv[current_arg], "set\0", 4) == 0) 
+    {
+        uint8_t line_number = 0;
+        current_arg++;
+        if (argc <= current_arg) 
+        {
+            ipmi_lcd_usage();
+            return -1;
+        }
+        if (strncmp(argv[current_arg], "line\0", 5) == 0) 
+        {
+            current_arg++;
+            if (argc <= current_arg) {usage();return -1;}
+            line_number = (uint8_t)strtoul(argv[current_arg], NULL, 0);
+            current_arg++;
+            if (argc <= current_arg) {usage();return -1;}
+        }
+        if ((strncmp(argv[current_arg], "mode\0", 5) == 0)&&(iDRAC_FLAG==1)) 
+        {
+            current_arg++;
+            if (argc <= current_arg) 
+            {
+                ipmi_lcd_usage();
+                return -1;
+            }    
+            if (argv[current_arg] == NULL)  
+            {
+                ipmi_lcd_usage();
+                return -1;
+            }
+            if (strncmp(argv[current_arg], "none\0", 5) == 0) 
+            {
+                rc = ipmi_lcd_configure_wh (intf, IPMI_DELL_LCD_CONFIG_NONE,0xFF,0XFF, 0, NULL);
+            }
+            else if (strncmp(argv[current_arg], "modelname\0", 10) == 0) 
+            {
+                rc = ipmi_lcd_configure_wh (intf, IPMI_DELL_LCD_CONFIG_DEFAULT,0xFF,0XFF, 0, NULL);
+            }
+            else if (strncmp(argv[current_arg], "userdefined\0", 12) == 0) 
+            {
+                current_arg++;
+                if (argc <= current_arg) 
+                {
+                    ipmi_lcd_usage();return -1;
+                }
+                rc = ipmi_lcd_configure_wh (intf, IPMI_DELL_LCD_CONFIG_USER_DEFINED,0xFF,0XFF, line_number, argv[current_arg]);
+            }
+            else if (strncmp(argv[current_arg], "ipv4address\0", 12) == 0) 
+            {
+                rc = ipmi_lcd_configure_wh (intf, IPMI_DELL_LCD_iDRAC_IPV4ADRESS  ,0xFF,0XFF, 0, NULL);
+            }
+            else if (strncmp(argv[current_arg], "macaddress\0", 11) == 0) 
+            {
+                rc = ipmi_lcd_configure_wh (intf, IPMI_DELL_LCD_IDRAC_MAC_ADDRESS,0xFF,0XFF, 0, NULL);
+            }
+            else if (strncmp(argv[current_arg], "systemname\0", 11) == 0) 
+            {
+                rc = ipmi_lcd_configure_wh (intf, IPMI_DELL_LCD_OS_SYSTEM_NAME,0xFF,0XFF, 0, NULL);
+            }
+            else if (strncmp(argv[current_arg], "servicetag\0", 11) == 0) 
+            {
+                rc = ipmi_lcd_configure_wh (intf, IPMI_DELL_LCD_SERVICE_TAG, 0xFF,0XFF,0, NULL);
+            }
+            else if (strncmp(argv[current_arg], "ipv6address\0", 12) == 0) 
+            {
+                rc = ipmi_lcd_configure_wh (intf, IPMI_DELL_LCD_iDRAC_IPV6ADRESS  ,0xFF,0XFF, 0, NULL);
+            }
+            else if (strncmp(argv[current_arg], "ambienttemp\0", 12) == 0) 
+            {
+                rc = ipmi_lcd_configure_wh (intf, IPMI_DELL_LCD_AMBEINT_TEMP, 0xFF,0XFF,0, NULL);
+
+            }
+            else if (strncmp(argv[current_arg], "systemwatt\0", 11) == 0) 
+            {
+                rc = ipmi_lcd_configure_wh (intf, IPMI_DELL_LCD_SYSTEM_WATTS , 0xFF,0XFF,0, NULL);
+
+            }
+            else if (strncmp(argv[current_arg], "assettag\0", 9) == 0) 
+            {
+                rc = ipmi_lcd_configure_wh (intf, IPMI_DELL_LCD_ASSET_TAG , 0xFF,0XFF,0, NULL);
+
+            }
+            else if (strncmp(argv[current_arg], "help\0", 5) == 0) 
+            {
+                ipmi_lcd_usage();
+            }
+            else
+            {       
+                ipmi_lcd_usage();
+            }
+        }
+        else if ((strncmp(argv[current_arg], "lcdqualifier\0", 13)== 0) &&(iDRAC_FLAG==1) )
+        {
+
+            current_arg++;
+            if (argc <= current_arg) 
+            {
+                ipmi_lcd_usage();
+                return -1;
+            }
+            if (argv[current_arg] == NULL) 
+            {
+                ipmi_lcd_usage();
+                return -1;
+            } 
+
+            if (strncmp(argv[current_arg], "watt\0", 5) == 0) {
+
+
+                rc = ipmi_lcd_configure_wh (intf, 0xFF,0x00,0XFF, 0, NULL);
+            }
+            else if (strncmp(argv[current_arg], "btuphr\0",7) == 0) {
+                rc = ipmi_lcd_configure_wh (intf, 0xFF,0x01,0XFF, 0, NULL);
+
+            } else if (strncmp(argv[current_arg], "celsius\0", 8) == 0) {
+                rc = ipmi_lcd_configure_wh (intf, 0xFF,0x02,0xFF, 0, NULL);
+            } else if (strncmp(argv[current_arg], "fahrenheit", 11) == 0) {
+                rc = ipmi_lcd_configure_wh (intf, 0xFF,0x03,0xFF, 0, NULL);
+
+            }else if (strncmp(argv[current_arg], "help\0", 5) == 0) {
+                ipmi_lcd_usage();
+            }
+            else {  
+                ipmi_lcd_usage();
+            }
+        }
+        else if( (strncmp(argv[current_arg], "errordisplay\0", 13) == 0)&&(iDRAC_FLAG==1)) 
+        {
+
+            current_arg++;
+            if (argc <= current_arg)
+            {
+                ipmi_lcd_usage();
+                return -1;
+            }
+            if (argv[current_arg] == NULL) 
+            { 
+                ipmi_lcd_usage();
+                return -1;
+            } 
+
+            if (strncmp(argv[current_arg], "sel\0", 4) == 0) 
+            {
+                rc = ipmi_lcd_configure_wh (intf, 0xFF,0xFF,IPMI_DELL_LCD_ERROR_DISP_SEL , 0, NULL);
+            }
+            else if (strncmp(argv[current_arg], "simple\0", 7) == 0) 
+            {
+                rc = ipmi_lcd_configure_wh (intf, 0xFF,0xFF,IPMI_DELL_LCD_ERROR_DISP_VERBOSE , 0, NULL);
+
+            }
+            else if (strncmp(argv[current_arg], "help\0", 5) == 0) 
+            {
+                ipmi_lcd_usage();
+            }
+            else 
+            {       
+                ipmi_lcd_usage();
+            }
+        }
+
+        else if ((strncmp(argv[current_arg], "none\0", 5) == 0)&&(iDRAC_FLAG==0)) 
+        {
+            rc = ipmi_lcd_configure (intf, IPMI_DELL_LCD_CONFIG_NONE, 0, NULL);
+        }
+        else if ((strncmp(argv[current_arg], "default\0", 8) == 0)&&(iDRAC_FLAG==0)) 
+        {
+            rc = ipmi_lcd_configure (intf, IPMI_DELL_LCD_CONFIG_DEFAULT, 0, NULL);
+
+        } 
+        else if ((strncmp(argv[current_arg], "custom\0", 7) == 0)&&(iDRAC_FLAG==0))  
+        {
+            current_arg++;
+            if (argc <= current_arg) 
+            {
+                ipmi_lcd_usage();
+                return -1;
+            }
+            rc = ipmi_lcd_configure (intf, IPMI_DELL_LCD_CONFIG_USER_DEFINED, line_number, argv[current_arg]);
+        } 
+
+        else if (strncmp(argv[current_arg], "vkvm\0", 5) == 0) 
+        {
+            current_arg++;
+            if (argc <= current_arg) 
+            {
+                ipmi_lcd_usage();
+                return -1;
+            }
+
+            if (strncmp(argv[current_arg], "active\0", 7) == 0) 
+            {
+                rc = ipmi_lcd_set_kvm (intf, 1);
+            }
+            else if (strncmp(argv[current_arg], "inactive\0", 9)==0)
+            {
+                rc = ipmi_lcd_set_kvm (intf, 0);
+
+            }
+            else if (strncmp(argv[current_arg], "help\0", 5) == 0) 
+            {
+                ipmi_lcd_usage();
+            }
+            else 
+            {       
+                ipmi_lcd_usage();
+            }
+
+        }
+        else if (strncmp(argv[current_arg], "frontpanelaccess\0", 17) == 0) 
+        {
+            current_arg++;
+            if (argc <= current_arg) 
+            {
+                ipmi_lcd_usage();
+                return -1;
+            }
+            if (strncmp(argv[current_arg], "viewandmodify\0", 14) == 0) 
+            {
+                rc = ipmi_lcd_set_lock (intf, 0);
+            }
+            else if (strncmp(argv[current_arg], "viewonly\0", 9)==0)
+            {
+                rc =  ipmi_lcd_set_lock (intf, 1);
+
+            }
+            else if (strncmp(argv[current_arg], "disabled\0", 9)==0)
+            {
+                rc =  ipmi_lcd_set_lock (intf, 2);
+
+            }
+            else if (strncmp(argv[current_arg], "help\0", 5) == 0) 
+            {
+                ipmi_lcd_usage();
+            }
+            else 
+            {       
+                ipmi_lcd_usage();
+            }
+
+        }
+        else if( (strncmp(argv[current_arg], "help\0", 5) == 0)&&(iDRAC_FLAG==0))  
+        {
+            ipmi_lcd_usage();
+        }
+        else 
+        {
+            ipmi_lcd_usage();
+            return -1;
+        }
+    } 
+    else 
+    {
+        ipmi_lcd_usage();
+        return -1;
+    }
+
+}
+
+
+
+/*****************************************************************
+* Function Name:      ipmi_lcd_get_platform_model_name
+*
+* Description: This function retrieves the platform model name, or any other parameter 
+*              which stores  data in the same format
+* Input:       intf         - pointer to interface
+*              max_length   - length of the platform model string
+*              field_type   - either hostname / platform model
+* Output:      lcdstring    - hostname / platform model string
+*
+* Return:            
+*
+******************************************************************/ 
+static int
+ipmi_lcd_get_platform_model_name (struct ipmi_intf * intf, 
+                          char* lcdstring, 
+                                  uint8_t max_length, 
+                                  uint8_t field_type)
+{
+    struct ipmi_rs * rsp = NULL;
+    struct ipmi_rq req = {0};
+    uint8_t data[4];
+    IPMI_DELL_LCD_STRING * lcdstringblock;
+    int lcdstring_len = 0;
+    int bytes_copied = 0;
+
+    int ii;
+
+    for (ii = 0; ii < 4; ii++)
+    {
+        int bytes_to_copy;
+
+        req.msg.netfn = IPMI_NETFN_APP;
+        req.msg.lun = 0;
+        req.msg.cmd = IPMI_GET_SYS_INFO;
+        req.msg.data_len = 4;
+        req.msg.data = data;
+        data[0] = 0;                            /* get parameter*/
+        data[1] = field_type;
+        data[2] = ii;
+        data[3] = 0;
+
+
+        rsp = intf->sendrecv(intf, &req);
+        if (rsp == NULL) {
+            lprintf(LOG_ERR, " Error getting platform model name");
+        } else if (rsp->ccode > 0) {
+            lprintf(LOG_ERR, " Error getting platform model name: %s",
+                val2str(rsp->ccode, completion_code_vals));
+        }
+
+        lcdstringblock = (IPMI_DELL_LCD_STRING *) (void *) rsp->data;
+
+        /* first block is different - 14 bytes*/
+        if (0 == ii) {
+            lcdstring_len = lcdstringblock->lcd_string.selector_0_string.length;
+
+            lcdstring_len = MIN (lcdstring_len,max_length);
+
+            bytes_to_copy = MIN(lcdstring_len, IPMI_DELL_LCD_STRING1_SIZE);
+            memcpy (lcdstring, lcdstringblock->lcd_string.selector_0_string.data, bytes_to_copy);
+        } else {
+            int string_offset;
+
+            bytes_to_copy = MIN(lcdstring_len - bytes_copied, IPMI_DELL_LCD_STRINGN_SIZE);
+            if (bytes_to_copy < 1)
+                break;
+            string_offset = IPMI_DELL_LCD_STRING1_SIZE + IPMI_DELL_LCD_STRINGN_SIZE * (ii-1);
+            memcpy (lcdstring+string_offset, lcdstringblock->lcd_string.selector_n_data, bytes_to_copy);
+        }
+
+
+        bytes_copied += bytes_to_copy;
+
+        if (bytes_copied >= lcdstring_len)
+
+            break;
+    }
+
+}
+
+/*****************************************************************
+* Function Name:    ipmi_idracvalidator_command
+*
+* Description:      This function returns the iDRAC6 type
+* Input:            intf            - ipmi interface
+* Output:       
+*
+* Return:           iDRAC6 type     1 - whoville 
+*                                   0 - others
+*
+******************************************************************/
+
+static int
+ipmi_idracvalidator_command (struct ipmi_intf * intf)
+{
+    struct ipmi_rs * rsp = NULL;
+    struct ipmi_rq req = {0};
+    uint8_t data[4];
+
+    req.msg.netfn = IPMI_NETFN_APP;
+    req.msg.lun = 0;
+    req.msg.cmd = IPMI_GET_SYS_INFO;
+    req.msg.data_len = 4;
+    req.msg.data = data;
+    data[0] = 0;
+    data[1] = IPMI_DELL_IDRAC_VALIDATOR;
+    data[2] = 2;
+    data[3] = 0;
+
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL) {
+        /*lprintf(LOG_ERR, " Error getting IMC type"); */
+        return -1;
+    } else if (rsp->ccode > 0) {
+        /*lprintf(LOG_ERR, " Error getting IMC type: %s",
+        val2str(rsp->ccode, completion_code_vals));  */
+        return -1;
+    }
+    if( (0x0A == rsp->data[10]) || (0x0D ==rsp->data[10]) )
+    {
+        iDRAC_FLAG=1;
+    }
+    else
+    {
+        iDRAC_FLAG=0;
+    }       
+    IMC_Type = rsp->data[10];
+    
+    return 0;
+}
+
+/*****************************************************************
+* Function Name:    ipmi_lcd_get_configure_command_wh
+*
+* Description:      This function returns current lcd configuration for Dell OEM LCD command
+* Input:            intf            - ipmi interface
+* Global:           lcd_mode - lcd mode setting
+* Output:    
+*
+* Return:           returns the current lcd configuration
+*                   0 = User defined
+*                   1 = Default
+*                   2 = None
+*
+******************************************************************/ 
+static int
+ipmi_lcd_get_configure_command_wh (struct ipmi_intf * intf)
+{
+    struct ipmi_rs * rsp = NULL;
+    struct ipmi_rq req = {0};
+    uint8_t data[4];
+
+    req.msg.netfn = IPMI_NETFN_APP;
+    req.msg.lun = 0;
+    req.msg.cmd = IPMI_GET_SYS_INFO;
+    req.msg.data_len = 4;
+    req.msg.data = data;
+    data[0] = 0;
+    data[1] = IPMI_DELL_LCD_CONFIG_SELECTOR;
+    data[2] = 0;
+    data[3] = 0;
+
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL) {
+        lprintf(LOG_ERR, " Error getting LCD configuration");
+        return -1;
+    }else if ((rsp->ccode == 0xc1)||(rsp->ccode == 0xcb)){
+
+        lprintf(LOG_ERR, " Error getting LCD configuration: Command not supported on this system."); 
+
+    } else if (rsp->ccode > 0) {
+        lprintf(LOG_ERR, " Error getting LCD configuration: %s",
+            val2str(rsp->ccode, completion_code_vals));
+        return -1;
+    }
+
+    lcd_mode= *((LCD_MODE*)(rsp->data));
+    return 0;
+}
+
+
+/*****************************************************************
+* Function Name:    ipmi_lcd_get_configure_command
+*
+* Description:   This function returns current lcd configuration for Dell OEM LCD command
+* Input:         intf            - ipmi interface
+* Output:        command         - user defined / default / none / ipv4 / mac address / 
+                 system name / service tag / ipv6 / temp / system watt / asset tag
+*
+* Return:             
+*
+******************************************************************/
+
+static int
+ipmi_lcd_get_configure_command (struct ipmi_intf * intf,
+                                uint8_t *command)
+{
+    struct ipmi_rs * rsp = NULL;
+    struct ipmi_rq req = {0};
+    uint8_t data[4];
+
+    req.msg.netfn = IPMI_NETFN_APP;
+    req.msg.lun = 0;
+    req.msg.cmd = IPMI_GET_SYS_INFO;
+    req.msg.data_len = 4;
+    req.msg.data = data;
+    data[0] = 0;
+    data[1] = IPMI_DELL_LCD_CONFIG_SELECTOR;
+    data[2] = 0;
+    data[3] = 0;
+
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL)
+    {
+        lprintf(LOG_ERR, " Error getting LCD configuration");
+        return -1;
+    }
+    else if ((rsp->ccode == 0xc1)||(rsp->ccode == 0xcb))
+    {
+        lprintf(LOG_ERR, " Error getting LCD configuration: Command not supported on this system."); 
+        return -1;
+    }
+    else if (rsp->ccode > 0) 
+    {
+        lprintf(LOG_ERR, " Error getting LCD configuration: %s",
+            val2str(rsp->ccode, completion_code_vals));
+        return -1;
+    }
+
+    /* rsp->data[0] is the rev */
+    *command = rsp->data[1];
+
+    return 0;
+}
+
+/*****************************************************************
+* Function Name:    ipmi_lcd_set_configure_command
+*
+* Description:      This function updates current lcd configuration 
+* Input:            intf            - ipmi interface
+*                   command         - user defined / default / none / ipv4 / mac address / 
+*                        system name / service tag / ipv6 / temp / system watt / asset tag
+* Output:
+* Return:             
+*
+******************************************************************/
+
+static int
+ipmi_lcd_set_configure_command (struct ipmi_intf * intf, int command)
+{
+#define LSCC_DATA_LEN 2
+
+    struct ipmi_rs * rsp = NULL;
+    struct ipmi_rq req = {0};
+    uint8_t data[2];
+
+    req.msg.netfn = IPMI_NETFN_APP;
+    req.msg.lun = 0;
+    req.msg.cmd = IPMI_SET_SYS_INFO;
+    req.msg.data_len = 2;
+    req.msg.data = data;
+    data[0] = IPMI_DELL_LCD_CONFIG_SELECTOR;
+    data[1] = command;                      /* command - custom, default, none */
+
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL) 
+    {
+        lprintf(LOG_ERR, " Error setting LCD configuration");
+        return -1;
+    }
+    else if ((rsp->ccode == 0xc1)||(rsp->ccode == 0xcb))
+    {
+        lprintf(LOG_ERR, " Error setting LCD configuration: Command not supported on this system."); 
+
+    }
+    else if (rsp->ccode > 0) 
+    {
+        lprintf(LOG_ERR, " Error setting LCD configuration: %s",
+            val2str(rsp->ccode, completion_code_vals));
+
+        return -1;
+    }
+
+    return 0;
+}
+
+
+/*****************************************************************
+* Function Name:    ipmi_lcd_set_configure_command
+*
+* Description:      This function updates current lcd configuration 
+* Input:            intf            - ipmi interface
+*                   mode            - user defined / default / none 
+*                   lcdquallifier   - lcd quallifier id
+*                   errordisp       - error number
+* Output:
+* Return:                
+*
+******************************************************************/ 
+static int
+ipmi_lcd_set_configure_command_wh (struct ipmi_intf * intf, 
+                                   uint32_t  mode,
+                                   uint16_t lcdquallifier,
+                                   uint8_t errordisp)
+{
+#define LSCC_DATA_LEN 2
+
+    struct ipmi_rs * rsp = NULL;
+    struct ipmi_rq req = {0};
+    uint8_t data[13];
+
+    ipmi_lcd_get_configure_command_wh(intf);
+    req.msg.netfn = IPMI_NETFN_APP;
+    req.msg.lun = 0;
+    req.msg.cmd = IPMI_SET_SYS_INFO;
+    req.msg.data_len = 13;
+    req.msg.data = data;
+    data[0] = IPMI_DELL_LCD_CONFIG_SELECTOR;
+
+    if(mode!=0xFF)
+    {
+
+        data[1] = mode&0xFF;                    /* command - custom, default, none*/
+        data[2]=(mode&0xFF00)>>8;
+        data[3]=(mode&0xFF0000)>>16;
+        data[4]=(mode&0xFF000000)>>24;
+    }
+    else
+    {
+        data[1] = (lcd_mode.lcdmode)&0xFF;                      /* command - custom, default, none*/
+        data[2]=((lcd_mode.lcdmode)&0xFF00)>>8;
+        data[3]=((lcd_mode.lcdmode)&0xFF0000)>>16;
+        data[4]=((lcd_mode.lcdmode)&0xFF000000)>>24;
+    }
+
+    if(lcdquallifier!=0xFF)
+    {
+        if(lcdquallifier==0x01)
+        {
+            data[5] =(lcd_mode.lcdquallifier)|0x01;                 /* command - custom, default, none*/
+
+        }
+        else  if(lcdquallifier==0x00)
+        {
+            data[5] =(lcd_mode.lcdquallifier)&0xFE;                 /* command - custom, default, none*/
+        }
+        else if (lcdquallifier==0x03)
+        {
+            data[5] =(lcd_mode.lcdquallifier)|0x02;                 /* command - custom, default, none*/
+        }
+        else if (lcdquallifier==0x02)
+        {
+            data[5] =(lcd_mode.lcdquallifier)&0xFD; 
+        }
+    }
+    else
+    {
+        data[5]=lcd_mode.lcdquallifier;
+    }   
+    if(errordisp!=0xFF)
+    {
+        data[11]=errordisp;
+    }
+    else
+    {
+        data[11]=lcd_mode.error_display;
+    }
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL) 
+    {
+        lprintf(LOG_ERR, " Error setting LCD configuration");
+        return -1;
+    }
+    else if ((rsp->ccode == 0xc1)||(rsp->ccode == 0xcb))
+    {
+        lprintf(LOG_ERR, " Error setting LCD configuration: Command not supported on this system."); 
+    }
+    else if (rsp->ccode > 0) 
+    {
+        lprintf(LOG_ERR, " Error setting LCD configuration: %s",
+            val2str(rsp->ccode, completion_code_vals));
+
+        return -1;
+    }
+
+    return 0;
+}
+
+
+
+/*****************************************************************
+* Function Name:    ipmi_lcd_get_single_line_text
+*
+* Description:    This function updates current lcd configuration 
+* Input:          intf            - ipmi interface
+*                 lcdstring       - new string to be updated 
+*                 max_length      - length of the string
+* Output:
+* Return:              
+*
+******************************************************************/
+
+static int
+ipmi_lcd_get_single_line_text (struct ipmi_intf * intf, char* lcdstring, uint8_t max_length)
+{
+    struct ipmi_rs * rsp = NULL;
+    struct ipmi_rq req = {0};
+    uint8_t data[4];
+    IPMI_DELL_LCD_STRING * lcdstringblock;
+    int lcdstring_len = 0;
+    int bytes_copied = 0;
+    int ii;
+
+    for (ii = 0; ii < 4; ii++) {
+        int bytes_to_copy;
+
+        req.msg.netfn = IPMI_NETFN_APP;
+        req.msg.lun = 0;
+        req.msg.cmd = IPMI_GET_SYS_INFO;
+        req.msg.data_len = 4;
+        req.msg.data = data;
+        data[0] = 0;                            /* get parameter*/
+        data[1] = IPMI_DELL_LCD_STRING_SELECTOR;
+        data[2] = ii;                           /* block selector*/
+        data[3] = 00;                           /* set selector (n/a)*/
+
+        rsp = intf->sendrecv(intf, &req);
+        if (rsp == NULL) {
+            lprintf(LOG_ERR, " Error getting text data");
+            return -1;
+        } else if (rsp->ccode > 0) {
+            lprintf(LOG_ERR, " Error getting text data: %s",
+                val2str(rsp->ccode, completion_code_vals));
+            return -1;
+        }
+
+        lcdstringblock = (IPMI_DELL_LCD_STRING *) (void *) rsp->data;
+
+        /* first block is different - 14 bytes*/
+        if (0 == ii)
+        {
+            lcdstring_len = lcdstringblock->lcd_string.selector_0_string.length;
+
+            if (lcdstring_len < 1 || lcdstring_len > max_length)
+                break;
+
+            bytes_to_copy = MIN(lcdstring_len, IPMI_DELL_LCD_STRING1_SIZE);
+            memcpy (lcdstring, lcdstringblock->lcd_string.selector_0_string.data, bytes_to_copy);
+        }
+        else
+        {
+            int string_offset;
+
+            bytes_to_copy = MIN(lcdstring_len - bytes_copied, IPMI_DELL_LCD_STRINGN_SIZE);
+            if (bytes_to_copy < 1)
+                break;
+            string_offset = IPMI_DELL_LCD_STRING1_SIZE + IPMI_DELL_LCD_STRINGN_SIZE * (ii-1);
+            memcpy (lcdstring+string_offset, lcdstringblock->lcd_string.selector_n_data, bytes_to_copy);
+        }
+
+        bytes_copied += bytes_to_copy;
+        if (bytes_copied >= lcdstring_len)
+            break;
+    }
+    return 0;
+}
+
+/*****************************************************************
+* Function Name:    ipmi_lcd_get_info_wh
+*
+* Description:     This function prints current lcd configuration for whoville platform
+* Input:           intf            - ipmi interface
+* Output:
+* Return:              
+*
+******************************************************************/
+
+static int
+ipmi_lcd_get_info_wh(struct ipmi_intf * intf)
+
+{
+    struct ipmi_rs * rsp = NULL;
+    struct ipmi_rq req = {0};
+    uint8_t data[4];
+    uint8_t command = 0;
+    IPMI_DELL_LCD_CAPS* lcd_caps;
+    char lcdstring[IPMI_DELL_LCD_STRING_LENGTH_MAX+1] = {0};
+    int rc;
+
+
+    printf("LCD info\n");
+
+    if (ipmi_lcd_get_configure_command_wh (intf) != 0) 
+    {
+        return -1;
+    }
+    else 
+    {
+        if (lcd_mode.lcdmode== IPMI_DELL_LCD_CONFIG_DEFAULT) 
+        {
+            char text[IPMI_DELL_LCD_STRING_LENGTH_MAX+1] = {0};
+
+            ipmi_lcd_get_platform_model_name(intf, text, 
+                IPMI_DELL_LCD_STRING_LENGTH_MAX,
+                IPMI_DELL_PLATFORM_MODEL_NAME_SELECTOR);
+
+            if (text == NULL)
+                return -1;
+            printf("    Setting:Model name\n");
+            printf("    Line 1:  %s\n", text);
+        }
+        else if (lcd_mode.lcdmode == IPMI_DELL_LCD_CONFIG_NONE) 
+        {
+            printf("    Setting:   none\n");
+        }
+        else if (lcd_mode.lcdmode == IPMI_DELL_LCD_CONFIG_USER_DEFINED) 
+        {
+            req.msg.netfn = IPMI_NETFN_APP;
+            req.msg.lun = 0;
+            req.msg.cmd = IPMI_GET_SYS_INFO;
+            req.msg.data_len = 4;
+            req.msg.data = data;
+            data[0] = 0;                            /* get parameter*/
+            data[1] = IPMI_DELL_LCD_GET_CAPS_SELECTOR;
+            data[2] = 0;                            /* set selector (n/a)*/
+            data[3] = 0;                            /* block selector (n/a)*/
+
+            printf("    Setting: User defined\n");
+
+            rsp = intf->sendrecv(intf, &req);
+            if (rsp == NULL)
+            {
+                lprintf(LOG_ERR, " Error getting LCD capabilities.");
+                return -1;
+            }
+            else if ((rsp->ccode == 0xc1)||(rsp->ccode == 0xcb))
+            {
+                lprintf(LOG_ERR, " Error getting LCD capabilities: Command not supported on this system.");
+            }
+            else if (rsp->ccode > 0) 
+            {
+                lprintf(LOG_ERR, " Error getting LCD capabilities: %s",
+                    val2str(rsp->ccode, completion_code_vals));
+                return -1;
+            }
+
+            lcd_caps = (IPMI_DELL_LCD_CAPS *)rsp->data;
+            if (lcd_caps->number_lines > 0) 
+            {
+                memset(lcdstring, 0, IPMI_DELL_LCD_STRING_LENGTH_MAX+1);
+
+                rc = ipmi_lcd_get_single_line_text (intf, lcdstring, lcd_caps->max_chars[0]);
+                printf("    Text:    %s\n", lcdstring);
+            }
+            else 
+            {
+                printf("    No lines to show\n");
+            }
+        }
+        else if (lcd_mode.lcdmode == IPMI_DELL_LCD_iDRAC_IPV4ADRESS) 
+        {
+            printf("    Setting:   IPV4 Address\n");
+        }
+        else if (lcd_mode.lcdmode == IPMI_DELL_LCD_IDRAC_MAC_ADDRESS) 
+        {
+            printf("    Setting:   MAC Address\n");
+        }
+        else if (lcd_mode.lcdmode == IPMI_DELL_LCD_OS_SYSTEM_NAME) 
+        {
+            printf("    Setting:   OS System Name\n");
+        }
+        else if (lcd_mode.lcdmode == IPMI_DELL_LCD_SERVICE_TAG) 
+        {
+            printf("    Setting:   System Tag\n");
+        }
+        else if (lcd_mode.lcdmode == IPMI_DELL_LCD_iDRAC_IPV6ADRESS) 
+        {
+            printf("    Setting:  IPV6 Address\n");
+        }
+        else if (lcd_mode.lcdmode == IPMI_DELL_LCD_AMBEINT_TEMP) 
+        {
+            printf("    Setting:  Ambient Temp\n");
+            if(lcd_mode.lcdquallifier&0x02)
+                printf("    Unit:  F\n");  
+            else
+                printf("    Unit:  C\n");  
+        }
+        else if (lcd_mode.lcdmode == IPMI_DELL_LCD_SYSTEM_WATTS)
+        {
+            printf("    Setting:  System Watts\n");
+
+            if(lcd_mode.lcdquallifier&0x01)
+                printf("    Unit:  BTU/hr\n");  
+            else
+                printf("    Unit:  Watt\n"); 
+
+        }
+        if(lcd_mode.error_display==IPMI_DELL_LCD_ERROR_DISP_SEL)
+            printf("    Error Display:  SEL\n");
+        else if(lcd_mode.error_display==IPMI_DELL_LCD_ERROR_DISP_VERBOSE)
+            printf("    Error Display:  Simple\n");
+    }
+
+    return 0;
+}
+
+/*****************************************************************
+* Function Name:    ipmi_lcd_get_info
+*
+* Description:      This function prints current lcd configuration for platform other than whoville
+* Input:            intf            - ipmi interface
+* Output:
+* Return:              
+*
+******************************************************************/
+static int ipmi_lcd_get_info(struct ipmi_intf * intf)
+{
+    struct ipmi_rs * rsp = NULL;
+    struct ipmi_rq req = {0};
+    uint8_t data[4];
+    IPMI_DELL_LCD_CAPS * lcd_caps;
+    uint8_t command = 0;
+    char lcdstring[IPMI_DELL_LCD_STRING_LENGTH_MAX+1] = {0};
+    int rc; 
+
+    printf("LCD info\n");
+
+    if (ipmi_lcd_get_configure_command (intf, &command) != 0)
+    {
+        return -1;
+    }
+    else
+    {
+        if (command == IPMI_DELL_LCD_CONFIG_DEFAULT)
+        {
+            memset (lcdstring,0,IPMI_DELL_LCD_STRING_LENGTH_MAX+1);
+
+            ipmi_lcd_get_platform_model_name(intf, lcdstring, IPMI_DELL_LCD_STRING_LENGTH_MAX,
+                IPMI_DELL_PLATFORM_MODEL_NAME_SELECTOR);
+
+            printf("    Setting: default\n");
+            printf("    Line 1:  %s\n", lcdstring);
+        }
+        else if (command == IPMI_DELL_LCD_CONFIG_NONE)
+        {
+            printf("    Setting:   none\n");
+        }
+        else if (command == IPMI_DELL_LCD_CONFIG_USER_DEFINED)
+        {
+            req.msg.netfn = IPMI_NETFN_APP;
+            req.msg.lun = 0;
+            req.msg.cmd = IPMI_GET_SYS_INFO;
+            req.msg.data_len = 4;
+            req.msg.data = data;
+            data[0] = 0;                            /* get parameter */
+            data[1] = IPMI_DELL_LCD_GET_CAPS_SELECTOR;
+            data[2] = 0;                            /* set selector (n/a) */
+            data[3] = 0;                            /* block selector (n/a) */
+
+            printf("    Setting: custom\n");
+
+            rsp = intf->sendrecv(intf, &req);
+            if (rsp == NULL)
+            {
+                lprintf(LOG_ERR, " Error getting LCD capabilities.");
+                return -1;
+            }
+            else if ((rsp->ccode == 0xc1)||(rsp->ccode == 0xcb))
+            {
+                lprintf(LOG_ERR, " Error getting LCD capabilities: Command not supported on this system.");
+            }
+            else if (rsp->ccode > 0)
+            {
+                lprintf(LOG_ERR, " Error getting LCD capabilities: %s",
+                    val2str(rsp->ccode, completion_code_vals));
+                return -1;
+            }
+
+            lcd_caps = (IPMI_DELL_LCD_CAPS *)(void *)rsp->data;
+            if (lcd_caps->number_lines > 0)
+            {
+                memset (lcdstring,0,IPMI_DELL_LCD_STRING_LENGTH_MAX+1);
+                rc = ipmi_lcd_get_single_line_text (intf, lcdstring, lcd_caps->max_chars[0]);
+                printf("    Text:    %s\n", lcdstring);
+            }
+            else
+            {
+                printf("    No lines to show\n");
+            }
+        }
+    }
+
+    return 0;
+}
+
+/*****************************************************************
+* Function Name:    ipmi_lcd_get_status_val
+*
+* Description:      This function gets current lcd configuration 
+* Input:            intf            - ipmi interface
+* Output:           lcdstatus       - KVM Status & Lock Status
+* Return:           
+*
+******************************************************************/
+
+static int
+ipmi_lcd_get_status_val(struct ipmi_intf * intf, LCD_STATUS* lcdstatus)
+{
+    struct ipmi_rs * rsp = NULL;
+    struct ipmi_rq req = {0};
+    uint8_t data[4];
+
+
+    req.msg.netfn = IPMI_NETFN_APP;
+    req.msg.lun = 0;
+    req.msg.cmd = IPMI_GET_SYS_INFO;
+    req.msg.data_len = 4;
+    req.msg.data = data;
+    data[0] = 0;                            /* get parameter */
+    data[1] = IPMI_DELL_LCD_STATUS_SELECTOR;
+    data[2] = 0;                            /* block selector */
+    data[3] = 0;            
+    /* set selector (n/a) */
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL) 
+    {
+        lprintf(LOG_ERR, " Error getting LCD Status");
+        return -1;
+    }
+    else if ((rsp->ccode == 0xc1)||(rsp->ccode == 0xcb)) 
+    {
+        lprintf(LOG_ERR, " Error getting LCD status: Command not supported on this system.");
+        return -1;
+    }
+    else if (rsp->ccode > 0) 
+    {
+        lprintf(LOG_ERR, " Error getting LCD Status: %s",
+            val2str(rsp->ccode, completion_code_vals));
+        return -1;
+    }
+
+    /*lcdstatus= (LCD_STATUS* ) rsp->data; */
+
+    lcdstatus->vKVM_status=rsp->data[1];
+    lcdstatus->lock_status=rsp->data[2];
+
+    return 0;
+}
+
+
+/*****************************************************************
+* Function Name:    IsLCDSupported
+*
+* Description:   This function returns whether lcd supported or not
+* Input:              
+* Output:       
+* Return:               
+*
+******************************************************************/
+static int IsLCDSupported ()
+{
+    return LcdSupported;
+}
+
+/*****************************************************************
+* Function Name:         CheckLCDSupport
+*
+* Description:  This function checks whether lcd supported or not
+* Input:        intf            - ipmi interface
+* Output:       
+* Return:               
+*
+******************************************************************/
+static void CheckLCDSupport(struct ipmi_intf * intf)
+{
+    struct ipmi_rs * rsp = NULL;
+    struct ipmi_rq req = {0};
+    uint8_t data[4];
+
+    LcdSupported = 0;
+
+    req.msg.netfn = IPMI_NETFN_APP;
+    req.msg.lun = 0;
+    req.msg.cmd = IPMI_GET_SYS_INFO;
+    req.msg.data_len = 4;
+    req.msg.data = data;
+    data[0] = 0;                            /* get parameter */
+    data[1] = IPMI_DELL_LCD_STATUS_SELECTOR;
+    data[2] = 0;                            /* block selector */
+    data[3] = 0;            
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL) 
+    {
+        return;
+    }
+    else if ((rsp->ccode == 0xc1)||(rsp->ccode == 0xcb)) 
+    {
+        return;
+    }
+    else if (rsp->ccode > 0) 
+    {
+        return;
+    }
+    LcdSupported = 1;       
+
+}
+
+/*****************************************************************
+* Function Name:     ipmi_lcd_status_print
+*
+* Description:    This function prints current lcd configuration KVM Status & Lock Status
+* Input:          lcdstatus - KVM Status & Lock Status
+* Output:   
+* Return:               
+*
+******************************************************************/
+
+static void ipmi_lcd_status_print( LCD_STATUS lcdstatus)
+{
+    switch (lcdstatus.vKVM_status)
+    {
+    case 0x00: 
+        printf("LCD KVM Status :Inactive\n");
+        break;
+    case 0x01: 
+        printf("LCD KVM Status :Active\n");
+        break;
+    default:
+        printf("LCD KVM Status :Invalid Status\n");
+
+        break;
+    }                       
+
+    switch (lcdstatus.lock_status)
+    {
+    case 0x00: 
+        printf("LCD lock Status :View and modify\n");
+        break;
+    case 0x01: 
+        printf("LCD lock Status :View only\n");
+        break;
+    case 0x02:
+        printf("LCD lock Status :disabled\n");
+        break;
+    default:
+        printf("LCD lock Status :Invalid\n");
+        break;
+    }
+
+}
+
+/*****************************************************************
+* Function Name:     ipmi_lcd_get_status
+*
+* Description:      This function gets current lcd KVM active status & lcd access mode
+* Input:            intf            - ipmi interface
+* Output:       
+* Return:           -1 on error
+*                   0 if successful
+*
+******************************************************************/
+static int
+ipmi_lcd_get_status(struct ipmi_intf * intf )
+{
+    int rc=0;
+    LCD_STATUS  lcdstatus;
+
+    rc =ipmi_lcd_get_status_val( intf, &lcdstatus);
+    if (rc <0)
+        return -1;
+    ipmi_lcd_status_print(lcdstatus);
+
+    return rc;
+
+}
+
+/*****************************************************************
+* Function Name:     ipmi_lcd_set_kvm
+*
+* Description:       This function sets lcd KVM active status 
+* Input:             intf            - ipmi interface
+*                    status  - Inactive / Active
+* Output:    
+* Return:            -1 on error
+*                    0 if successful
+*
+******************************************************************/ 
+static int
+ipmi_lcd_set_kvm(struct ipmi_intf * intf, char status)
+{
+#define LSCC_DATA_LEN 2
+    LCD_STATUS lcdstatus;
+    int rc=0;
+    struct ipmi_rs * rsp = NULL;
+    struct ipmi_rq req = {0};
+    uint8_t data[5];
+    rc=ipmi_lcd_get_status_val(intf,&lcdstatus);
+    if (rc < 0)
+        return -1;
+    req.msg.netfn = IPMI_NETFN_APP;
+    req.msg.lun = 0;
+    req.msg.cmd = IPMI_SET_SYS_INFO;
+    req.msg.data_len = 5;
+    req.msg.data = data;
+    data[0] = IPMI_DELL_LCD_STATUS_SELECTOR;
+    data[1] = status;                       /* active- incative*/
+    data[2] = lcdstatus.lock_status;        /* full-veiw-locked */
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL) {
+        lprintf(LOG_ERR, " Error setting LCD status");
+        rc= -1;
+    }else if ((rsp->ccode == 0xc1)||(rsp->ccode == 0xcb)) {
+        lprintf(LOG_ERR, " Error getting LCD status: Command not supported on this system.");
+        return -1;
+    } else if (rsp->ccode > 0) {
+        lprintf(LOG_ERR, " Error setting LCD status: %s",
+            val2str(rsp->ccode, completion_code_vals));
+
+        rc= -1;
+    }
+
+    return rc;
+}
+
+/*****************************************************************
+* Function Name:   ipmi_lcd_set_lock
+*
+* Description:     This function sets lcd access mode 
+* Input:           intf            - ipmi interface
+*                  lock    - View and modify / View only / Diabled
+* Output:        
+* Return:          -1 on error
+*                  0 if successful
+*
+******************************************************************/ 
+static int
+ipmi_lcd_set_lock(struct ipmi_intf * intf,  char lock)
+{
+#define LSCC_DATA_LEN 2
+    LCD_STATUS lcdstatus;
+    int rc =0;
+    struct ipmi_rs * rsp = NULL;
+    struct ipmi_rq req = {0};
+    uint8_t data[5];
+    rc=ipmi_lcd_get_status_val(intf,&lcdstatus);
+    if (rc < 0)
+        return -1;
+    req.msg.netfn = IPMI_NETFN_APP;
+    req.msg.lun = 0;
+    req.msg.cmd = IPMI_SET_SYS_INFO;
+    req.msg.data_len = 5;
+    req.msg.data = data;
+    data[0] = IPMI_DELL_LCD_STATUS_SELECTOR;
+    data[1] = lcdstatus.vKVM_status;                        /* active- incative */
+    data[2] = lock;                 /* full- veiw-locked */
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL)
+    {
+        lprintf(LOG_ERR, " Error setting LCD status");
+        rc= -1;
+    }
+    if ((rsp->ccode == 0xc1)||(rsp->ccode == 0xcb)) 
+    {
+        lprintf(LOG_ERR, " Error getting LCD status: Command not supported on this system.");
+        return -1;
+    }
+    else if (rsp->ccode > 0) 
+    {
+        lprintf(LOG_ERR, " Error setting LCD status: %s",
+            val2str(rsp->ccode, completion_code_vals));
+
+        rc= -1;
+    }
+
+    return rc;
+}
+
+/*****************************************************************
+* Function Name:   ipmi_lcd_set_single_line_text
+*
+* Description:    This function sets lcd line text
+* Input:          intf            - ipmi interface
+*                 text    - lcd string
+* Output:   
+* Return:         -1 on error
+*                 0 if successful
+*
+******************************************************************/
+
+static int 
+ipmi_lcd_set_single_line_text (struct ipmi_intf * intf, char * text)
+{
+    struct ipmi_rs * rsp = NULL;
+    struct ipmi_rq req = {0};
+    uint8_t data[18];
+    int bytes_to_store = strlen(text);
+    int bytes_stored = 0;
+    int ii;
+    int rc = 0;
+    if (bytes_to_store>IPMI_DELL_LCD_STRING_LENGTH_MAX)
+    {
+        lprintf(LOG_ERR, " Out of range Max limit is 62 characters");
+        return 1;
+
+    }
+    else
+    {
+        bytes_to_store = MIN(bytes_to_store, IPMI_DELL_LCD_STRING_LENGTH_MAX);
+        for (ii = 0; ii < 4; ii++) {
+            /*first block, 2 bytes parms and 14 bytes data*/
+            if (0 == ii) {
+                int size_of_copy =  
+                    MIN((bytes_to_store - bytes_stored), IPMI_DELL_LCD_STRING1_SIZE);
+                if (size_of_copy < 0)           /* allow 0 string length*/
+                    break;
+                req.msg.netfn = IPMI_NETFN_APP;
+                req.msg.lun = 0;
+                req.msg.cmd = IPMI_SET_SYS_INFO;
+                req.msg.data_len = size_of_copy + 4; /* chars, selectors and sizes*/
+                req.msg.data = data;
+                data[0] = IPMI_DELL_LCD_STRING_SELECTOR;
+                data[1] = ii;                           /* block number to use (0)*/
+                data[2] = 0;                            /*string encoding*/
+                data[3] = bytes_to_store;       /* total string length*/
+                memcpy (data+4, text+bytes_stored, size_of_copy);
+                bytes_stored += size_of_copy;
+            } else {
+                int size_of_copy =  
+                    MIN((bytes_to_store - bytes_stored), IPMI_DELL_LCD_STRINGN_SIZE);
+                if (size_of_copy <= 0)
+                    break;
+                req.msg.netfn = IPMI_NETFN_APP;
+                req.msg.lun = 0;
+                req.msg.cmd = IPMI_SET_SYS_INFO;
+                req.msg.data_len = size_of_copy + 2;
+                req.msg.data = data;
+                data[0] = IPMI_DELL_LCD_STRING_SELECTOR;
+                data[1] = ii;                           /* block number to use (1,2,3)*/
+                memcpy (data+2, text+bytes_stored, size_of_copy);
+                bytes_stored += size_of_copy;
+            }
+
+            rsp = intf->sendrecv(intf, &req);
+            if (rsp == NULL) {
+                lprintf(LOG_ERR, " Error setting text data");
+                rc = -1;
+            } else if (rsp->ccode > 0) {
+                lprintf(LOG_ERR, " Error setting text data: %s",
+                    val2str(rsp->ccode, completion_code_vals));
+                rc = -1;
+            }
+        }
+    }
+    return rc;
+}
+
+/*****************************************************************
+* Function Name:   ipmi_lcd_set_text
+*
+* Description:     This function sets lcd line text
+* Input:           intf            - ipmi interface
+*                  text    - lcd string
+*                  line_number- line number
+
+* Output:       
+* Return:          -1 on error
+*                  0 if successful
+*
+******************************************************************/
+
+static int
+ipmi_lcd_set_text(struct ipmi_intf * intf, char * text, int line_number)
+{
+    int rc = 0;
+
+    struct ipmi_rs * rsp = NULL;
+    struct ipmi_rq req = {0};
+    uint8_t data[4];
+    IPMI_DELL_LCD_CAPS * lcd_caps;
+
+    req.msg.netfn = IPMI_NETFN_APP;
+    req.msg.lun = 0;
+    req.msg.cmd = IPMI_GET_SYS_INFO;
+    req.msg.data_len = 4;
+    req.msg.data = data;
+    data[0] = 0;                            /* get parameter*/
+    data[1] = IPMI_DELL_LCD_GET_CAPS_SELECTOR;
+    data[2] = 0;                            /* set selector (n/a)*/
+    data[3] = 0;                            /* block selector (n/a)*/
+
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL) 
+    {
+        lprintf(LOG_ERR, " Error getting LCD capabilities");
+        return -1;
+    }
+    else if (rsp->ccode > 0) 
+    {
+        lprintf(LOG_ERR, " Error getting LCD capabilities: %s",
+            val2str(rsp->ccode, completion_code_vals));
+
+        return -1;
+    }
+
+    lcd_caps = (IPMI_DELL_LCD_CAPS *)(void *)rsp->data;
+
+    if (lcd_caps->number_lines > 0) {
+        rc = ipmi_lcd_set_single_line_text (intf, text);
+    } else {
+        lprintf(LOG_ERR, "LCD does not have any lines that can be set");
+        rc = -1;
+    }
+
+
+    return rc;
+}
+
+/*****************************************************************
+* Function Name:   ipmi_lcd_configure_wh
+*
+* Description:     This function updates the current lcd configuration
+* Input:           intf            - ipmi interface
+*                  lcdquallifier- lcd quallifier
+*                  errordisp       - error number
+*                  line_number-line number
+*                  text            - lcd string
+* Output:   
+* Return:          -1 on error
+*                  0 if successful
+*
+******************************************************************/
+
+static int
+ipmi_lcd_configure_wh (struct ipmi_intf * intf, uint32_t  mode ,
+                       uint16_t lcdquallifier, uint8_t errordisp, 
+                       int8_t line_number, char * text)
+{
+    int rc = 0;
+
+
+    if (IPMI_DELL_LCD_CONFIG_USER_DEFINED == mode)
+        /* Any error was reported earlier. */
+        rc = ipmi_lcd_set_text(intf, text, line_number);
+
+
+    if (rc == 0)
+
+        rc = ipmi_lcd_set_configure_command_wh (intf, mode ,lcdquallifier,errordisp);
+
+    return rc;
+}
+
+
+/*****************************************************************
+* Function Name:   ipmi_lcd_configure
+*
+* Description:     This function updates the current lcd configuration
+* Input:           intf            - ipmi interface
+*                  command- lcd command
+*                  line_number-line number
+*                  text            - lcd string
+* Output:   
+* Return:          -1 on error
+*                  0 if successful
+*
+******************************************************************/
+
+static int
+ipmi_lcd_configure (struct ipmi_intf * intf, int command, 
+                    int8_t line_number, char * text)
+{
+    int rc = 0;
+
+    if (IPMI_DELL_LCD_CONFIG_USER_DEFINED == command)
+        rc = ipmi_lcd_set_text(intf, text, line_number);
+
+    if (rc == 0)
+        rc = ipmi_lcd_set_configure_command (intf, command);
+
+    return rc;
+}
+
+
+/*****************************************************************
+* Function Name:   ipmi_lcd_usage
+*
+* Description:   This function prints help message for lcd command
+* Input:               
+* Output:       
+*
+* Return:              
+*
+******************************************************************/
+
+static void
+ipmi_lcd_usage(void)
+{
+    lprintf(LOG_NOTICE, "");
+    if(iDRAC_FLAG==0)
+    {
+        lprintf(LOG_NOTICE, "   lcd set {none}|{default}|{custom <text>}");
+        lprintf(LOG_NOTICE, "      Set LCD text displayed during non-fault conditions");
+    }
+    else if(iDRAC_FLAG==1)
+    {
+        lprintf(LOG_NOTICE, "   lcd set {mode}|{lcdqualifier}|{errordisplay}");
+        lprintf(LOG_NOTICE, "");
+        lprintf(LOG_NOTICE, "   lcd set mode {none}|{modelname}|{ipv4address}|{macaddress}|");
+        lprintf(LOG_NOTICE, "   {systemname}|{servicetag}|{ipv6address}|{ambienttemp}");
+        lprintf(LOG_NOTICE, "   {systemwatt }|{assettag}|{userdefined}<text>");
+        lprintf(LOG_NOTICE, "");
+        lprintf(LOG_NOTICE, "   lcd set lcdqualifier {watt}|{btuphr}|{celsius}|{fahrenheit}");
+        lprintf(LOG_NOTICE, "");
+        lprintf(LOG_NOTICE, "   lcd set errordisplay {sel}|{simple}");
+    }
+    lprintf(LOG_NOTICE, "");
+    lprintf(LOG_NOTICE, "   lcd info");
+    lprintf(LOG_NOTICE, "      Show LCD text that is displayed during non-fault conditions");
+    lprintf(LOG_NOTICE, "");
+    lprintf(LOG_NOTICE, "");
+    lprintf(LOG_NOTICE, "   lcd set vkvm{active}|{inactive}");
+    lprintf(LOG_NOTICE, "           Set vKVM active and inactive, message will be displayed on lcd"); 
+    lprintf(LOG_NOTICE, " when vKVM is active and vKVM session is in progress");
+    lprintf(LOG_NOTICE, "");
+    lprintf(LOG_NOTICE, "   lcd set frontpanelaccess {viewandmodify}|{viewonly}|{disabled}");
+    lprintf(LOG_NOTICE, "      Set LCD mode to view and modify, view only or disabled ");
+    lprintf(LOG_NOTICE, "");
+    lprintf(LOG_NOTICE, "   lcd status");
+    lprintf(LOG_NOTICE, "           Show LCD Status for vKVM display<active|inactive>");
+    lprintf(LOG_NOTICE, "   and Front Panel access mode {viewandmodify}|{viewonly}|{disabled} ");
+    lprintf(LOG_NOTICE, "");
+}
+
+/*****************************************************************
+* Function Name:       ipmi_delloem_mac_main
+*
+* Description:         This function processes the delloem mac command
+* Input:               intf    - ipmi interface
+                       argc    - no of arguments
+                       argv    - argument string array
+* Output:        
+*
+* Return:              return code     0 - success
+*                         -1 - failure
+*
+******************************************************************/
+
+
+static int ipmi_delloem_mac_main (struct ipmi_intf * intf, int argc, char ** argv)
+{
+    int rc = 0;
+
+    current_arg++;
+    if (argc == 1)
+    {
+        rc = ipmi_macinfo(intf, 0xff);
+    }
+    else if (strncmp(argv[current_arg], "list\0", 5) == 0)
+    {
+        rc = ipmi_macinfo(intf, 0xff);
+    }
+    else if (strncmp(argv[current_arg], "get\0", 4) == 0)
+    {
+        current_arg++;
+        if (argv[current_arg] == NULL)
+        {
+            ipmi_mac_usage();
+            return -1;
+        }
+        int currIdInt;
+        make_int(argv[current_arg],&currIdInt);
+        if(currIdInt>8)
+        {
+            lprintf(LOG_ERR, "Invalid NIC number. The NIC number should be between 0-8\n");
+            ipmi_mac_usage();
+            return -1;
+        }
+        rc = ipmi_macinfo(intf, currIdInt);
+    }
+    else
+    {
+        ipmi_mac_usage();
+    }
+
+}
+
+
+/*****************************************************************
+* Function Name:     make_int
+*
+* Description:   This function convert string into integer
+* Input:         str     - decimal number string
+* Output:        value   - integer value
+* Return:                
+*
+******************************************************************/
+static int make_int(const char *str, int *value)
+{
+    char *tmp=NULL;
+    *value = strtol(str,&tmp,0);
+    if ( tmp-str != strlen(str) )
+    {
+        return -1;
+    }
+    return 0;
+}
+
+
+
+
+
+EmbeddedNICMacAddressType EmbeddedNICMacAddress;
+
+EmbeddedNICMacAddressType_10G EmbeddedNICMacAddress_10G;
+
+static void InitEmbeddedNICMacAddressValues ()
+{
+    uint8_t i;
+    uint8_t j;
+
+
+    for (i=0;i<MAX_LOM;i++)
+    {
+        EmbeddedNICMacAddress.LOMMacAddress[i].BladSlotNumber = 0;
+        EmbeddedNICMacAddress.LOMMacAddress[i].MacType = LOM_MACTYPE_RESERVED;
+        EmbeddedNICMacAddress.LOMMacAddress[i].EthernetStatus = LOM_ETHERNET_RESERVED;
+        EmbeddedNICMacAddress.LOMMacAddress[i].NICNumber = 0;
+        EmbeddedNICMacAddress.LOMMacAddress[i].Reserved = 0;
+        for (j=0;j<MACADDRESSLENGH;j++)
+        {
+            EmbeddedNICMacAddress.LOMMacAddress[i].MacAddressByte[j] = 0;
+            EmbeddedNICMacAddress_10G.MacAddress[i].MacAddressByte[j] = 0;
+        }
+    }
+}
+
+uint8_t UseVirtualMacAddress = 0;
+#define VIRTUAL_MAC_OFFSET (2)
+static int ipmi_macinfo_drac_idrac_virtual_mac(struct ipmi_intf* intf,uint8_t NicNum)
+{
+    struct ipmi_rs * rsp;
+    struct ipmi_rq req;
+
+    uint8_t msg_data[30];
+    uint8_t VirtualMacAddress [MACADDRESSLENGH];
+    uint8_t input_length=0;
+    uint8_t j;
+    uint8_t length;
+    uint8_t i;
+
+
+    if (0xff==NicNum || IDRAC_NIC_NUMBER==NicNum )
+    {
+        UseVirtualMacAddress = 0;
+
+        input_length = 0;
+        msg_data[input_length++] = 1; /*Get*/
+
+        req.msg.netfn = DELL_OEM_NETFN;
+        req.msg.lun = 0;                
+        req.msg.cmd = GET_IDRAC_VIRTUAL_MAC;
+        req.msg.data = msg_data;
+        req.msg.data_len = input_length;
+
+        rsp = intf->sendrecv(intf, &req);
+        if (rsp == NULL)
+        {
+            return -1;
+        }
+        if (rsp->ccode > 0) 
+        {
+            return -1;
+        }
+        memcpy(VirtualMacAddress,((rsp->data)+VIRTUAL_MAC_OFFSET),MACADDRESSLENGH);
+
+        for (i=0;i<MACADDRESSLENGH;i++)
+        {
+            if (0 != VirtualMacAddress [i])
+            {
+                UseVirtualMacAddress = 1;
+            }       
+        }
+        if (0 == UseVirtualMacAddress)
+            return -1;              
+        if (IMC_IDRAC_10G == IMC_Type)
+            printf ("\n\rDRAC MAC Address ");
+        else
+            printf ("\n\riDRAC6 MAC Address ");
+
+        for (j=0;j<5;j++)
+            printf("%02x:",VirtualMacAddress[j]);
+        printf("%02x",VirtualMacAddress[j]);
+
+        printf ("\n\r");        
+
+    }  
+    return 0;
+}
+
+
+/*****************************************************************
+* Function Name:    ipmi_macinfo_drac_idrac_mac
+*
+* Description:      This function retrieves the mac address of DRAC or iDRAC
+* Input:            NicNum
+* Output:                 
+* Return:               
+*
+******************************************************************/
+
+static int ipmi_macinfo_drac_idrac_mac(struct ipmi_intf* intf,uint8_t NicNum)
+{
+    struct ipmi_rs * rsp;
+    struct ipmi_rq req;
+
+    uint8_t msg_data[30];
+    uint8_t input_length=0;
+    uint8_t iDRAC6MacAddressByte[MACADDRESSLENGH];
+    uint8_t j;
+
+    ipmi_macinfo_drac_idrac_virtual_mac (intf,NicNum);
+
+
+    if ((0xff==NicNum || IDRAC_NIC_NUMBER==NicNum) && 0 == UseVirtualMacAddress)
+    {
+
+        input_length = 0;
+
+        msg_data[input_length++] = LAN_CHANNEL_NUMBER; 
+        msg_data[input_length++] = MAC_ADDR_PARAM;  
+        msg_data[input_length++] = 0x00;                        
+        msg_data[input_length++] = 0x00;                        
+
+        req.msg.netfn = TRANSPORT_NETFN;
+        req.msg.lun = 0;                
+        req.msg.cmd = GET_LAN_PARAM_CMD;
+        req.msg.data = msg_data;
+        req.msg.data_len = input_length;
+
+        rsp = intf->sendrecv(intf, &req);
+        if (rsp == NULL)
+        {
+            lprintf(LOG_ERR, " Error in getting MAC Address");
+            return -1;
+        }
+        if (rsp->ccode > 0) 
+        {
+            lprintf(LOG_ERR, " Error in getting MAC Address (%s) \n",
+                val2str(rsp->ccode, completion_code_vals) );
+            return -1;
+        }
+
+        memcpy(iDRAC6MacAddressByte,((rsp->data)+PARAM_REV_OFFSET),MACADDRESSLENGH);
+
+        if (IMC_IDRAC_10G == IMC_Type)
+            printf ("\n\rDRAC MAC Address ");
+        else
+            printf ("\n\riDRAC6 MAC Address ");
+
+        for (j=0;j<5;j++)
+            printf("%02x:",iDRAC6MacAddressByte[j]);
+        printf("%02x",iDRAC6MacAddressByte[j]);
+
+        printf ("\n\r");        
+    }
+    return 0;
+}
+
+
+/*****************************************************************
+* Function Name:    ipmi_macinfo_10g
+*
+* Description:      This function retrieves the mac address of LOMs
+* Input:            intf      - ipmi interface
+                    NicNum    - NIC number
+* Output:               
+* Return:               
+*
+******************************************************************/
+
+static int ipmi_macinfo_10g (struct ipmi_intf* intf, uint8_t NicNum)
+{
+    struct ipmi_rs * rsp;
+    struct ipmi_rq req;
+
+    uint8_t msg_data[30];
+    uint8_t input_length=0;
+
+    uint8_t j;
+    uint8_t i;
+    uint8_t rc;
+
+    uint8_t Total_No_NICs = 0;
+
+
+    InitEmbeddedNICMacAddressValues ();
+
+    memset(msg_data, 0, sizeof(msg_data));
+    input_length = 0;
+    msg_data[input_length++] = 0x00; /* Get Parameter Command */
+    msg_data[input_length++] = EMB_NIC_MAC_ADDRESS_9G_10G;  /* OEM Param */
+
+    msg_data[input_length++] = 0x00;         
+    msg_data[input_length++] = 0x00;         
+
+    memset(&req, 0, sizeof(req));
+
+    req.msg.netfn = APP_NETFN;
+    req.msg.lun = 0;                
+    req.msg.cmd = GET_SYSTEM_INFO_CMD;
+    req.msg.data = msg_data;
+
+
+    req.msg.data_len = input_length;
+
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL) {
+        lprintf(LOG_ERR, " Error in getting MAC Address");
+        return -1;
+    }
+    if (rsp->ccode > 0) {
+        lprintf(LOG_ERR, " Error in getting MAC Address (%s) \n",
+            val2str(rsp->ccode, completion_code_vals) );
+        return -1;
+    }
+
+    Total_No_NICs = (uint8_t) rsp->data[0+PARAM_REV_OFFSET]; /* Byte 1: Total Number of Embedded NICs */
+
+    if (IDRAC_NIC_NUMBER != NicNum)
+    {
+        if (0xff == NicNum)
+        {
+            printf ("\n\rSystem LOMs");
+        }       
+        printf("\n\rNIC Number\tMAC Address\n\r");
+
+
+        memcpy(&EmbeddedNICMacAddress_10G,((rsp->data)+PARAM_REV_OFFSET+TOTAL_N0_NICS_INDEX),Total_No_NICs* MACADDRESSLENGH);
+
+
+        /*Read the LOM type and Mac Addresses */
+
+        for (i=0;i<Total_No_NICs;i++)
+        {
+            if ((0xff==NicNum) || (i == NicNum)     )
+            {       
+                printf ("\n\r%d",i);
+                printf ("\t\t");
+                for (j=0;j<5;j++)
+                {
+                    printf("%02x:",EmbeddedNICMacAddress_10G.MacAddress[i].MacAddressByte[j]);
+                }       
+                printf("%02x",EmbeddedNICMacAddress_10G.MacAddress[i].MacAddressByte[j]);
+            }               
+        }
+        printf ("\n\r");
+
+    }
+
+    ipmi_macinfo_drac_idrac_mac(intf,NicNum);
+
+
+    return 0;
+}
+
+
+/*****************************************************************
+* Function Name:      ipmi_macinfo_11g
+*
+* Description:        This function retrieves the mac address of LOMs
+* Input:              intf - ipmi interface
+* Output:               
+* Return:               
+*
+******************************************************************/
+
+static int ipmi_macinfo_11g (struct ipmi_intf* intf, uint8_t NicNum)
+{
+    struct ipmi_rs * rsp;
+    struct ipmi_rq req;
+
+    uint8_t msg_data[30];
+    uint8_t input_length=0;
+
+    uint8_t len;
+    uint8_t j;
+    uint8_t offset;
+    uint8_t maxlen;
+    uint8_t loop_count;
+    uint8_t i;
+    uint8_t rc;
+    uint8_t LOMStatus = 0;
+    uint8_t PlayingDead = 0;
+
+
+
+    offset = 0;
+    len = 8; /*eigher 8 or 16 */
+    maxlen = 64;
+    loop_count = maxlen / len;
+
+    InitEmbeddedNICMacAddressValues ();
+
+    memset(msg_data, 0, sizeof(msg_data));
+    input_length = 0;
+    msg_data[input_length++] = 0x00; /* Get Parameter Command */
+    msg_data[input_length++] = EMB_NIC_MAC_ADDRESS_11G;      /* OEM Param */
+
+    msg_data[input_length++] = 0x00;      
+    msg_data[input_length++] = 0x00;      
+    msg_data[input_length++] = 0x00;      
+    msg_data[input_length++] = 0x00;      
+
+    memset(&req, 0, sizeof(req));
+
+    req.msg.netfn = APP_NETFN;
+    req.msg.lun = 0;              
+    req.msg.cmd = GET_SYSTEM_INFO_CMD;
+    req.msg.data = msg_data;
+
+
+    req.msg.data_len = input_length;
+
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL) {
+        lprintf(LOG_ERR, " Error in getting MAC Address");
+        return -1;
+    }
+    if (rsp->ccode > 0) {
+        lprintf(LOG_ERR, " Error in getting MAC Address (%s) \n",
+            val2str(rsp->ccode, completion_code_vals) );
+        return -1;
+    }
+
+    len = 8; /*eigher 8 or 16 */
+    maxlen = (uint8_t) rsp->data[0+PARAM_REV_OFFSET];
+    loop_count = maxlen / len;
+
+    if (IDRAC_NIC_NUMBER != NicNum)
+    {
+        if (0xff == NicNum)
+        {
+            printf ("\n\rSystem LOMs");
+        }       
+        printf("\n\rNIC Number\tMAC Address\t\tStatus\n\r");
+
+
+        /*Read the LOM type and Mac Addresses */
+        offset=0;
+        for (i=0;i<loop_count;i++,offset=offset+len)
+        {
+            input_length = 4;
+            msg_data[input_length++] = offset;
+            msg_data[input_length++] = len;   
+
+            req.msg.netfn = APP_NETFN;
+            req.msg.lun = 0;
+            req.msg.cmd = GET_SYSTEM_INFO_CMD;
+            req.msg.data = msg_data;
+            req.msg.data_len = input_length;
+
+            rsp = intf->sendrecv(intf, &req);
+            if (rsp == NULL) {
+                lprintf(LOG_ERR, " Error in getting MAC Address");
+                return -1;
+            }
+            if (rsp->ccode > 0) {
+                lprintf(LOG_ERR, " Error in getting MAC Address (%s) \n",
+                    val2str(rsp->ccode, completion_code_vals) );
+                return -1;
+
+            }
+
+            memcpy(&(EmbeddedNICMacAddress.LOMMacAddress[i]),((rsp->data)+PARAM_REV_OFFSET),len);
+
+
+            if (LOM_MACTYPE_ETHERNET == EmbeddedNICMacAddress.LOMMacAddress[i].MacType)
+            {
+
+                if (    (0xff==NicNum) || (NicNum == EmbeddedNICMacAddress.LOMMacAddress[i].NICNumber)  )
+                {
+                    printf ("\n\r%d",EmbeddedNICMacAddress.LOMMacAddress[i].NICNumber);
+                    printf ("\t\t");
+                    for (j=0;j<5;j++)
+                        printf("%02x:",EmbeddedNICMacAddress.LOMMacAddress[i].MacAddressByte[j]);
+                    printf("%02x",EmbeddedNICMacAddress.LOMMacAddress[i].MacAddressByte[j]);
+
+                    if (LOM_ETHERNET_ENABLED == EmbeddedNICMacAddress.LOMMacAddress[i].EthernetStatus)
+                        printf ("\tEnabled");
+                    else
+                        printf ("\tDisabled");
+                }
+            }
+
+        }         
+        printf ("\n\r");
+
+    }
+
+    ipmi_macinfo_drac_idrac_mac(intf,NicNum);
+
+    return 0;
+
+}     
+
+
+
+/*****************************************************************
+* Function Name:      ipmi_macinfo
+*
+* Description:     This function retrieves the mac address of LOMs
+* Input:           intf   - ipmi interface
+* Output:               
+* Return:               
+*
+******************************************************************/
+
+static int ipmi_macinfo (struct ipmi_intf* intf, uint8_t NicNum)
+{
+    if (IMC_IDRAC_10G == IMC_Type)
+    {
+        return ipmi_macinfo_10g (intf,NicNum);
+    }
+    else if (IMC_IDRAC_11G_MODULAR == IMC_Type || IMC_IDRAC_11G_MONOLITHIC== IMC_Type ) 
+    {
+        return ipmi_macinfo_11g (intf,NicNum);
+    }
+    else
+    {
+        lprintf(LOG_ERR, " Error in getting MAC Address : Not supported platform");
+        return 0;
+    }       
+}
+
+
+/*****************************************************************
+* Function Name:     ipmi_mac_usage
+*
+* Description:   This function prints help message for mac command
+* Input:               
+* Output:       
+*
+* Return:              
+*
+******************************************************************/
+
+static void
+ipmi_mac_usage(void)
+{
+    lprintf(LOG_NOTICE, "");
+    lprintf(LOG_NOTICE, "   mac list");
+    lprintf(LOG_NOTICE, "      Lists the MAC address of LOMs");
+    lprintf(LOG_NOTICE, "");
+    lprintf(LOG_NOTICE, "   mac get <NIC number>");
+    lprintf(LOG_NOTICE, "      Shows the MAC address of specified LOM. 0-7 System LOM, 8- DRAC/iDRAC.");
+    lprintf(LOG_NOTICE, "");
+}
+
+/*****************************************************************
+* Function Name:       ipmi_delloem_lan_main
+*
+* Description:         This function processes the delloem lan command
+* Input:               intf    - ipmi interface
+                       argc    - no of arguments
+                       argv    - argument string array
+* Output:        
+*
+* Return:              return code     0 - success
+*                         -1 - failure
+*
+******************************************************************/
+
+static int ipmi_delloem_lan_main (struct ipmi_intf * intf, int argc, char ** argv)
+{
+    int rc = 0;
+
+    int nic_selection = 0;
+    current_arg++;
+    if (argv[current_arg] == NULL)
+    {
+        ipmi_lan_usage();
+        return -1;
+    }               
+    else if (strncmp(argv[current_arg], "set\0", 4) == 0)
+    {
+        current_arg++;
+        if (argv[current_arg] == NULL)
+        {
+            ipmi_lan_usage();
+            return -1;
+        }
+        nic_selection = get_nic_selection_mode(current_arg,argv);
+
+
+        if (INVALID == nic_selection)
+        {
+            ipmi_lan_usage();
+            return -1;
+        }                               
+        rc = ipmi_lan_set_nic_selection(intf,nic_selection);
+        return 0;                       
+    }
+    else if (strncmp(argv[current_arg], "get\0", 4) == 0)
+    {
+        current_arg++;
+        if (argv[current_arg] == NULL)
+        {
+            rc = ipmi_lan_get_nic_selection(intf);
+            return rc;
+        }
+        else if (strncmp(argv[current_arg], "active\0", 7) == 0)                
+        {
+            rc = ipmi_lan_get_active_nic(intf);
+            return rc;
+        }
+        else
+        {
+            ipmi_lan_usage();
+        }
+
+    }
+    else
+    {
+        ipmi_lan_usage();
+    }
+}
+
+
+static int IsLANSupported ()
+{
+    if (IMC_IDRAC_11G_MODULAR == IMC_Type)
+        return 0;
+    return 1;
+}
+
+char NIC_Selection_Mode_String [4] [50] =     {       "shared",  
+"shared with failover lom2",
+"dedicated",
+"shared with Failover all loms"
+};
+
+
+char AciveLOM_String [5] [10] =       {"dedicated","LOM1","LOM2","LOM3","LOM4" };
+
+
+
+
+static int get_nic_selection_mode (int current_arg, char ** argv)
+{
+    int nic_selection_mode = 0;
+    if (NULL!= argv[current_arg] && 0 == strncmp(argv[current_arg], "dedicated\0", 10)) 
+    {
+        return DEDICATED;
+    }
+    if (NULL!= argv[current_arg] && 0 == strncmp(argv[current_arg], "shared\0", 7)) 
+    {
+        if (NULL == argv[current_arg+1] )
+            return SHARED;          
+    }
+    current_arg++;  
+    if (NULL!= argv[current_arg] && 0 == strncmp(argv[current_arg], "with\0", 5)) 
+    {
+    }       
+    else
+        return INVALID;         
+
+    current_arg++;  
+    if (NULL!= argv[current_arg] && 0 == strncmp(argv[current_arg], "failover\0", 9)) 
+    {
+    }       
+    else
+        return INVALID;         
+
+    current_arg++;  
+    if (NULL!= argv[current_arg] && 0 == strncmp(argv[current_arg], "lom2\0", 5)) 
+    {
+        return SHARED_WITH_FAILOVER_LOM2;
+    }       
+    else if (NULL!= argv[current_arg] && 0 == strncmp(argv[current_arg], "all\0", 4)) 
+    {
+    }       
+    else
+        return INVALID; 
+
+    current_arg++;  
+    if (NULL!= argv[current_arg] && 0 == strncmp(argv[current_arg], "loms\0", 5)) 
+    {
+        return SHARED_WITH_FAILOVER_ALL_LOMS;
+    }       
+
+    return INVALID;
+
+}
+
+
+static int ipmi_lan_set_nic_selection (struct ipmi_intf* intf, uint8_t nic_selection)
+{
+    struct ipmi_rs * rsp;
+    struct ipmi_rq req;
+
+    uint8_t msg_data[30];
+    uint8_t input_length=0;
+    uint8_t j;
+
+    input_length = 0;
+
+    msg_data[input_length++] = nic_selection; 
+
+    req.msg.netfn = DELL_OEM_NETFN;
+    req.msg.lun = 0;                
+    req.msg.cmd = SET_NIC_SELECTION_CMD;
+    req.msg.data = msg_data;
+    req.msg.data_len = input_length;
+
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL)
+    {
+        lprintf(LOG_ERR, " Error in setting nic selection");
+        return -1;
+    }
+    else if (rsp->ccode > 0) 
+    {
+        lprintf(LOG_ERR, " Error in setting nic selection (%s) \n",
+            val2str(rsp->ccode, completion_code_vals) );
+        return -1;
+    }
+    printf("configured successfully");
+
+    return 0;
+}      
+
+static int ipmi_lan_get_nic_selection (struct ipmi_intf* intf)
+{
+    uint8_t nic_selection=-1;
+
+    struct ipmi_rs * rsp;
+    struct ipmi_rq req;
+
+    uint8_t msg_data[30];
+    uint8_t input_length=0;
+    uint8_t j;
+
+    input_length = 0;
+
+    req.msg.netfn = DELL_OEM_NETFN;
+    req.msg.lun = 0;                
+    req.msg.cmd = GET_NIC_SELECTION_CMD;
+    req.msg.data = msg_data;
+    req.msg.data_len = input_length;
+
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL)
+    {
+        lprintf(LOG_ERR, " Error in getting nic selection");
+        return -1;
+    }
+    else if (rsp->ccode > 0) 
+    {
+        lprintf(LOG_ERR, " Error in getting nic selection (%s) \n",
+            val2str(rsp->ccode, completion_code_vals) );
+        return -1;
+    }
+    nic_selection = rsp->data[0];
+
+    printf ("\n%s",NIC_Selection_Mode_String[nic_selection]);
+
+    return 0;
+}      
+
+static int ipmi_lan_get_active_nic (struct ipmi_intf* intf)
+{
+    uint8_t active_nic=0;
+
+    struct ipmi_rs * rsp;
+    struct ipmi_rq req;
+
+    uint8_t msg_data[30];
+    uint8_t input_length=0;
+    uint8_t j;
+
+    input_length = 0;
+
+    msg_data[input_length++] = 0; /*Get Status*/
+    msg_data[input_length++] = 0; /*Reserved*/
+    msg_data[input_length++] = 0; /*Reserved*/        
+
+    req.msg.netfn = DELL_OEM_NETFN;
+    req.msg.lun = 0;                
+    req.msg.cmd = GET_ACTIVE_NIC_CMD;
+    req.msg.data = msg_data;
+    req.msg.data_len = input_length;
+
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL)
+    {
+        lprintf(LOG_ERR, " Error in getting Active LOM Status");
+        return -1;
+    }
+    else if (rsp->ccode > 0) 
+    {
+        lprintf(LOG_ERR, " Error in getting Active LOM Status (%s) \n",
+            val2str(rsp->ccode, completion_code_vals) );
+        return -1;
+    }
+    active_nic = rsp->data[0];
+    if (active_nic < 5)
+        printf ("\n%s",AciveLOM_String[active_nic]);
+
+    return 0;
+}      
+
+
+static void
+ipmi_lan_usage(void)
+{
+    lprintf(LOG_NOTICE, "");
+    lprintf(LOG_NOTICE, "   lan set <Mode> ");
+    lprintf(LOG_NOTICE, "      sets the NIC Selection Mode (dedicated, shared, shared with failover lom2, shared with Failover all loms).");
+    lprintf(LOG_NOTICE, "");
+    lprintf(LOG_NOTICE, "   lan get ");
+    lprintf(LOG_NOTICE, "      returns the current NIC Selection Mode (dedicated, shared, shared with failover lom2, shared with Failover all loms).");
+    lprintf(LOG_NOTICE, "");
+    lprintf(LOG_NOTICE, "   lan get active");
+    lprintf(LOG_NOTICE, "      returns the current active NIC (dedicated, LOM1, LOM2, LOM3, LOM4).");       
+    lprintf(LOG_NOTICE, "");
+
+}
+
+/*****************************************************************
+* Function Name:       ipmi_delloem_powermonitor_main
+*
+* Description:         This function processes the delloem powermonitor command
+* Input:               intf    - ipmi interface
+                       argc    - no of arguments
+                       argv    - argument string array
+* Output:        
+*
+* Return:              return code     0 - success
+*                         -1 - failure
+*
+******************************************************************/
+
+static int ipmi_delloem_powermonitor_main (struct ipmi_intf * intf, int argc, char ** argv)
+{
+    int rc = 0;
+
+    current_arg++;
+    if (argc == 1)
+    {
+        rc = ipmi_powermgmt(intf);
+    }
+    else if (strncmp(argv[current_arg], "status\0", 7) == 0) 
+    {
+        rc = ipmi_powermgmt(intf);
+    }
+
+    else if (strncmp(argv[current_arg], "clear\0", 6) == 0) 
+    {
+        current_arg++;
+        if (argv[current_arg] == NULL) 
+        {
+            ipmi_powermonitor_usage();
+            return -1;
+        }
+        else if (strncmp(argv[current_arg], "peakpower\0", 10) == 0) 
+        {
+            rc = ipmi_powermgmt_clear(intf, 1);
+        }
+        else if (strncmp(argv[current_arg], "cumulativepower\0", 16) == 0) 
+        {
+            rc = ipmi_powermgmt_clear(intf, 0);
+        }
+        else 
+        {
+            ipmi_powermonitor_usage();
+            return -1;
+        }
+
+    }
+
+
+    else if (strncmp(argv[current_arg], "powerconsumption\0", 17) == 0) 
+    {
+        current_arg++;
+
+        if (argv[current_arg] == NULL)
+        {
+
+            rc=ipmi_print_get_power_consmpt_data(intf,watt);
+
+        }
+        else if (strncmp(argv[current_arg], "watt\0", 5) == 0) 
+        {
+
+            rc = ipmi_print_get_power_consmpt_data(intf, watt);
+        }
+        else if (strncmp(argv[current_arg], "btuphr\0", 7) == 0) 
+        {
+            rc = ipmi_print_get_power_consmpt_data(intf, btuphr);
+        }
+        else
+        {
+            ipmi_powermonitor_usage();
+            return -1;
+        }
+    }
+    else if (strncmp(argv[current_arg], "powerconsumptionhistory\0", 23) == 0) 
+    {
+        current_arg++;
+        if (argv[current_arg] == NULL)
+        {
+            rc=ipmi_print_power_consmpt_history(intf,watt);
+
+        }
+        else if (strncmp(argv[current_arg], "watt\0", 5) == 0) 
+        {
+            rc = ipmi_print_power_consmpt_history(intf, watt);
+        }
+        else if (strncmp(argv[current_arg], "btuphr\0", 7) == 0)
+        {
+            rc = ipmi_print_power_consmpt_history(intf, btuphr);
+        }
+        else
+        {
+            ipmi_powermonitor_usage();
+            return -1;
+        }
+
+    }
+
+    else if (strncmp(argv[current_arg], "getpowerbudget\0", 15) == 0)
+    {
+        current_arg++;
+        if (argv[current_arg] == NULL)
+        {
+            rc=ipmi_print_power_cap(intf,watt);
+
+        }
+        else if (strncmp(argv[current_arg], "watt\0", 5) == 0)
+        {
+            rc = ipmi_print_power_cap(intf, watt);
+        }
+        else if (strncmp(argv[current_arg], "btuphr\0", 7) == 0)
+        {
+            rc = ipmi_print_power_cap(intf, btuphr);
+        }
+        else
+        {
+            ipmi_powermonitor_usage();
+            return -1;
+        }
+
+    }
+
+    else if (strncmp(argv[current_arg], "setpowerbudget\0", 15) == 0)
+    {
+        current_arg++;
+        int val;
+        if (argv[current_arg] == NULL)
+        { 
+            ipmi_powermonitor_usage();
+            return -1;
+        }
+        make_int(argv[current_arg],&val);
+        current_arg++;
+        if (argv[current_arg] == NULL)
+        {       
+            ipmi_powermonitor_usage();
+        }
+        else if (strncmp(argv[current_arg], "watt\0", 5) == 0)
+        {
+            rc=ipmi_set_power_cap(intf,watt,val);
+        }
+        else if (strncmp(argv[current_arg], "btuphr\0", 7) == 0)
+        {
+            rc=ipmi_set_power_cap(intf, btuphr,val);
+        }
+        else if (strncmp(argv[current_arg], "percent\0", 8) == 0)
+        {
+            rc=ipmi_set_power_cap(intf,percent,val);
+        }
+        else
+        {
+            ipmi_powermonitor_usage();
+            return -1;
+        }
+
+    }
+
+    else if (strncmp(argv[current_arg], "enablepowercap\0", 15) == 0)
+    {
+        ipmi_set_power_capstatus_command(intf,1);
+    }
+
+    else if (strncmp(argv[current_arg], "disablepowercap\0", 16) == 0)
+    {
+        ipmi_set_power_capstatus_command(intf,0);
+    }
+    else
+    {
+        ipmi_powermonitor_usage();
+        return -1;
+    }
+}
+
+
+/*****************************************************************
+* Function Name:     ipmi_time_to_str
+*
+* Description:       This function converts ipmi time format into gmtime format
+* Input:             rawTime  - ipmi time format 
+* Output:            strTime  - gmtime format
+*
+* Return:              
+*
+******************************************************************/
+
+static void
+ipmi_time_to_str(time_t rawTime, char* strTime)
+{
+    struct tm * tm;
+    char *temp;
+    tm = gmtime(&rawTime);
+
+    temp = asctime(tm);
+
+    strcpy(strTime,temp);
+}
+
+/*****************************************************************
+* Function Name:      ipmi_get_sensor_reading
+*
+* Description:        This function retrieves a raw sensor reading
+* Input:              sensorOwner       - sensor owner id
+*                     sensorNumber      - sensor id
+*                     intf              - ipmi interface
+* Output:             sensorReadingData - ipmi response structure
+* Return:             1 on error
+*                     0 if successful
+*
+******************************************************************/
+static int
+ipmi_get_sensor_reading(struct ipmi_intf *intf ,
+                unsigned char sensorNumber,
+                        SensorReadingType* pSensorReadingData)
+{
+    struct ipmi_rq req;
+    struct ipmi_rs * rsp;
+    int rc = 0;
+    uint8_t save_addr;
+
+    memset(&req, 0, sizeof (req));
+    req.msg.netfn = IPMI_NETFN_SE;
+    req.msg.lun = 0;
+    req.msg.cmd = GET_SENSOR_READING;
+    req.msg.data = &sensorNumber;
+    req.msg.data_len = 1;
+
+    if (NULL == pSensorReadingData)
+        return -1;
+    memset(pSensorReadingData,0, sizeof(SensorReadingType));        
+
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL) {
+        return 1;
+    } else if (rsp->ccode > 0) {
+        return 1;
+    }
+
+    memcpy(pSensorReadingData, rsp->data, sizeof(SensorReadingType));
+
+    /* if there is an error transmitting ipmi command, return error*/
+    if (rsp->ccode != 0) {
+        rc = 1;
+    }
+
+    /* if sensor messages are disabled, return error*/
+    if ((!(rsp->data[1]& 0xC0)) || ((rsp->data[1] & 0x20))) {
+        rc =1;
+    }
+    return rc;
+}
+
+
+/*****************************************************************
+* Function Name:   ipmi_get_power_capstatus_command
+*
+* Description:     This function gets the power cap status
+* Input:           intf                 - ipmi interface
+* Global:          PowercapSetable_flag - power cap status
+* Output:                
+*
+* Return:              
+*
+******************************************************************/
+static int
+ipmi_get_power_capstatus_command (struct ipmi_intf * intf)
+{
+    struct ipmi_rs * rsp = NULL;
+    struct ipmi_rq req = {0};
+    uint8_t data[2];
+
+    req.msg.netfn = DELL_OEM_NETFN;
+    req.msg.lun = 0;
+    req.msg.cmd = IPMI_DELL_POWER_CAP_STATUS;
+    req.msg.data_len = 2;
+    req.msg.data = data;
+    data[0] = 01;
+    data[1] = 0xFF;
+
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL) {
+        lprintf(LOG_ERR, " Error getting powercap status");
+        return -1;
+    } else if (rsp->ccode > 0) {
+        lprintf(LOG_ERR, " Error getting powercap statusr: %s",
+            val2str(rsp->ccode, completion_code_vals));
+        return -1;
+    }
+    if (rsp->data[0]&0x02)
+        PowercapSetable_flag=1;
+    if(rsp->data[0]&0x01)
+        PowercapstatusFlag=1;
+    return 0;
+}
+
+/*****************************************************************
+* Function Name:    ipmi_set_power_capstatus_command
+*
+* Description:      This function sets the power cap status
+* Input:            intf     - ipmi interface
+*                   val      - power cap status
+* Output:            
+*
+* Return:              
+*
+******************************************************************/
+
+static int
+ipmi_set_power_capstatus_command (struct ipmi_intf * intf,uint8_t val)
+{
+    struct ipmi_rs * rsp = NULL;
+    struct ipmi_rq req = {0};
+    uint8_t data[2];
+    ipmi_get_power_capstatus_command(intf);
+
+    if (PowercapSetable_flag!=1)
+    {
+        lprintf(LOG_ERR, " Can not set powercap on this system");
+        return -1;
+    }
+    req.msg.netfn = DELL_OEM_NETFN;
+    req.msg.lun = 0;
+    req.msg.cmd = IPMI_DELL_POWER_CAP_STATUS;
+    req.msg.data_len = 2;
+    req.msg.data = data;
+
+    data[0] = 00;
+    data[1] = val;
+
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL) {
+        lprintf(LOG_ERR, " Error setting powercap status");
+        return -1;
+    } else if (rsp->ccode > 0) {
+        lprintf(LOG_ERR, " Error setting powercap statusr: %s",
+            val2str(rsp->ccode, completion_code_vals));
+        return -1;
+    }
+
+    return 0;
+}
+
+
+
+/*****************************************************************
+* Function Name:    ipmi_powermgmt
+*
+* Description:      This function print the powermonitor details
+* Input:            intf     - ipmi interface
+* Output:              
+*
+* Return:              
+*
+******************************************************************/
+static int ipmi_powermgmt(struct ipmi_intf* intf)
+{
+    time_t now;
+    struct tm* tm;
+    char* dte;
+
+    struct ipmi_rs * rsp;
+    struct ipmi_rq req;
+    uint8_t msg_data[2];
+    uint32_t cumStartTimeConv;
+    uint32_t cumReadingConv;
+    uint32_t maxPeakStartTimeConv;
+    uint32_t ampPeakTimeConv;
+    uint16_t ampReadingConv;
+    uint32_t wattPeakTimeConv;
+    uint32_t wattReadingConv;
+    uint32_t bmctimeconv;
+    uint32_t * bmctimeconvval;
+
+    IPMI_POWER_MONITOR* pwrMonitorInfo;
+
+
+    char cumStartTime[26];
+    char maxPeakStartTime[26];
+    char ampPeakTime[26];
+    char wattPeakTime[26];
+    char bmctime[26];
+
+    float cumReading;
+    int ampReading;
+    int wattReading;
+    int ampReadingRemainder;
+
+    now = time(0);
+    tm = gmtime(&now);
+    dte = asctime(tm);
+
+    memset(&req, 0, sizeof(req));
+    req.msg.netfn = IPMI_NETFN_STORAGE;
+    req.msg.lun = 0;
+    req.msg.cmd = IPMI_CMD_GET_SEL_TIME;
+
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL) {
+        lprintf(LOG_ERR, " Error getting BMC time info.\n");
+        return -1;
+    } 
+    if (rsp->ccode != 0) {
+        printf("Error getting power management information, return code %x\n", rsp->ccode);
+        return -1;
+    }
+    bmctimeconvval=(uint32_t*)rsp->data;
+    bmctimeconv=*bmctimeconvval;
+
+    /* get powermanagement info*/
+    req.msg.netfn = DELL_OEM_NETFN;
+    req.msg.lun = 0x0;
+    req.msg.cmd = GET_PWRMGMT_INFO_CMD;
+    req.msg.data = msg_data;
+    req.msg.data_len = 2;
+
+    memset(msg_data, 0, 2);
+    msg_data[0] = 0x07;     
+    msg_data[1] = 0x01;
+
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL) {
+        lprintf(LOG_ERR, " Error getting power management information.\n");
+        return -1;
+    } 
+    if ((rsp->ccode == 0xc1)||(rsp->ccode == 0xcb)) {
+        lprintf(LOG_ERR, " Error getting power management information: Command not supported on this system.");
+        return -1;
+    }else if (rsp->ccode != 0) {
+        printf("Error getting power management information, return code %x\n", rsp->ccode);
+        return -1;
+    }
+
+
+
+    pwrMonitorInfo = (IPMI_POWER_MONITOR*)rsp->data;
+
+    cumStartTimeConv = pwrMonitorInfo->cumStartTime;
+    cumReadingConv = pwrMonitorInfo->cumReading;
+    maxPeakStartTimeConv = pwrMonitorInfo->maxPeakStartTime;
+    ampPeakTimeConv = pwrMonitorInfo->ampPeakTime;
+    ampReadingConv = pwrMonitorInfo->ampReading;
+    wattPeakTimeConv = pwrMonitorInfo->wattPeakTime;
+    wattReadingConv = pwrMonitorInfo->wattReading;
+
+    ipmi_time_to_str(cumStartTimeConv, cumStartTime);
+
+    ipmi_time_to_str(maxPeakStartTimeConv, maxPeakStartTime);
+    ipmi_time_to_str(ampPeakTimeConv, ampPeakTime);
+    ipmi_time_to_str(wattPeakTimeConv, wattPeakTime);
+    ipmi_time_to_str(bmctimeconv, bmctime);
+
+
+
+    now = time(0);
+
+    int round;
+    int round2;
+    int remainder;
+
+
+    remainder = (cumReadingConv % 1000);
+    cumReadingConv = cumReadingConv / 1000;
+    remainder = (remainder + 50) / 100;
+
+    ampReading = ampReadingConv;
+    ampReadingRemainder = ampReading%10;
+    ampReading = ampReading/10;
+
+    wattReading = wattReadingConv;
+
+    printf("Power Tracking Statistics\n");
+    printf("Statistic      : Cumulative Energy Consumption\n");
+    printf("Start Time     : %s", cumStartTime);
+    printf("Finish Time    : %s", bmctime);
+    printf("Reading        : %d.%d kWh\n\n", cumReadingConv, remainder);
+
+    printf("Statistic      : System Peak Power\n");
+    printf("Start Time     : %s", maxPeakStartTime);
+    printf("Peak Time      : %s", wattPeakTime);
+    printf("Peak Reading   : %d W\n\n", wattReading);
+
+    printf("Statistic      : System Peak Amperage\n");
+    printf("Start Time     : %s", maxPeakStartTime);
+    printf("Peak Time      : %s", ampPeakTime);
+    printf("Peak Reading   : %d.%d A\n", ampReading, ampReadingRemainder);
+
+
+    return 0;
+
+}
+/*****************************************************************
+* Function Name:    ipmi_powermgmt_clear
+*
+* Description:     This function clears peakpower / cumulativepower value
+* Input:           intf           - ipmi interface
+*                  clearValue     - peakpower / cumulativepower
+* Output:          
+*
+* Return:              
+*
+******************************************************************/
+static int
+ipmi_powermgmt_clear(struct ipmi_intf* intf,uint8_t clearValue)
+{
+    struct ipmi_rs * rsp;
+    struct ipmi_rq req;
+    uint8_t clearType;
+    uint8_t msg_data[3];
+
+    if (clearValue) {
+        clearType = 2;
+    } else {
+        clearType = 1;
+    }
+
+    /* clear powermanagement info*/
+    req.msg.netfn = DELL_OEM_NETFN;
+    req.msg.lun = 0;
+    req.msg.cmd = CLEAR_PWRMGMT_INFO_CMD;
+    req.msg.data = msg_data;
+    req.msg.data_len = 3;
+
+
+    memset(msg_data, 0, 3);
+    msg_data[0] = 0x07;
+    msg_data[1] = 0x01;
+    msg_data[2] = clearType;
+
+
+
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL) {
+        lprintf(LOG_ERR, " Error clearing power values.\n");
+        return -1;
+    } else if (rsp->ccode == 0xc1) {
+        lprintf(LOG_ERR, " Error clearing power values, command not supported on this system.\n");
+        return -1;
+    } else if (rsp->ccode != 0){
+        lprintf(LOG_ERR, " Error clearing power values: %s",
+            val2str(rsp->ccode, completion_code_vals));
+        return -1;
+    }
+
+}
+
+/*****************************************************************
+* Function Name:    watt_to_btuphr_conversion
+*
+* Description:      This function converts the power value in watt to btuphr
+* Input:            powerinwatt     - power in watt
+*                               
+* Output:           power in btuphr
+*
+* Return:              
+*
+******************************************************************/
+static uint64_t watt_to_btuphr_conversion(uint32_t powerinwatt)
+{
+    uint64_t powerinbtuphr;
+    powerinbtuphr=(3.413*powerinwatt);
+
+    return(powerinbtuphr);
+
+
+}
+
+/*****************************************************************
+* Function Name:    btuphr_to_watt_conversion
+*
+* Description:      This function converts the power value in  btuphr to watt
+* Input:            powerinbtuphr   - power in btuphr
+*                              
+* Output:           power in watt
+*
+* Return:                
+*
+******************************************************************/
+static uint32_t btuphr_to_watt_conversion(uint64_t powerinbtuphr)
+{
+    uint32_t powerinwatt;
+    /*returning the floor value*/
+    powerinwatt= (powerinbtuphr/3.413);
+    return (powerinwatt);
+}
+
+/*****************************************************************
+* Function Name:        ipmi_get_power_headroom_command
+*
+* Description:          This function prints the Power consumption information
+* Input:                intf    - ipmi interface
+*                       unit    - watt / btuphr
+* Output:           
+*
+* Return:              
+*
+******************************************************************/
+static int ipmi_get_power_headroom_command (struct ipmi_intf * intf,uint8_t unit)
+{
+    struct ipmi_rs * rsp = NULL;
+    struct ipmi_rq req = {0};
+    uint64_t peakpowerheadroombtuphr;
+    uint64_t instantpowerhearoom;
+
+    req.msg.netfn = DELL_OEM_NETFN;
+    req.msg.lun = 0;
+    req.msg.cmd = GET_PWR_HEADROOM_CMD;
+    req.msg.data_len = 0;
+
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL) {
+        lprintf(LOG_ERR, " Error getting power headroom status");
+        return -1;
+    } else if ((rsp->ccode == 0xc1)||(rsp->ccode == 0xcb)){
+        lprintf(LOG_ERR, " Error getting power headroom status: Command not supported on this system ");
+        return -1;
+    } else if (rsp->ccode > 0) {
+        lprintf(LOG_ERR, " Error getting power headroom status: %s",
+            val2str(rsp->ccode, completion_code_vals));
+        return -1;
+    }
+    if(verbose>1)
+        printf("power headroom  Data               : %x %x %x %x ",
+        /*need to look into */                                                                  rsp->data[0], rsp->data[1], rsp->data[2], rsp->data[3]);
+    powerheadroom= *(( POWER_HEADROOM *)rsp->data);
+
+    printf ("Headroom\n\r");
+    printf ("Statistic                     Reading\n\r");   
+
+    if(unit == btuphr)
+    {
+        peakpowerheadroombtuphr=watt_to_btuphr_conversion(powerheadroom.peakheadroom);
+        instantpowerhearoom= watt_to_btuphr_conversion(powerheadroom.instheadroom);
+
+        printf ("System Instantaneous Headroom : %d BTU/hr\n",instantpowerhearoom);
+        printf ("System Peak Headroom          : %d BTU/hr\n",peakpowerheadroombtuphr);
+    }
+    else
+    {
+        printf ("System Instantaneous Headroom : %d W\n",powerheadroom.instheadroom);
+        printf ("System Peak Headroom          : %d W\n",powerheadroom.peakheadroom);
+    }
+
+    return 0;
+}
+
+
+
+/*****************************************************************
+* Function Name:       ipmi_get_power_consumption_data
+*
+* Description:         This function updates the instant Power consumption information
+* Input:               intf - ipmi interface
+* Output:              power consumption current reading 
+*                      Assumption value will be in Watt.
+*
+* Return:               
+*
+******************************************************************/
+static int ipmi_get_power_consumption_data(struct ipmi_intf* intf,uint8_t unit)
+{
+    int rc = 0;
+    SensorReadingType sensorReadingData;
+
+    int i;
+
+    struct ipmi_rs * rsp=NULL;
+    struct sdr_record_list *sdr;
+    int readingbtuphr=0;
+    int warning_threshbtuphr=0;
+    int failuer_thresbtuphr=0;
+    int status=0;
+    int sensor_number = 0;
+
+
+    sdr = ipmi_sdr_find_sdr_byid(intf, "System Level");
+    if (NULL ==sdr)
+    {
+        printf ("Error : Can not access the System Level sensor data \n\n");
+        return -1;      
+    }       
+
+    sensor_number = sdr->record.full->keys.sensor_num;
+    ipmi_get_sensor_reading (intf,sensor_number,&sensorReadingData);                
+
+    rsp = ipmi_sdr_get_sensor_thresholds(intf,
+        sdr->record.full->keys.sensor_num,
+        sdr->record.full->keys.owner_id,
+        sdr->record.full->keys.lun);
+
+    if (rsp != NULL && rsp->ccode == 0)
+    {   
+        readingbtuphr=sdr_convert_sensor_reading
+            (sdr->record.full, sensorReadingData.sensorReading);
+        warning_threshbtuphr=sdr_convert_sensor_reading
+            (sdr->record.full, rsp->data[4]);
+        failuer_thresbtuphr=sdr_convert_sensor_reading
+            (sdr->record.full, rsp->data[5]);                                                
+
+        printf ("System Board System Level\n\r");
+        if (unit==btuphr)
+        {
+            readingbtuphr= watt_to_btuphr_conversion(readingbtuphr);
+            warning_threshbtuphr= watt_to_btuphr_conversion(warning_threshbtuphr);
+            failuer_thresbtuphr= watt_to_btuphr_conversion( failuer_thresbtuphr);
+
+            printf ("Reading                        : %d BTU/hr\n",readingbtuphr);
+            printf ("Warning threshold      : %d BTU/hr\n",warning_threshbtuphr);
+            printf ("Failure threshold      : %d BTU/hr\n",failuer_thresbtuphr);
+        }
+        else
+        {
+            printf ("Reading                        : %d W \n",readingbtuphr);              
+            printf ("Warning threshold      : %d W \n",(warning_threshbtuphr));
+            printf ("Failure threshold      : %d W \n",(failuer_thresbtuphr));
+        }
+    }
+    else
+    {
+        printf ("Error : Can not access the System Level sensor data \n\n");
+        return -1;              
+    }       
+    return status;
+}
+
+
+
+
+/*****************************************************************
+* Function Name:      ipmi_get_instan_power_consmpt_data
+*
+* Description:        This function updates the instant Power consumption information
+* Input:              intf - ipmi interface
+* Output:             instpowerconsumptiondata - instant Power consumption information
+*
+* Return:              
+*
+******************************************************************/
+
+static int ipmi_get_instan_power_consmpt_data(struct ipmi_intf* intf,
+                                              IPMI_INST_POWER_CONSUMPTION_DATA* instpowerconsumptiondata)
+{
+
+    struct ipmi_rs * rsp;
+    struct ipmi_rq req={0};
+
+    uint8_t msg_data[2];
+
+
+    /*get instantaneous power consumption command*/
+    req.msg.netfn = DELL_OEM_NETFN;
+    req.msg.lun = 0;
+    req.msg.cmd = GET_PWR_CONSUMPTION_CMD;
+
+    req.msg.data = msg_data;
+    req.msg.data_len = 2;
+
+
+
+    memset(msg_data, 0, 2);
+
+    msg_data[0] = 0x0A;     
+    msg_data[1] = 0x00;
+
+
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL) {
+        lprintf(LOG_ERR, " Error getting instantaneous power consumption data .\n");
+
+        return -1;
+    } else if ((rsp->ccode == 0xc1)||(rsp->ccode == 0xcb)) {
+        lprintf(LOG_ERR, "  Error getting instantaneous power consumption data: Command not supported on this system.");
+        return -1;
+    } else if (rsp->ccode != 0){
+        lprintf(LOG_ERR, "  Error getting instantaneous power consumption data: %s",
+            val2str(rsp->ccode, completion_code_vals));
+
+        return -1;
+    }
+
+    * instpowerconsumptiondata = * ( (IPMI_INST_POWER_CONSUMPTION_DATA*) (rsp->data));
+
+    return 0;
+
+
+}
+
+
+/*****************************************************************
+* Function Name:      ipmi_print_get_instan_power_Amps_data
+*
+* Description:        This function prints the instant Power consumption information
+* Input:              instpowerconsumptiondata - instant Power consumption information
+* Output:               
+*
+* Return:              
+*
+******************************************************************/
+static void ipmi_print_get_instan_power_Amps_data(IPMI_INST_POWER_CONSUMPTION_DATA instpowerconsumptiondata)
+{
+    uint16_t intampsval=0;
+    uint16_t decimalampsval=0;
+
+
+    if (instpowerconsumptiondata.instanApms>0)
+    {
+        decimalampsval=(instpowerconsumptiondata.instanApms%10);
+        intampsval=instpowerconsumptiondata.instanApms/10;
+    }
+    printf("\nAmperage value: %d.%d A \n",intampsval,decimalampsval);
+}
+/*****************************************************************
+* Function Name:     ipmi_print_get_power_consmpt_data
+*
+* Description:       This function prints the Power consumption information
+* Input:             intf            - ipmi interface
+*                    unit            - watt / btuphr 
+* Output:               
+*
+* Return:              
+*
+******************************************************************/
+static int ipmi_print_get_power_consmpt_data(struct ipmi_intf* intf,uint8_t  unit)
+{
+
+    int rc = 0;
+    int i;
+    uint16_t inputwattageL=0;
+    int sensorIndex = 0;
+
+    uint32_t readingbtuphr;
+    uint32_t warning_threshbtuphr;
+    uint32_t failuer_thresbtuphr;
+    IPMI_INST_POWER_CONSUMPTION_DATA instpowerconsumptiondata = {0,0,0,0};
+
+    printf ("\nPower consumption information\n");
+
+
+    rc=ipmi_get_power_consumption_data(intf,unit);
+    if (-1 == rc)
+        return rc;
+
+    rc=ipmi_get_instan_power_consmpt_data(intf,&instpowerconsumptiondata);
+    if (-1 == rc)
+        return rc;
+
+    ipmi_print_get_instan_power_Amps_data(instpowerconsumptiondata);
+
+
+    rc=ipmi_get_power_headroom_command(intf,unit);      
+
+    if (-1 == rc)
+        return rc;
+
+    return rc;
+
+
+}
+
+
+/*****************************************************************
+* Function Name:   ipmi_get_avgpower_consmpt_history
+*
+* Description:     This function updates the average power consumption information
+* Input:           intf            - ipmi interface
+* Output:          pavgpower- average power consumption information
+*
+* Return:              
+*
+******************************************************************/
+static int ipmi_get_avgpower_consmpt_history(struct ipmi_intf* intf,IPMI_AVGPOWER_CONSUMP_HISTORY* pavgpower )
+{
+    struct ipmi_rs * rsp = NULL;
+    struct ipmi_rq req = {0};
+    uint8_t data[4];
+
+    req.msg.netfn = IPMI_NETFN_APP;
+    req.msg.lun = 0;
+    req.msg.cmd = IPMI_GET_SYS_INFO;
+    req.msg.data_len = 4;
+    req.msg.data = data;
+    data[0] = 0;
+    data[1] = 0xeb;
+    data[2] = 0;
+    data[3] = 0;
+
+    rsp = intf->sendrecv(intf, &req);
+
+    if (rsp == NULL)
+    {
+        lprintf(LOG_ERR, " Error getting average power consumption history data .\n");
+        return -1;
+    } 
+    else if ((rsp->ccode == 0xc1)||(rsp->ccode == 0xcb))
+    {
+        lprintf(LOG_ERR, "  Error getting average power consumption  history data: Command not supported on this system.");
+        return -1;
+    }
+    else if (rsp->ccode != 0)
+    {
+        lprintf(LOG_ERR, "  Error getting average power consumption historydata: %s",
+            val2str(rsp->ccode, completion_code_vals));
+
+        return -1;
+    }
+
+    if (verbose > 1)
+    {
+        printf("Average power consumption history  Data               :%x %x %x %x %x %x %x\n\n",
+            rsp->data[0], rsp->data[1], rsp->data[2], rsp->data[3], 
+            rsp->data[4], rsp->data[5], rsp->data[6], rsp->data[7]);
+
+    }
+
+    *pavgpower = *( (IPMI_AVGPOWER_CONSUMP_HISTORY*) rsp->data);
+
+    return 0;
+}
+
+/*****************************************************************
+* Function Name:    ipmi_get_peakpower_consmpt_history
+*
+* Description:      This function updates the peak power consumption information
+* Input:            intf            - ipmi interface
+* Output:           pavgpower- peak power consumption information
+*
+* Return:         
+*
+******************************************************************/
+static int ipmi_get_peakpower_consmpt_history(struct ipmi_intf* intf,IPMI_POWER_CONSUMP_HISTORY * pstPeakpower)
+{
+
+    struct ipmi_rs * rsp = NULL;
+    struct ipmi_rq req = {0};
+    uint8_t data[4];
+
+    req.msg.netfn = IPMI_NETFN_APP;
+    req.msg.lun = 0;
+    req.msg.cmd = IPMI_GET_SYS_INFO;
+    req.msg.data_len = 4;
+    req.msg.data = data;
+    data[0] = 0;
+    data[1] = 0xec;
+    data[2] = 0;
+    data[3] = 0;
+
+    rsp = intf->sendrecv(intf, &req);
+
+    if (rsp == NULL)
+    {
+        lprintf(LOG_ERR, " Error getting  peak power consumption history data .\n");
+        return -1;
+    }
+    else if ((rsp->ccode == 0xc1)||(rsp->ccode == 0xcb))
+    {
+        lprintf(LOG_ERR, "  Error getting peak power consumption history data: Command not supported on this system.");
+        return -1;
+    }
+    else if (rsp->ccode != 0)
+    {
+        lprintf(LOG_ERR, "  Error getting peak power consumption history data: %s",
+            val2str(rsp->ccode, completion_code_vals));
+        return -1;
+    }
+
+    if (verbose > 1)
+    {
+        printf("Peak power consmhistory  Data               : %x %x %x %x %x %x %x %x %x %x\n   %x %x %x %x %x %x %x %x %x %x %x %x %x\n\n",
+            rsp->data[0], rsp->data[1], rsp->data[2], rsp->data[3], 
+            rsp->data[4], rsp->data[5], rsp->data[6], rsp->data[7], 
+            rsp->data[8], rsp->data[9], rsp->data[10], rsp->data[11], 
+            rsp->data[12], rsp->data[13], rsp->data[14], rsp->data[15], 
+            rsp->data[16], rsp->data[17], rsp->data[18], rsp->data[19],  
+            rsp->data[20], rsp->data[21], rsp->data[22], rsp->data[23]
+        );
+
+    }
+    *pstPeakpower =* ((IPMI_POWER_CONSUMP_HISTORY*)rsp->data);
+    return 0;
+}
+
+
+/*****************************************************************
+* Function Name:    ipmi_get_minpower_consmpt_history
+*
+* Description:      This function updates the peak power consumption information
+* Input:            intf            - ipmi interface
+* Output:           pavgpower- peak power consumption information
+*
+* Return:         
+*
+******************************************************************/
+static int ipmi_get_minpower_consmpt_history(struct ipmi_intf* intf,IPMI_POWER_CONSUMP_HISTORY * pstMinpower)
+{
+
+    struct ipmi_rs * rsp = NULL;
+    struct ipmi_rq req = {0};
+    uint8_t data[4];
+
+    req.msg.netfn = IPMI_NETFN_APP;
+    req.msg.lun = 0;
+    req.msg.cmd = IPMI_GET_SYS_INFO;
+    req.msg.data_len = 4;
+    req.msg.data = data;
+    data[0] = 0;
+    data[1] = 0xed;
+    data[2] = 0;
+    data[3] = 0;
+
+    rsp = intf->sendrecv(intf, &req);
+
+    if (rsp == NULL)
+    {
+        lprintf(LOG_ERR, " Error getting  peak power consumption history data .\n");
+        return -1;
+    }
+    else if ((rsp->ccode == 0xc1)||(rsp->ccode == 0xcb))
+    {
+        lprintf(LOG_ERR, "  Error getting peak power consumption history data: Command not supported on this system.");
+        return -1;
+    }
+    else if (rsp->ccode != 0)
+    {
+        lprintf(LOG_ERR, "  Error getting peak power consumption history data: %s",
+            val2str(rsp->ccode, completion_code_vals));
+        return -1;
+    }
+
+    if (verbose > 1)
+    {
+        printf("Peak power consmhistory  Data               : %x %x %x %x %x %x %x %x %x %x\n   %x %x %x %x %x %x %x %x %x %x %x %x %x\n\n",
+            rsp->data[0], rsp->data[1], rsp->data[2], rsp->data[3], 
+            rsp->data[4], rsp->data[5], rsp->data[6], rsp->data[7], 
+            rsp->data[8], rsp->data[9], rsp->data[10], rsp->data[11], 
+            rsp->data[12], rsp->data[13], rsp->data[14], rsp->data[15], 
+            rsp->data[16], rsp->data[17], rsp->data[18], rsp->data[19],  
+            rsp->data[20], rsp->data[21], rsp->data[22], rsp->data[23]
+        );
+
+    }
+    *pstMinpower =* ((IPMI_POWER_CONSUMP_HISTORY*)rsp->data);
+    return 0;
+}
+
+
+
+/*****************************************************************
+* Function Name:    ipmi_print_power_consmpt_history
+*
+* Description:      This function print the average and peak power consumption information
+* Input:            intf      - ipmi interface
+*                   unit      - watt / btuphr
+* Output:                
+*
+* Return:              
+*
+******************************************************************/
+static int ipmi_print_power_consmpt_history(struct ipmi_intf* intf,int unit )
+{
+
+    char timestr[30];
+
+    uint32_t lastminutepeakpower;
+    uint32_t lasthourpeakpower;
+    uint32_t lastdaypeakpower;
+    uint32_t lastweekpeakpower;
+
+    IPMI_AVGPOWER_CONSUMP_HISTORY avgpower;
+    IPMI_POWER_CONSUMP_HISTORY stMinpower;
+    IPMI_POWER_CONSUMP_HISTORY stPeakpower;
+
+    uint64_t tempbtuphrconv;
+    uint16_t temp;
+    int rc=0;
+
+
+    rc= ipmi_get_avgpower_consmpt_history(intf,&avgpower);    
+    if (-1 == rc)
+        return rc;
+
+    rc= ipmi_get_peakpower_consmpt_history(intf,&stPeakpower);
+    if (-1 == rc)
+        return rc;
+
+    rc= ipmi_get_minpower_consmpt_history(intf,&stMinpower);
+    if (-1 == rc)
+        return rc;
+
+
+    if(rc==0) 
+    {
+        printf ("Power Consumption History\n\r\n\r");
+        /* The fields are alligned manually changing the spaces will alter the alignment*/
+        printf ("Statistic                   Last Minute     Last Hour     Last Day     Last Week\n\r\n\r");
+
+        if (unit ==btuphr)
+        {
+            printf ("Average Power Consumption  ");         
+            tempbtuphrconv=watt_to_btuphr_conversion(avgpower.lastminutepower);
+            printf ("%4d BTU/hr     ",tempbtuphrconv);
+            tempbtuphrconv=watt_to_btuphr_conversion(avgpower.lasthourpower);
+            printf ("%4d BTU/hr   ",tempbtuphrconv);
+            tempbtuphrconv=watt_to_btuphr_conversion(avgpower.lastdaypower);
+            printf ("%4d BTU/hr  ",tempbtuphrconv);
+            tempbtuphrconv=watt_to_btuphr_conversion(avgpower.lastweakpower);
+            printf ("%4d BTU/hr\n\r",tempbtuphrconv);
+
+            printf ("Max Power Consumption      ");         
+            tempbtuphrconv=watt_to_btuphr_conversion(stPeakpower.lastminutepower);
+            printf ("%4d BTU/hr     ",tempbtuphrconv);
+            tempbtuphrconv=watt_to_btuphr_conversion(stPeakpower.lasthourpower);
+            printf ("%4d BTU/hr   ",tempbtuphrconv);
+            tempbtuphrconv=watt_to_btuphr_conversion(stPeakpower.lastdaypower);
+            printf ("%4d BTU/hr  ",tempbtuphrconv);
+            tempbtuphrconv=watt_to_btuphr_conversion(stPeakpower.lastweakpower);
+            printf ("%4d BTU/hr\n\r",tempbtuphrconv);
+
+            printf ("Min Power Consumption      ");         
+            tempbtuphrconv=watt_to_btuphr_conversion(stMinpower.lastminutepower);
+            printf ("%4d BTU/hr     ",tempbtuphrconv);
+            tempbtuphrconv=watt_to_btuphr_conversion(stMinpower.lasthourpower);
+            printf ("%4d BTU/hr   ",tempbtuphrconv);
+            tempbtuphrconv=watt_to_btuphr_conversion(stMinpower.lastdaypower);
+            printf ("%4d BTU/hr  ",tempbtuphrconv);
+            tempbtuphrconv=watt_to_btuphr_conversion(stMinpower.lastweakpower);
+            printf ("%4d BTU/hr\n\r\n\r",tempbtuphrconv);
+
+        }
+        else
+        {
+
+            printf ("Average Power Consumption  ");         
+            tempbtuphrconv=(avgpower.lastminutepower);
+            printf ("%4d W          ",tempbtuphrconv);
+            tempbtuphrconv=(avgpower.lasthourpower);
+            printf ("%4d W        ",tempbtuphrconv);
+            tempbtuphrconv=(avgpower.lastdaypower);
+            printf ("%4d W       ",tempbtuphrconv);
+            tempbtuphrconv=(avgpower.lastweakpower);
+            printf ("%4d W   \n\r",tempbtuphrconv);
+
+            printf ("Max Power Consumption      ");         
+            tempbtuphrconv=(stPeakpower.lastminutepower);
+            printf ("%4d W          ",tempbtuphrconv);
+            tempbtuphrconv=(stPeakpower.lasthourpower);
+            printf ("%4d W        ",tempbtuphrconv);
+            tempbtuphrconv=(stPeakpower.lastdaypower);
+            printf ("%4d W       ",tempbtuphrconv);
+            tempbtuphrconv=(stPeakpower.lastweakpower);
+            printf ("%4d W   \n\r",tempbtuphrconv);
+
+            printf ("Min Power Consumption      ");         
+            tempbtuphrconv=(stMinpower.lastminutepower);
+            printf ("%4d W          ",tempbtuphrconv);
+            tempbtuphrconv=(stMinpower.lasthourpower);
+            printf ("%4d W        ",tempbtuphrconv);
+            tempbtuphrconv=(stMinpower.lastdaypower);
+            printf ("%4d W       ",tempbtuphrconv);
+            tempbtuphrconv=(stMinpower.lastweakpower);
+            printf ("%4d W   \n\r\n\r",tempbtuphrconv);
+        }               
+
+        lastminutepeakpower=stPeakpower.lastminutepowertime;
+        lasthourpeakpower=stPeakpower.lasthourpowertime;
+        lastdaypeakpower=stPeakpower.lastdaypowertime;
+        lastweekpeakpower=stPeakpower.lastweekpowertime;
+
+        printf ("Max Power Time\n\r");
+        ipmi_time_to_str(lastminutepeakpower, timestr);         
+        printf ("Last Minute     : %s",timestr);
+        ipmi_time_to_str(lasthourpeakpower, timestr);           
+        printf ("Last Hour       : %s",timestr);
+        ipmi_time_to_str(lastdaypeakpower, timestr);            
+        printf ("Last Day        : %s",timestr);
+        ipmi_time_to_str(lastweekpeakpower, timestr);           
+        printf ("Last Week       : %s",timestr);                
+
+
+        lastminutepeakpower=stMinpower.lastminutepowertime;
+        lasthourpeakpower=stMinpower.lasthourpowertime;
+        lastdaypeakpower=stMinpower.lastdaypowertime;
+        lastweekpeakpower=stMinpower.lastweekpowertime; 
+
+        printf ("Min Power Time\n\r");
+        ipmi_time_to_str(lastminutepeakpower, timestr);         
+        printf ("Last Minute     : %s",timestr);
+        ipmi_time_to_str(lasthourpeakpower, timestr);           
+        printf ("Last Hour       : %s",timestr);
+        ipmi_time_to_str(lastdaypeakpower, timestr);            
+        printf ("Last Day        : %s",timestr);
+        ipmi_time_to_str(lastweekpeakpower, timestr);           
+        printf ("Last Week       : %s",timestr);        
+
+    }
+
+}
+
+
+
+/*****************************************************************
+* Function Name:    ipmi_get_power_cap
+*
+* Description:      This function updates the power cap information
+* Input:            intf         - ipmi interface
+* Output:           ipmipowercap - power cap information
+*
+* Return:          
+*
+******************************************************************/
+
+static int ipmi_get_power_cap(struct ipmi_intf* intf,IPMI_POWER_CAP* ipmipowercap )
+{
+    struct ipmi_rs * rsp=NULL;
+    struct ipmi_rq req={0};
+    uint64_t tempbtuphrconv;
+    uint8_t data[4];
+
+    /* power supply rating command*/
+    req.msg.netfn = IPMI_NETFN_APP;
+    req.msg.lun = 0;
+    req.msg.cmd = IPMI_GET_SYS_INFO;
+    req.msg.data_len = 4;
+    req.msg.data = data;
+
+    data[0] = 0;
+    data[1] = IPMI_DELL_POWER_CAP;
+    data[2] = 0;
+    data[3] = 0;
+
+
+    rsp = intf->sendrecv(intf, &req);
+
+    if (rsp == NULL) {
+        lprintf(LOG_ERR, " Error getting power cap  .\n");
+        if (verbose > 1){
+            printf("power cap  Data               :%x %x %x %x %x %x %x %x %x %x ",
+                rsp->data[1], rsp->data[2], rsp->data[3], 
+                rsp->data[4], rsp->data[5], rsp->data[6], rsp->data[7], 
+                rsp->data[8], rsp->data[9], rsp->data[10],rsp->data[11]);
+        }
+        return -1;
+
+    } else if ((rsp->ccode == 0xc1)||(rsp->ccode == 0xcb)) {
+
+        lprintf(LOG_ERR, "  Error getting power cap: Command not supported on this system.");
+        if (verbose > 1){
+            printf("power cap  Data               :%x %x %x %x %x %x %x %x %x %x ",
+                rsp->data[1], rsp->data[2], rsp->data[3], 
+                rsp->data[4], rsp->data[5], rsp->data[6], rsp->data[7], 
+                rsp->data[8], rsp->data[9], rsp->data[10],rsp->data[11]);
+
+        }
+        return -1;
+    } else if (rsp->ccode != 0){
+        lprintf(LOG_ERR, "  Error getting power cap: %s",
+            val2str(rsp->ccode, completion_code_vals));
+        if (verbose > 1){
+            printf("power cap  Data               :%x %x %x %x %x %x %x %x %x %x ",
+                rsp->data[1], rsp->data[2], rsp->data[3], 
+                rsp->data[4], rsp->data[5], rsp->data[6], rsp->data[7], 
+                rsp->data[8], rsp->data[9], rsp->data[10],rsp->data[11]);
+        }
+        return -1;
+    }
+    if (verbose > 1){
+        printf("power cap  Data               :%x %x %x %x %x %x %x %x %x %x ",
+            rsp->data[1], rsp->data[2], rsp->data[3], 
+            rsp->data[4], rsp->data[5], rsp->data[6], rsp->data[7], 
+            rsp->data[8], rsp->data[9], rsp->data[10],rsp->data[11]);
+
+    }
+
+    * ipmipowercap = *((IPMI_POWER_CAP*)(rsp->data));
+
+    return 0;
+}
+
+/*****************************************************************
+* Function Name:    ipmi_print_power_cap
+*
+* Description:      This function print the power cap information
+* Input:            intf            - ipmi interface
+*                   unit            - watt / btuphr
+* Output:                
+* Return:               
+*
+******************************************************************/
+static int ipmi_print_power_cap(struct ipmi_intf* intf,uint8_t unit )
+{
+    uint64_t tempbtuphrconv;
+    int rc;
+    IPMI_POWER_CAP ipmipowercap;
+
+    rc=ipmi_get_power_cap(intf,&ipmipowercap);
+
+
+    if (rc==0) 
+    {
+        if (unit ==btuphr){
+            tempbtuphrconv=watt_to_btuphr_conversion(ipmipowercap.MaximumPowerConsmp);
+            printf ("Maximum power: %d  BTU/hr\n",tempbtuphrconv);
+            tempbtuphrconv=watt_to_btuphr_conversion(ipmipowercap.MinimumPowerConsmp);
+            printf ("Minimum power: %d  BTU/hr\n",tempbtuphrconv);
+            tempbtuphrconv=watt_to_btuphr_conversion(ipmipowercap.PowerCap);
+            printf ("Power cap    : %d  BTU/hr\n",tempbtuphrconv);
+        }else{
+
+            printf ("Maximum power: %d Watt\n",ipmipowercap.MaximumPowerConsmp);
+            printf ("Minimum power: %d Watt\n",ipmipowercap.MinimumPowerConsmp);
+            printf ("Power cap    : %d Watt\n",ipmipowercap.PowerCap);
+        }
+    }
+    return rc;
+
+}  
+
+/*****************************************************************
+* Function Name:     ipmi_set_power_cap
+*
+* Description:       This function updates the power cap information
+* Input:             intf            - ipmi interface
+*                    unit            - watt / btuphr
+*                    val             - new power cap value
+* Output:          
+* Return:               
+*
+******************************************************************/
+static int ipmi_set_power_cap(struct ipmi_intf* intf,int unit,int val )
+{
+    struct ipmi_rs *rsp = NULL;
+    struct ipmi_rq req={0};;
+    uint8_t data[13];
+    uint16_t powercapval;
+    uint64_t maxpowerbtuphr;
+    uint64_t maxpowerbtuphr1;
+    uint64_t minpowerbtuphr;
+    int rc;
+    IPMI_POWER_CAP ipmipowercap;
+
+    ipmi_get_power_capstatus_command(intf);
+    if (PowercapSetable_flag!=1)
+    {
+        lprintf(LOG_ERR, " Can not set powercap on this system");
+        return -1;
+    }
+    else if(PowercapstatusFlag!=1)
+    {
+        lprintf(LOG_ERR, " Power cap set feature is not enabled");
+        return -1;
+    }
+
+    req.msg.netfn = IPMI_NETFN_APP;
+    req.msg.lun = 0;
+    req.msg.cmd = IPMI_GET_SYS_INFO;
+    req.msg.data_len = 4;
+    memset(data, 0, 4);
+    req.msg.data = data;
+
+    data[0] = 0;
+    data[1] = IPMI_DELL_POWER_CAP;
+    data[2] = 0;
+    data[3] = 0;
+
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL) 
+    {
+        lprintf(LOG_ERR, " Error getting power cap  .\n");
+        if (verbose > 1)
+        {
+            printf("power cap  Data               :%x %x %x %x %x %x %x %x %x %x ",
+                rsp->data[1], rsp->data[2], rsp->data[3], 
+                rsp->data[4], rsp->data[5], rsp->data[6], rsp->data[7], 
+                rsp->data[8], rsp->data[9], rsp->data[10],rsp->data[11]);
+        }
+        return -1;
+
+    }
+    else if (rsp->ccode == 0xc1) 
+    {
+
+        lprintf(LOG_ERR, "  Error getting power cap, command not supported on this system.\n");
+        if (verbose > 1){
+            printf("power cap  Data               :%x %x %x %x %x %x %x %x %x %x ",
+                rsp->data[1], rsp->data[2], rsp->data[3], 
+                rsp->data[4], rsp->data[5], rsp->data[6], rsp->data[7], 
+                rsp->data[8], rsp->data[9], rsp->data[10],rsp->data[11]);
+
+        }
+        return -1;
+    }
+    else if (rsp->ccode != 0)
+    {
+        lprintf(LOG_ERR, "  Error getting power cap: %s",
+            val2str(rsp->ccode, completion_code_vals));
+        if (verbose > 1)
+        {
+            printf("power cap  Data               :%x %x %x %x %x %x %x %x %x %x ",
+                rsp->data[1], rsp->data[2], rsp->data[3], 
+                rsp->data[4], rsp->data[5], rsp->data[6], rsp->data[7], 
+                rsp->data[8], rsp->data[9], rsp->data[10],rsp->data[11]);
+        }
+        return -1;
+    }
+    if (verbose > 1)
+    {
+        printf("power cap  Data               :%x %x %x %x %x %x %x %x %x %x ",
+            rsp->data[1], rsp->data[2], rsp->data[3], 
+            rsp->data[4], rsp->data[5], rsp->data[6], rsp->data[7], 
+            rsp->data[8], rsp->data[9], rsp->data[10],rsp->data[11]);
+
+    }
+
+    ipmipowercap.PowerCap=((rsp->data[1]<<8)+rsp->data[2]);
+    ipmipowercap.unit=rsp->data[3];
+    ipmipowercap.MaximumPowerConsmp=((rsp->data[4]<<8)+rsp->data[5]);
+    ipmipowercap.MinimumPowerConsmp=((rsp->data[6]<<8)+rsp->data[7]);
+
+    memset(data, 0, 13);
+    req.msg.netfn = IPMI_NETFN_APP;
+    req.msg.lun = 0;
+    req.msg.cmd = IPMI_SET_SYS_INFO;
+    req.msg.data_len = 13;
+    req.msg.data = data;
+    data[0] = IPMI_DELL_POWER_CAP;
+    powercapval=val;
+
+
+    data[1] = (powercapval&0XFF);                   
+    data[2] = ((powercapval&0XFF00)>>8);
+    data[3] = unit;
+
+    data[4]=((ipmipowercap.MaximumPowerConsmp&0xFF));
+    data[5]=((ipmipowercap.MaximumPowerConsmp&0xFF00)>>8);
+    data[6]=((ipmipowercap.MinimumPowerConsmp&0xFF));
+    data[7]=((ipmipowercap.MinimumPowerConsmp&0xFF00)>>8);
+    data[8]=(ipmipowercap.totalnumpowersupp);
+    data[9]=((ipmipowercap.AvailablePower&0xFF));
+    data[10]=((ipmipowercap.AvailablePower&0xFF00)>>8);
+    data[11]=(ipmipowercap.SystemThrottling);
+    data[12]=0x00;
+
+    ipmipowercap.MaximumPowerConsmp = BSWAP_16(ipmipowercap.MaximumPowerConsmp);
+    ipmipowercap.MinimumPowerConsmp = BSWAP_16(ipmipowercap.MinimumPowerConsmp);
+    ipmipowercap.PowerCap = BSWAP_16(ipmipowercap.PowerCap);
+    if(unit==btuphr)
+    {
+        val = btuphr_to_watt_conversion(val);
+
+    }
+    else if(unit ==percent)
+    {
+        if((val <1)||(val>100))
+        {
+            lprintf(LOG_ERR, " Cap value is out of boundary conditon it should be between 0  - 100");
+            return -1;
+        }
+        val =( (val*(ipmipowercap.MaximumPowerConsmp -ipmipowercap.MinimumPowerConsmp))/100)+ipmipowercap.MinimumPowerConsmp;
+        lprintf(LOG_ERR, " Cap value in percentage is  %d ",val);
+        data[1] = (val&0XFF);                   
+        data[2] = ((val&0XFF00)>>8);
+        data[3] = watt;
+    }
+    if(((val<ipmipowercap.MinimumPowerConsmp)||(val>ipmipowercap.MaximumPowerConsmp))&&(unit==watt))
+    {
+        lprintf(LOG_ERR, " Cap value is out of boundary conditon it should be between %d  - %d",
+            ipmipowercap.MinimumPowerConsmp,ipmipowercap.MaximumPowerConsmp);
+        return -1;
+    }
+    else if(((val<ipmipowercap.MinimumPowerConsmp)||(val>ipmipowercap.MaximumPowerConsmp))&&(unit==btuphr))
+    {
+        minpowerbtuphr= watt_to_btuphr_conversion(ipmipowercap.MinimumPowerConsmp);
+        maxpowerbtuphr=watt_to_btuphr_conversion(ipmipowercap.MaximumPowerConsmp);
+        maxpowerbtuphr1= watt_to_btuphr_conversion(ipmipowercap.MaximumPowerConsmp);
+        lprintf(LOG_ERR, " Cap value is out of boundary conditon it should be between %d",
+            minpowerbtuphr);
+        lprintf(LOG_ERR, " -%d",
+            maxpowerbtuphr1);
+
+        return -1;
+    }
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL) 
+    {
+        lprintf(LOG_ERR, " Error setting power cap");
+        return -1;
+    }
+    else if (rsp->ccode > 0) 
+    {
+        lprintf(LOG_ERR, " Error setting power cap: %s",
+            val2str(rsp->ccode, completion_code_vals));
+        return -1;
+    }
+    if (verbose > 1)
+    {
+        printf("CC for setpowercap :%d ",rsp->ccode);
+    }
+    return 0;
+}
+
+/*****************************************************************
+* Function Name:    getpowersupplyfruinfo
+*
+* Description:      This function retrieves the FRU header
+* Input:            intf    - ipmi interface
+*                   header  - watt / btuphr
+*                   fru     - FRU information
+* Output:           header  - FRU header
+* Return:           
+*
+******************************************************************/
+static int getpowersupplyfruinfo(struct ipmi_intf *intf, uint8_t id, 
+                         struct fru_header header, struct fru_info fru)
+{
+    struct ipmi_rs * rsp;
+    struct ipmi_rq req;
+
+    uint8_t msg_data[4];
+
+    memset(&fru, 0, sizeof(struct fru_info));
+    memset(&header, 0, sizeof(struct fru_header));
+
+    /*
+    * get info about this FRU
+    */
+    memset(msg_data, 0, 4);
+    msg_data[0] = id;
+
+    memset(&req, 0, sizeof(req));
+    req.msg.netfn = IPMI_NETFN_STORAGE;
+    req.msg.lun = 0;
+    req.msg.cmd = GET_FRU_INFO;
+    req.msg.data = msg_data;
+    req.msg.data_len = 1;
+
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL) {
+        printf(" Device not present (No Response)\n");
+        return -1;
+    }
+    if (rsp->ccode > 0) {
+        printf(" Device not present (%s)\n",
+            val2str(rsp->ccode, completion_code_vals));
+        return -1;
+    }
+
+    fru.size = (rsp->data[1] << 8) | rsp->data[0];
+    fru.access = rsp->data[2] & 0x1;
+
+    lprintf(LOG_DEBUG, "fru.size = %d bytes (accessed by %s)",
+        fru.size, fru.access ? "words" : "bytes");
+
+    if (fru.size < 1) {
+        lprintf(LOG_ERR, " Invalid FRU size %d", fru.size);
+        return -1;
+    }
+
+    /*
+    * retrieve the FRU header
+    */
+    msg_data[0] = id;
+    msg_data[1] = 0;
+    msg_data[2] = 0;
+    msg_data[3] = 8;
+
+    memset(&req, 0, sizeof(req));
+    req.msg.netfn = IPMI_NETFN_STORAGE;
+    req.msg.lun = 0;
+    req.msg.cmd = GET_FRU_DATA;
+    req.msg.data = msg_data;
+    req.msg.data_len = 4;
+
+    rsp = intf->sendrecv(intf, &req);
+    if (rsp == NULL) {
+        printf(" Device not present (No Response)\n");
+        return 1;
+    }
+    if (rsp->ccode > 0) {
+        printf(" Device not present (%s)\n",
+            val2str(rsp->ccode, completion_code_vals));
+        return 1;
+    }
+
+    if (verbose > 1)
+        printbuf(rsp->data, rsp->data_len, "FRU DATA");
+
+    memcpy(&header, rsp->data + 1, 8);
+
+
+
+}
+
+/*****************************************************************
+* Function Name:   ipmi_powermonitor_usage
+*
+* Description:     This function prints help message for powermonitor command
+* Input:              
+* Output:       
+*
+* Return:              
+*
+******************************************************************/
+static void
+ipmi_powermonitor_usage(void)
+{
+    lprintf(LOG_NOTICE, "");
+    lprintf(LOG_NOTICE, "   powermonitor");
+    lprintf(LOG_NOTICE, "      Shows power tracking statistics ");
+    lprintf(LOG_NOTICE, "");
+    lprintf(LOG_NOTICE, "   powermonitor clear cumulativepower");
+    lprintf(LOG_NOTICE, "      Reset cumulative power reading");
+    lprintf(LOG_NOTICE, "");
+    lprintf(LOG_NOTICE, "   powermonitor clear peakpower");
+    lprintf(LOG_NOTICE, "      Reset peak power reading");
+    lprintf(LOG_NOTICE, "");
+    lprintf(LOG_NOTICE, "   powermonitor powerconsumption");
+    lprintf(LOG_NOTICE, "      Displays power consumption in <watt|btuphr>");
+    lprintf(LOG_NOTICE, "");
+    lprintf(LOG_NOTICE, "   powermonitor powerconsumptionhistory <watt|btuphr>");
+    lprintf(LOG_NOTICE, "      Displays power consumption history ");
+    lprintf(LOG_NOTICE, "");
+    lprintf(LOG_NOTICE, "   powermonitor getpowerbudget");
+    lprintf(LOG_NOTICE, "      Displays power cap in <watt|btuphr>");
+    lprintf(LOG_NOTICE, "");
+    lprintf(LOG_NOTICE, "   powermonitor setpowerbudget <val><watt|btuphr|percent>");
+    lprintf(LOG_NOTICE, "      Allows user to set the  power cap in <watt|BTU/hr|percentage>");
+    lprintf(LOG_NOTICE, "");
+    lprintf(LOG_NOTICE, "   powermonitor enablepowercap ");
+    lprintf(LOG_NOTICE, "      To enable set power cap");
+    lprintf(LOG_NOTICE, "");
+    lprintf(LOG_NOTICE, "   powermonitor disablepowercap ");
+    lprintf(LOG_NOTICE, "      To disable set power cap");
+    lprintf(LOG_NOTICE, "");
+
+}
+
+
+
+
diff --git a/lib/ipmi_event.c b/lib/ipmi_event.c
index a782e2e..fd75bab 100644
--- a/lib/ipmi_event.c
+++ b/lib/ipmi_event.c
@@ -97,7 +97,7 @@ ipmi_send_platform_event(struct ipmi_intf * intf, struct platform_event_msg * em
 	if (chmed == IPMI_CHANNEL_MEDIUM_SYSTEM) {
 		/* system interface, need extra generator ID */
 		req.msg.data_len = 8;
-		rqdata[0] = 0x20;
+		rqdata[0] = 0x41;   // As per Fig. 29-2 and Table 5-4
 		memcpy(rqdata+1, emsg, sizeof(struct platform_event_msg));
 	}
 	else {
@@ -509,7 +509,7 @@ ipmi_event_fromfile(struct ipmi_intf * intf, char * file)
 	chmed = ipmi_current_channel_medium(intf);
 	if (chmed == IPMI_CHANNEL_MEDIUM_SYSTEM) {
 		/* system interface, need extra generator ID */
-		rqdata[0] = 0x20;
+		rqdata[0] = 0x41;   // As per Fig. 29-2 and Table 5-4
 		req.msg.data_len = 8;
 	}
 
diff --git a/lib/ipmi_fru.c b/lib/ipmi_fru.c
index 7bf3766..8c56e9a 100644
--- a/lib/ipmi_fru.c
+++ b/lib/ipmi_fru.c
@@ -73,8 +73,14 @@ static int ipmi_fru_get_multirec_from_file(char * pFileName, uint8_t * pBufArea,
 static int ipmi_fru_get_multirec_size_from_file(char * pFileName, uint32_t * pSize, uint32_t * pOffset);
 static void ipmi_fru_get_adjust_size_from_buffer(uint8_t * pBufArea, uint32_t *pSize);
 static void ipmi_fru_picmg_ext_print(uint8_t * fru_data, int off, int length);
+
 static int ipmi_fru_set_field_string(struct ipmi_intf * intf, unsigned
 						char fruId, uint8_t f_type, uint8_t f_index, char *f_string);
+static int
+ipmi_fru_set_field_string_rebuild(struct ipmi_intf * intf, uint8_t fruId, 
+                                  struct fru_info fru, struct fru_header header, 
+                                  uint8_t f_type, uint8_t f_index, char *f_string);
+
 static void
 fru_area_print_multirec_bloc(struct ipmi_intf * intf, struct fru_info * fru,
 			uint8_t id, uint32_t offset);
@@ -89,8 +95,7 @@ read_fru_area(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,
  *
  * returns pointer to FRU area string
  */
-char *
-get_fru_area_str(uint8_t * data, uint32_t * offset)
+char * get_fru_area_str(uint8_t * data, uint32_t * offset)
 {
 	static const char bcd_plus[] = "0123456789 -.:,_";
 	char * str;
@@ -325,7 +330,7 @@ build_fru_bloc(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,
          //printf("Bloc Size : %i\n", h->len);
          //printf("\n");
 		   i += h->len + sizeof (struct fru_multirec_header);
-	   } while (!(h->format & 0x80));
+	   } while (!(h->format & 0x80) && ( last_off < fru->size));
 
       lprintf(LOG_DEBUG ,"Multi-Record area ends at: %i (%xh)",i,i);
 
@@ -416,13 +421,14 @@ build_fru_bloc(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,
          printf("\n");*/
 
 		   i += h->len + sizeof (struct fru_multirec_header);
-	   } while (!(h->format & 0x80));
+        
+	   } while (!(h->format & 0x80) && ( bloc_count < num_bloc ) );
 
       lprintf(LOG_DEBUG ,"Multi-Record area ends at: %i (%xh)",i,i);
       /* If last bloc size was defined and is not until the end, create a 
          last bloc with the remaining unused space */
 
-      if(fru->size > i)
+      if((fru->size > i) && (bloc_count < num_bloc))
       {
          // Bloc for remaining space
          p_bloc[bloc_count].start = i;
@@ -431,7 +437,6 @@ build_fru_bloc(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,
          bloc_count ++;
        }
      
-
 	   free(fru_data);
    }
 
@@ -460,11 +465,6 @@ build_fru_bloc(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,
          lprintf(LOG_DEBUG ,"Bloc Size : %i\n", p_bloc[counter].size);
          lprintf(LOG_DEBUG ,"\n");
       }
-
-     
-      
-
-
    }
 
    (* ptr_number_bloc) = num_bloc;
@@ -487,7 +487,7 @@ write_fru_area(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,
 	uint16_t off=0,  tmp, finish;
 	struct ipmi_rs * rsp;
 	struct ipmi_rq req;
-	uint8_t msg_data[25];
+	uint8_t msg_data[256];
 	uint8_t writeLength;
    uint16_t num_bloc;
 
@@ -512,6 +512,12 @@ write_fru_area(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,
 #endif
 	  fru_data_rqst_size = 16;
 
+    /* Check if we receive size in parameters */
+    if(intf->channel_buf_size != 0)
+    {
+       fru_data_rqst_size = intf->channel_buf_size - 5; /* Plan for overhead */
+    }
+
 	do {
       /* Temp init end_bloc to the end, if not found */
       uint16_t end_bloc = finish;
@@ -543,9 +549,9 @@ write_fru_area(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,
       }
 
 		tmp = end_bloc - (doffset+off); /* bytes remaining for the bloc */
-		if (tmp > 16) {
-			memcpy(&msg_data[3], pFrubuf + soffset + off, 16);
-			req.msg.data_len = 16 + 3;
+		if (tmp > fru_data_rqst_size) {
+			memcpy(&msg_data[3], pFrubuf + soffset + off, fru_data_rqst_size);
+			req.msg.data_len = fru_data_rqst_size + 3;
 		}
 		else {
 			memcpy(&msg_data[3], pFrubuf + soffset + off, (uint8_t)tmp);
@@ -555,17 +561,16 @@ write_fru_area(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,
       {
 		   lprintf(LOG_INFO,"Writing %d bytes", (req.msg.data_len-3));
       }
-      else
+      else if(found_bloc != 0xFFFF)
       {
          lprintf(LOG_INFO,"Writing %d bytes (Bloc #%i: %s)", 
                         (req.msg.data_len-3),
                         found_bloc, fru_bloc[found_bloc].blocId);
       }
 
-
 		writeLength = req.msg.data_len-3;
 
-		rsp = intf->sendrecv(intf, &req);
+        rsp = intf->sendrecv(intf, &req);
 		if (!rsp) {
 			break;
 		}
@@ -584,11 +589,11 @@ write_fru_area(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,
 
       if(protected_bloc == 0)
       {
+         lprintf(LOG_INFO,"Wrote %d bytes", writeLength); 
 		   off += writeLength; // Write OK, bloc not protected, continue
       }
       else
-      {
-         
+      {         
          if(found_bloc != 0xffff)
          {
             // Bloc protected, advise user and jump over protected bloc
@@ -735,6 +740,15 @@ read_fru_area(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,
 	if (fru->access && fru_data_rqst_size > 16)
 #endif
 		fru_data_rqst_size = 16;
+
+
+    /* Check if we receive size in parameters */
+    if(intf->channel_buf_size != 0)
+    {
+       fru_data_rqst_size = intf->channel_buf_size - 9; /* Plan for overhead */
+    }
+
+
 	do {
 		tmp = fru->access ? off >> 1 : off;
 		msg_data[0] = id;
@@ -1398,7 +1412,7 @@ fru_area_print_multirec(struct ipmi_intf * intf, struct fru_info * fru,
 				}
 				/* FIXME: Add OEM record support here */
 				else{
-					printf("	 OEM (0x%s) Record\n", val2str( iana,	ipmi_oem_info));
+					printf("	 OEM (%s) Record\n", val2str( iana,	ipmi_oem_info));
 				}
 			}
 			break;
@@ -1466,7 +1480,7 @@ int ipmi_fru_query_new_value(uint8_t *data,int offset, size_t len)
  *
  *		IANA			  : 15000  (Kontron)
  *		RECORD ID	  : 3
- *		RECORD VERSION: 0
+ *		RECORD VERSION: 0 (or 1)
  *
  * I would have like to put that stuff in an OEM specific file, but apart for
  * the record format information, all commands are really standard 'FRU' command
@@ -1483,7 +1497,8 @@ int ipmi_fru_query_new_value(uint8_t *data,int offset, size_t len)
  */
 #define OEM_KONTRON_INFORMATION_RECORD 3
 
-#define OEM_KONTRON_COMPLETE_ARG_COUNT	  12
+#define EDIT_OEM_KONTRON_COMPLETE_ARG_COUNT	  12
+#define GET_OEM_KONTRON_COMPLETE_ARG_COUNT	  5
 /*
 ./src/ipmitool	 fru edit 0
   oem 15000 3 0 name instance FIELD1 FIELD2 FIELD3 crc32
@@ -1501,8 +1516,12 @@ int ipmi_fru_query_new_value(uint8_t *data,int offset, size_t len)
 #define OEM_KONTRON_CRC32_ARG_POS		  11
 
 #define OEM_KONTRON_FIELD_SIZE			 8
+#define OEM_KONTRON_VERSION_FIELD_SIZE 10
 
-typedef struct OemKontronInformationRecord{
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
+typedef struct OemKontronInformationRecordV0{
 	uint8_t field1TypeLength;
 	uint8_t field1[OEM_KONTRON_FIELD_SIZE];
 	uint8_t field2TypeLength;
@@ -1511,7 +1530,146 @@ typedef struct OemKontronInformationRecord{
 	uint8_t field3[OEM_KONTRON_FIELD_SIZE];
 	uint8_t crcTypeLength;
 	uint8_t crc32[OEM_KONTRON_FIELD_SIZE];
-}tOemKontronInformationRecord;
+}tOemKontronInformationRecordV0;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
+
+
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
+typedef struct OemKontronInformationRecordV1{
+	uint8_t field1TypeLength;
+	uint8_t field1[OEM_KONTRON_VERSION_FIELD_SIZE];
+	uint8_t field2TypeLength;
+	uint8_t field2[OEM_KONTRON_FIELD_SIZE];
+	uint8_t field3TypeLength;
+	uint8_t field3[OEM_KONTRON_FIELD_SIZE];
+	uint8_t crcTypeLength;
+	uint8_t crc32[OEM_KONTRON_FIELD_SIZE];
+}tOemKontronInformationRecordV1;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
+
+/*
+./src/ipmitool	 fru get 0 oem iana 3
+
+*/
+
+static void ipmi_fru_oemkontron_get( int argc, char ** argv,uint8_t * fru_data,
+												int off,int len,
+												struct fru_multirec_header *h,
+												struct fru_multirec_oem_header *oh)
+{
+	static int badParams=FALSE;
+	int start = off;
+	int offset = start;
+	int length = len;
+	int i;
+	offset += sizeof(struct fru_multirec_oem_header);
+
+	if(!badParams){
+		/* the 'OEM' field is already checked in caller */
+		if( argc > OEM_KONTRON_SUBCOMMAND_ARG_POS ){
+			if(strncmp("oem", argv[OEM_KONTRON_SUBCOMMAND_ARG_POS],3)){
+				printf("usage: fru get <id> <oem>\r\n");
+				badParams = TRUE;
+				return;
+			}
+		}
+		if( argc<GET_OEM_KONTRON_COMPLETE_ARG_COUNT ){
+			printf("usage: oem <iana> <recordid>\r\n");
+			printf("usage: oem 15000 3\r\n");
+			badParams = TRUE;
+			return;
+		}
+	}
+
+	if(!badParams){
+
+		if(oh->record_id == OEM_KONTRON_INFORMATION_RECORD ) {
+
+			uint8_t version;
+
+			printf("Kontron OEM Information Record\n");
+			version = oh->record_version;
+
+			int blockstart;
+			uint8_t blockCount;
+			uint8_t blockIndex=0;
+
+			unsigned int matchInstance = 0;
+			unsigned int instance = atoi( argv[OEM_KONTRON_INSTANCE_ARG_POS]);
+
+			blockCount = fru_data[offset++];
+
+			for(blockIndex=0;blockIndex<blockCount;blockIndex++){
+				void * pRecordData;
+				uint8_t nameLen;
+
+				blockstart = offset;
+				nameLen = ( fru_data[offset++] &= 0x3F );
+				printf("  Name: %*.*s\n",nameLen, nameLen, (const char *)(fru_data+offset));
+
+				offset+=nameLen;
+
+				pRecordData = &fru_data[offset];
+
+				printf("  Record Version: %d\n", version);
+				if( version == 0 )
+				{
+					printf("  Version: %*.*s\n",
+						OEM_KONTRON_FIELD_SIZE, 
+						OEM_KONTRON_FIELD_SIZE,
+						((tOemKontronInformationRecordV0 *) pRecordData)->field1);
+					printf("  Build Date: %*.*s\n",
+						OEM_KONTRON_FIELD_SIZE, 
+						OEM_KONTRON_FIELD_SIZE,
+						((tOemKontronInformationRecordV0 *) pRecordData)->field2);
+					printf("  Update Date: %*.*s\n",
+						OEM_KONTRON_FIELD_SIZE, 
+						OEM_KONTRON_FIELD_SIZE,
+						((tOemKontronInformationRecordV0 *) pRecordData)->field3);
+					printf("  Checksum: %*.*s\n\n",
+						OEM_KONTRON_FIELD_SIZE, 
+						OEM_KONTRON_FIELD_SIZE,
+						((tOemKontronInformationRecordV0 *) pRecordData)->crc32);
+					matchInstance++;
+					offset+= sizeof(tOemKontronInformationRecordV0);
+					offset++;
+				}
+				else if ( version == 1 )
+				{
+					printf("  Version: %*.*s\n",
+						OEM_KONTRON_VERSION_FIELD_SIZE, 
+						OEM_KONTRON_VERSION_FIELD_SIZE,
+						((tOemKontronInformationRecordV1 *) pRecordData)->field1);
+					printf("  Build Date: %*.*s\n",
+						OEM_KONTRON_FIELD_SIZE, 
+						OEM_KONTRON_FIELD_SIZE,
+						((tOemKontronInformationRecordV1 *) pRecordData)->field2);
+					printf("  Update Date: %*.*s\n",
+						OEM_KONTRON_FIELD_SIZE, 
+						OEM_KONTRON_FIELD_SIZE,
+						((tOemKontronInformationRecordV1 *) pRecordData)->field3);
+					printf("  Checksum: %*.*s\n\n",
+						OEM_KONTRON_FIELD_SIZE, 
+						OEM_KONTRON_FIELD_SIZE,
+						((tOemKontronInformationRecordV1 *) pRecordData)->crc32);
+					matchInstance++;
+					offset+= sizeof(tOemKontronInformationRecordV1);
+					offset++;
+				}
+				else
+				{
+					printf ("  Unsupported version %d\n",version);
+				}
+			}
+		}
+	}
+}
 
 static int ipmi_fru_oemkontron_edit( int argc, char ** argv,uint8_t * fru_data,
 												int off,int len,
@@ -1535,7 +1693,7 @@ static int ipmi_fru_oemkontron_edit( int argc, char ** argv,uint8_t * fru_data,
 				return hasChanged;
 			}
 		}
-		if( argc<OEM_KONTRON_COMPLETE_ARG_COUNT ){
+		if( argc<EDIT_OEM_KONTRON_COMPLETE_ARG_COUNT ){
 			printf("usage: oem <iana> <recordid> <format> <args...>\r\n");
 			printf("usage: oem 15000 3 0 <name> <instance> <field1>"\
 					 " <field2> <field3> <crc32>\r\n");
@@ -1545,8 +1703,9 @@ static int ipmi_fru_oemkontron_edit( int argc, char ** argv,uint8_t * fru_data,
 		if( atoi(argv[OEM_KONTRON_RECORDID_ARG_POS])
 			 ==	OEM_KONTRON_INFORMATION_RECORD){
 			for(i=OEM_KONTRON_VERSION_ARG_POS;i<=OEM_KONTRON_CRC32_ARG_POS;i++){
-				if(strlen(argv[i]) != OEM_KONTRON_FIELD_SIZE ){
-					printf("error: version fields must have a %d caracters\r\n",
+				if( (strlen(argv[i]) != OEM_KONTRON_FIELD_SIZE) && 
+					 (strlen(argv[i]) != OEM_KONTRON_VERSION_FIELD_SIZE)) {
+					printf("error: version fields must have %d characters\r\n",
 										OEM_KONTRON_FIELD_SIZE);
 					badParams = TRUE;
 					return hasChanged;
@@ -1558,12 +1717,13 @@ static int ipmi_fru_oemkontron_edit( int argc, char ** argv,uint8_t * fru_data,
 	if(!badParams){
 
 		if(oh->record_id == OEM_KONTRON_INFORMATION_RECORD ) {
+         uint8_t formatVersion = (uint8_t)atoi( argv[OEM_KONTRON_FORMAT_ARG_POS]);
 			uint8_t version;
 
 			printf("	  Kontron OEM Information Record\n");
 			version = oh->record_version;
 
-			if( version == 0 ){
+			if( version == formatVersion  ){
 				int blockstart;
 				uint8_t blockCount;
 				uint8_t blockIndex=0;
@@ -1571,53 +1731,95 @@ static int ipmi_fru_oemkontron_edit( int argc, char ** argv,uint8_t * fru_data,
 				unsigned int matchInstance = 0;
 				unsigned int instance = atoi( argv[OEM_KONTRON_INSTANCE_ARG_POS]);
 
+
 				blockCount = fru_data[offset++];
 				printf("	  blockCount: %d\n",blockCount);
 
 				for(blockIndex=0;blockIndex<blockCount;blockIndex++){
-					tOemKontronInformationRecord *recordData;
+					void * pRecordData;
 					uint8_t nameLen;
 
 					blockstart = offset;
 
-					nameLen = ( fru_data[offset++] &= 0x3F );
+					nameLen = ( fru_data[offset++] & 0x3F );
 
-					if(!strncmp((char *)argv[OEM_KONTRON_NAME_ARG_POS],
-					(const char *)(fru_data+offset),nameLen)&& (matchInstance == instance)){
+               if( version == 0 || version == 1 )
+               {
+                  if(!strncmp((char *)argv[OEM_KONTRON_NAME_ARG_POS],
+                  (const char *)(fru_data+offset),nameLen)&& (matchInstance == instance)){
 
-						printf ("Found : %s\n",argv[OEM_KONTRON_NAME_ARG_POS]);
-						offset+=nameLen;
+                     printf ("Found : %s\n",argv[OEM_KONTRON_NAME_ARG_POS]);
+                     offset+=nameLen;
 
-						recordData = ( tOemKontronInformationRecord *)
-															&fru_data[offset];
+                     pRecordData = 	&fru_data[offset];
 
-						memcpy( recordData->field1 ,
-								  argv[OEM_KONTRON_VERSION_ARG_POS] ,
+                     if( version == 0 )
+                     {
+                        memcpy( ((tOemKontronInformationRecordV0 *)
+    														pRecordData)->field1 ,
+ 								  argv[OEM_KONTRON_VERSION_ARG_POS] ,
 								  OEM_KONTRON_FIELD_SIZE);
-						memcpy( recordData->field2 ,
+                        memcpy( ((tOemKontronInformationRecordV0 *)
+    														pRecordData)->field2 ,
 								  argv[OEM_KONTRON_BUILDDATE_ARG_POS],
 								  OEM_KONTRON_FIELD_SIZE);
-						memcpy( recordData->field3 ,
+                        memcpy( ((tOemKontronInformationRecordV0 *)
+    														pRecordData)->field3 ,
 								  argv[OEM_KONTRON_UPDATEDATE_ARG_POS],
 								  OEM_KONTRON_FIELD_SIZE);
-						memcpy( recordData->crc32 ,
+                        memcpy( ((tOemKontronInformationRecordV0 *)
+    														pRecordData)->crc32 ,
 							  argv[OEM_KONTRON_CRC32_ARG_POS] ,
 							  OEM_KONTRON_FIELD_SIZE);
+                     }
+                     else 
+                     {
+                        memcpy( ((tOemKontronInformationRecordV1 *)
+    														pRecordData)->field1 ,
+ 								  argv[OEM_KONTRON_VERSION_ARG_POS] ,
+								  OEM_KONTRON_VERSION_FIELD_SIZE);
+                        memcpy( ((tOemKontronInformationRecordV1 *)
+    														pRecordData)->field2 ,
+								  argv[OEM_KONTRON_BUILDDATE_ARG_POS],
+								  OEM_KONTRON_FIELD_SIZE);
+                        memcpy( ((tOemKontronInformationRecordV1 *)
+    														pRecordData)->field3 ,
+								  argv[OEM_KONTRON_UPDATEDATE_ARG_POS],
+								  OEM_KONTRON_FIELD_SIZE);
+                        memcpy( ((tOemKontronInformationRecordV1 *)
+    														pRecordData)->crc32 ,
+							  argv[OEM_KONTRON_CRC32_ARG_POS] ,
+							  OEM_KONTRON_FIELD_SIZE);
+                     }
 
-						matchInstance++;
-						hasChanged = TRUE;
-					}
-					else if(!strncmp((char *)argv[OEM_KONTRON_NAME_ARG_POS],
-					      (const char *)(fru_data+offset), nameLen)){
-						printf ("Skipped : %s\n",argv[OEM_KONTRON_NAME_ARG_POS]);
-						matchInstance++;
-						offset+=nameLen;
-					}
-					else{
-						offset+=nameLen;
-					}
-
-					offset+=37;
+                     matchInstance++;
+                     hasChanged = TRUE;
+                  }
+                  else if(!strncmp((char *)argv[OEM_KONTRON_NAME_ARG_POS],
+                       (const char *)(fru_data+offset), nameLen)){
+                     printf ("Skipped : %s  [instance %d]\n",argv[OEM_KONTRON_NAME_ARG_POS],
+                             matchInstance);
+                     matchInstance++;       
+                     offset+=nameLen;           
+                  }
+                  else {
+                     offset+=nameLen;
+                  }
+  
+                  if( version == 0 )
+                  {
+                     offset+= sizeof(tOemKontronInformationRecordV0);
+                  }
+                  else
+                  {
+                     offset+= sizeof(tOemKontronInformationRecordV1);
+                  }
+                  offset++;
+               }
+               else 
+               {
+                  printf ("  Unsupported version %d\n",version);
+               }		
 				}
 			}
 			else{
@@ -1747,6 +1949,14 @@ static int ipmi_fru_picmg_ext_edit(uint8_t * fru_data,
 	return hasChanged;
 }
 
+/* ipmi_fru_picmg_ext_print  - prints OEM fru record (PICMG)
+ *
+ * @fru_data:	FRU data
+ * @offset:	   offset of the bytes to be modified in data
+ * @length:		size of the record
+ *
+ * returns : n/a
+ */
 static void ipmi_fru_picmg_ext_print(uint8_t * fru_data, int off, int length)
 {
 	struct fru_multirec_oem_header *h;
@@ -3010,6 +3220,155 @@ ipmi_fru_edit_multirec(struct ipmi_intf * intf, uint8_t id ,
 	return 0;
 }
 
+/* ipmi_fru_get_multirec	-	Query new values to replace original FRU content
+ *
+ * @intf:	interface to use
+ * @id:	FRU id to work on
+ *
+ * returns: nothing
+ */
+/* Work in progress, copy paste most of the stuff for other functions in this
+	file ... not elegant yet */
+static int
+ipmi_fru_get_multirec(struct ipmi_intf * intf, uint8_t id ,
+												  int argc, char ** argv)
+{
+
+	struct ipmi_rs * rsp;
+	struct ipmi_rq req;
+	struct fru_info fru;
+	struct fru_header header;
+	uint8_t msg_data[4];
+
+	uint16_t retStatus = 0;
+	uint32_t offFruMultiRec;
+	uint32_t fruMultiRecSize = 0;
+	struct fru_info fruInfo;
+	retStatus = ipmi_fru_get_multirec_location_from_fru(intf, id, &fruInfo,
+								 &offFruMultiRec,
+								 &fruMultiRecSize);
+
+
+	lprintf(LOG_DEBUG, "FRU Size			: %lu\n", fruMultiRecSize);
+	lprintf(LOG_DEBUG, "Multi Rec offset: %lu\n", offFruMultiRec);
+
+	{
+
+
+	memset(&fru, 0, sizeof(struct fru_info));
+	memset(&header, 0, sizeof(struct fru_header));
+
+	/*
+	 * get info about this FRU
+	 */
+	memset(msg_data, 0, 4);
+	msg_data[0] = id;
+
+	memset(&req, 0, sizeof(req));
+	req.msg.netfn = IPMI_NETFN_STORAGE;
+	req.msg.cmd = GET_FRU_INFO;
+	req.msg.data = msg_data;
+	req.msg.data_len = 1;
+
+	rsp = intf->sendrecv(intf, &req);
+	if (rsp == NULL) {
+		printf(" Device not present (No Response)\n");
+		return -1;
+	}
+	if (rsp->ccode > 0) {
+		printf(" Device not present (%s)\n",
+			val2str(rsp->ccode, completion_code_vals));
+		return -1;
+	}
+
+	fru.size = (rsp->data[1] << 8) | rsp->data[0];
+	fru.access = rsp->data[2] & 0x1;
+
+	lprintf(LOG_DEBUG, "fru.size = %d bytes (accessed by %s)",
+		fru.size, fru.access ? "words" : "bytes");
+
+	if (fru.size < 1) {
+		lprintf(LOG_ERR, " Invalid FRU size %d", fru.size);
+		return -1;
+	}
+	}
+
+	{
+		uint8_t * fru_data;
+		uint32_t fru_len, i;
+		uint32_t offset= offFruMultiRec;
+		struct fru_multirec_header * h;
+		uint32_t last_off, len;
+		uint8_t error=0;
+
+		i = last_off = offset;
+		fru_len = 0;
+
+		fru_data = malloc(fru.size + 1);
+		if (fru_data == NULL) {
+			lprintf(LOG_ERR, " Out of memory!");
+			return -1;
+		}
+		memset(fru_data, 0, fru.size + 1);
+
+		do {
+			h = (struct fru_multirec_header *) (fru_data + i);
+
+			/* read area in (at most) FRU_MULTIREC_CHUNK_SIZE bytes at a time */
+			if ((last_off < (i + sizeof(*h))) || (last_off < (i + h->len)))
+			{
+				len = fru.size - last_off;
+				if (len > FRU_MULTIREC_CHUNK_SIZE)
+					len = FRU_MULTIREC_CHUNK_SIZE;
+
+				if (read_fru_area(intf, &fru, id, last_off, len, fru_data) < 0)
+					break;
+
+				last_off += len;
+			}
+			if( h->type ==	 FRU_RECORD_TYPE_OEM_EXTENSION ){
+
+				struct fru_multirec_oem_header *oh=(struct fru_multirec_oem_header *)
+										 &fru_data[i + sizeof(struct fru_multirec_header)];
+				uint32_t iana = oh->mfg_id[0] | oh->mfg_id[1]<<8 | oh->mfg_id[2]<<16;
+
+				uint32_t suppliedIana = 0 ;
+				/* Now makes sure this is really PICMG record */
+				if( !strncmp( argv[2] , "oem" , 3 )) {
+					/* Expect IANA number next */
+					if( argc <= 3 ) {
+						lprintf(LOG_ERR, "oem iana <record> <format>");
+						error = 1;
+					} else {
+						suppliedIana = atol ( argv[3] ) ;
+						lprintf(LOG_DEBUG, "using iana: %d", suppliedIana);
+					}
+				}
+
+				if( suppliedIana == iana ) {
+					lprintf(LOG_DEBUG, "Matching record found" );
+
+				if( iana == IPMI_OEM_KONTRON ) {
+						ipmi_fru_oemkontron_get( argc,argv,fru_data,
+						 i + sizeof(struct fru_multirec_header),
+						 h->len, h, oh );
+					}
+					/* FIXME: Add OEM record support here */
+					else{
+						printf("	 OEM IANA (%s) Record not supported in this mode\n",
+															val2str( iana,	 ipmi_oem_info));
+						error = 1;
+					}
+				}
+			}
+			i += h->len + sizeof (struct fru_multirec_header);
+		} while (!(h->format & 0x80) && (error != 1));
+
+		free(fru_data);
+	}
+	return 0;
+}
+
 
 static int
 ipmi_fru_upg_ekeying(struct ipmi_intf * intf,
@@ -3811,6 +4170,36 @@ ipmi_fru_main(struct ipmi_intf * intf, int argc, char ** argv)
 
 		}
 	}
+	else if (!strncmp(argv[0], "get", 4)) {
+
+		if ((argc >= 2) && (strncmp(argv[1], "help", 4) == 0)) {
+			lprintf(LOG_ERR, "get commands:");
+			lprintf(LOG_ERR, "  get - retrieve OEM records");
+			lprintf(LOG_ERR,
+				"  get <fruid> oem iana <record> <format> <args> - limited OEM support");
+		} else {
+
+		uint8_t fruId = 0;
+
+		if ((argc >= 2) && (strlen(argv[1]) > 0)) {
+			fruId = atoi(argv[1]);
+			if (verbose) {
+				printf("Fru Id				 : %d\n", fruId);
+			}
+		} else {
+			printf("Using default FRU id: %d\n", fruId);
+		}
+
+		if ((argc >= 3) && (strlen(argv[1]) > 0)) {
+			if (!strncmp(argv[2], "oem", 3)){
+				ipmi_fru_get_multirec(intf,fruId, argc, argv);
+			}
+		} else {
+			ipmi_fru_get_multirec(intf,fruId, argc, argv);
+		}
+
+		}
+	}
 	else {
 		lprintf(LOG_ERR, "Invalid FRU command: %s", argv[0]);
 		lprintf(LOG_ERR, "FRU Commands:	print read write upgEkey edit");
@@ -3819,13 +4208,15 @@ ipmi_fru_main(struct ipmi_intf * intf, int argc, char ** argv)
 
 	return rc;
 }
-/* ipmi_fru_set_field_string -  Set a field string to a new value, Need to be the same size
+/* ipmi_fru_set_field_string -  Set a field string to a new value, Need to be the same size.  If
+ *                              size if not equal, the function ipmi_fru_set_field_string_rebuild
+ *                              will be called.
  *
- * @intf:		ipmi interface
- * @id:		fru id
- * @f_type:		 Type of the Field : c=Chassis b=Board p=Product
- * @f_index:	  findex of the field, zero indexed.
- * @f_string:		NULL terminated string
+ * @intf:	    ipmi interface
+ * @id:		    fru id
+ * @f_type:		Type of the Field : c=Chassis b=Board p=Product
+ * @f_index:	findex of the field, zero indexed.
+ * @f_string:	NULL terminated string
  *
  * returns -1 on error
  * returns 1 if successful
@@ -3867,8 +4258,8 @@ f_type, uint8_t f_index, char *f_string)
 			val2str(rsp->ccode, completion_code_vals));
 		return(-1);
 	}
-	printf("OK\n");
-	fru.size = (rsp->data[1] << 8) | rsp->data[0];
+
+    fru.size = (rsp->data[1] << 8) | rsp->data[0];
 	fru.access = rsp->data[2] & 0x1;
 
 	if (fru.size < 1) {
@@ -3925,21 +4316,21 @@ f_type, uint8_t f_index, char *f_string)
 	/* Setup offset from the field type */
 
 	/* Chassis type field */
-	if (f_type == 0x63) {
+	if (f_type == 'c' ) {
 		header_offset = (header.offset.chassis * 8);
 		read_fru_area(intf ,&fru, fruId, header_offset , 3 , fru_data);
 		fru_field_offset = (header.offset.chassis * 8) + 3;
 		fru_section_len = *(fru_data + header_offset + 1) * 8;
 	}
 	/* Board type field */
-	else if (f_type == 0x62) {
+	else if (f_type == 'b' ) {
 		header_offset = (header.offset.board * 8);
 		read_fru_area(intf ,&fru, fruId, header_offset , 3 , fru_data);
 		fru_field_offset = (header.offset.board * 8) + 6;
 		fru_section_len = *(fru_data + header_offset + 1) * 8;
 	}
 	/* Product type field */
-	else if (f_type == 0x70) {
+	else if (f_type == 'p' ) {
 		header_offset = (header.offset.product * 8);
 		read_fru_area(intf ,&fru, fruId, header_offset , 3 , fru_data);
 		fru_field_offset = (header.offset.product * 8) + 3;
@@ -3965,17 +4356,28 @@ f_type, uint8_t f_index, char *f_string)
 	{
 		  fru_area = (uint8_t *) get_fru_area_str(fru_data, &fru_field_offset);
 	}
-	if ( strlen((const char *)fru_area) == 0 ) {
+
+	if( (fru_area == NULL )  || strlen((const char *)fru_area) == 0 ) {
 		printf("Field not found!\n");
 		return -1;
 	}
 		/* Get original field string */
 	fru_field_offset_tmp = fru_field_offset;
 	fru_area = (uint8_t *) get_fru_area_str(fru_data, &fru_field_offset);
+   if ( (fru_area == NULL ) || strlen((const char *)fru_area) == 0 ) {
+      printf("Field not found!\n");
+      return -1;
+   }
+
+
+   if ( (fru_area == NULL ) || strlen((const char *)fru_area) == 0 ) {
+      printf("Field not found!\n");
+      return -1;
+   }
 
 	if ( strlen((const char *)fru_area) == strlen((const char *)f_string) )
 	{
-			printf("Updating Field...\n");
+			printf("Updating Field '%s' with '%s' ...\n", fru_area, f_string );
 			memcpy(fru_data + fru_field_offset_tmp + 1,
 									f_string, strlen(f_string));
 
@@ -3999,10 +4401,398 @@ f_type, uint8_t f_index, char *f_string)
 			}
 	}
 	else {
-			printf("String size are not equal.\n");
-			free(fru_data);
-			return -1;
+            free(fru_data); /* Free data, will be rebuild in function */
+
+            printf("String size are not equal, resizing fru to fit new string\n");
+
+            if( 
+                 ipmi_fru_set_field_string_rebuild(intf,fruId,fru,header,f_type,f_index,f_string)
+              )
+            {
+                return -1;
+            }
 	}
 	free(fru_data);
 	return 1;
 }
+
+/* 
+   This function can update a string within of the following section when the size is not equal:
+ 
+   Chassis
+   Product
+   Board
+*/
+/* ipmi_fru_set_field_string_rebuild -  Set a field string to a new value, When size are not
+ *                                      the same size.
+ *
+ *  This function can update a string within of the following section when the size is not equal:
+ *
+ *      - Chassis
+ *      - Product
+ *      - Board
+ *
+ * @intf:	  ipmi interface
+ * @fruId:	  fru id
+ * @fru:      info about fru
+ * @header:   contain the header of the FRU
+ * @f_type:	  Type of the Field : c=Chassis b=Board p=Product
+ * @f_index:  findex of the field, zero indexed.
+ * @f_string: NULL terminated string
+ *
+ * returns -1 on error
+ * returns 1 if successful
+ */
+ 
+#define DBG_RESIZE_FRU
+static int
+ipmi_fru_set_field_string_rebuild(struct ipmi_intf * intf, uint8_t fruId, 
+                                  struct fru_info fru, struct fru_header header, 
+                                  uint8_t f_type, uint8_t f_index, char *f_string)
+{
+	struct ipmi_rs *rsp;
+	struct ipmi_rq req;
+
+	uint8_t msg_data[4];
+	uint8_t checksum;
+	int i = 0;
+	uint8_t	*fru_data_old, *fru_data_new, *fru_area = NULL;
+	uint32_t fru_field_offset, fru_field_offset_tmp;
+	uint32_t fru_section_len, old_section_len, header_offset;
+    uint32_t chassis_offset, board_offset, product_offset;
+    uint32_t chassis_len, board_len, product_len;
+    int      num_byte_change = 0, padding_len = 0;
+    uint32_t counter;
+    unsigned char cksum;
+
+	fru_data_old = malloc( fru.size );
+    fru_data_new = malloc( fru.size );
+
+	if( fru_data_old == NULL || fru_data_new == NULL )
+	{
+		printf("Out of memory!\n");
+		return(-1);
+	}
+
+    /*************************
+      1) Read ALL FRU */
+    printf("Read All FRU area\n"); 
+    printf("Fru Size       : %lu bytes\n", fru.size); 
+
+    /* Read current fru data */
+    read_fru_area(intf ,&fru, fruId, 0, fru.size , fru_data_old);
+
+    #ifdef DBG_RESIZE_FRU
+    printf("Copy to new FRU\n"); 
+    #endif
+
+    /*************************
+      2) Copy all FRU to new FRU */
+    memcpy(fru_data_new, fru_data_old, fru.size);
+
+    /* Build location of all modifiable components */
+    chassis_offset = (header.offset.chassis * 8);
+    board_offset   = (header.offset.board   * 8);
+    product_offset = (header.offset.product * 8);
+
+    /* Retreive length of all modifiable components */
+    chassis_len    =  *(fru_data_old + chassis_offset + 1) * 8;
+    board_len      =  *(fru_data_old + board_offset   + 1) * 8;
+    product_len    =  *(fru_data_old + product_offset + 1) * 8;
+
+    /* Chassis type field */
+	if (f_type == 'c' ) 
+    {
+		header_offset    = chassis_offset;
+		fru_field_offset = chassis_offset + 3;
+		fru_section_len  = chassis_len;
+	}
+	/* Board type field */
+	else if (f_type == 'b' ) 
+    {
+		header_offset    = board_offset;
+		fru_field_offset = board_offset + 6;
+		fru_section_len  = board_len;
+	}
+	/* Product type field */
+	else if (f_type == 'p' ) 
+    {
+		header_offset    = product_offset;
+		fru_field_offset = product_offset + 3;
+		fru_section_len  = product_len;
+	}
+	else
+	{
+        printf("Wrong field type.");
+		return -1;
+	}
+
+    /* Keep length for future old section display */
+    old_section_len = fru_section_len; 
+
+    /*************************
+      3) Seek to field index */
+	for( i=0; i<f_index; i++ )
+	{
+        fru_area = (uint8_t *) get_fru_area_str(fru_data_old, &fru_field_offset);
+	}
+
+	if( (fru_area == NULL )  || strlen((const char *)fru_area) == 0 ) {
+		printf("Field not found (1)!\n");
+		return -1;
+	}
+
+    /* Get original field string */
+	fru_field_offset_tmp = fru_field_offset;
+	fru_area = (uint8_t *) get_fru_area_str(fru_data_old, &fru_field_offset);
+    if ( (fru_area == NULL ) || strlen((const char *)fru_area) == 0 ) 
+    {
+      printf("Field not found! (2)\n");
+      return -1;
+    }
+
+    if ( (fru_area == NULL ) || strlen((const char *)fru_area) == 0 ) 
+    {
+        printf("Field not found! (3)\n");
+        return -1;
+    }
+
+    #ifdef DBG_RESIZE_FRU
+    printf("Section Length: %lu\n", fru_section_len);
+    #endif
+
+    /*************************
+      4) Check number of padding bytes and bytes changed */
+    for(counter = 2; counter < fru_section_len; counter ++)
+    {
+       if(*(fru_data_old + (header_offset + fru_section_len - counter)) == 0)
+          padding_len ++;
+       else
+          break;
+    }
+    num_byte_change = strlen(f_string) - strlen(fru_area);
+
+    #ifdef DBG_RESIZE_FRU
+    printf("Padding Length: %u\n", padding_len);
+    printf("NumByte Change: %i\n", num_byte_change);
+    printf("Start SecChnge: %x\n", *(fru_data_old + fru_field_offset_tmp));
+    printf("End SecChnge  : %x\n", *(fru_data_old + fru_field_offset_tmp + strlen(f_string) + 1));
+
+    printf("Start Section : %x\n", *(fru_data_old + header_offset));
+    printf("End Sec wo Pad: %x\n", *(fru_data_old + header_offset + fru_section_len - 2 - padding_len));
+    printf("End Section   : %x\n", *(fru_data_old + header_offset + fru_section_len - 1));
+    #endif
+
+    /* Calculate New Padding Length */ 
+    padding_len -= num_byte_change;
+    
+    #ifdef DBG_RESIZE_FRU
+    printf("New Padding Length: %i\n", padding_len);
+    #endif
+
+    /*************************
+      5) Check if section must be resize.  This occur when padding length is not between 0 and 7 */
+    if( (padding_len < 0) || (padding_len >= 8))
+    {
+        uint32_t remaining_offset = ((header.offset.product * 8) + product_len);
+        int change_size_by_8;
+
+        if(padding_len >= 8)
+        {
+            /* Section must be set smaller */
+            change_size_by_8 = ((padding_len) / 8) * (-1);
+        }
+        else
+        {
+            /* Section must be set bigger */
+            change_size_by_8 = 1 + (((padding_len+1) / 8) * (-1));
+        }
+
+        /* Recalculate padding and section length base on the section changes */
+        fru_section_len += (change_size_by_8 * 8);
+        padding_len     += (change_size_by_8 * 8);
+
+        #ifdef DBG_RESIZE_FRU
+        printf("change_size_by_8: %i\n", change_size_by_8);
+        printf("New Padding Length: %i\n", padding_len);
+        printf("change_size_by_8: %i\n", change_size_by_8);
+        printf("header.offset.board: %i\n", header.offset.board);
+        #endif
+
+        /* Must move sections */
+        /* Section that can be modified are as follow
+           Chassis
+           Board
+           product */
+
+        /* Chassis type field */
+        if (f_type == 'c' ) 
+        {
+            printf("Moving Section Chassis, from %i to %i\n", 
+                        ((header.offset.board) * 8),
+                        ((header.offset.board + change_size_by_8) * 8)
+                  ); 
+            memcpy( 
+                     (fru_data_new + ((header.offset.board + change_size_by_8) * 8)),
+                     (fru_data_old + (header.offset.board) * 8),
+                     board_len
+                  );
+            header.offset.board   += change_size_by_8;
+        }
+        /* Board type field */
+        if ((f_type == 'c' ) || (f_type == 'b' ))
+        {
+            printf("Moving Section Product, from %i to %i\n", 
+                        ((header.offset.product) * 8),
+                        ((header.offset.product + change_size_by_8) * 8)
+                  ); 
+            memcpy( 
+                     (fru_data_new + ((header.offset.product + change_size_by_8) * 8)),
+                     (fru_data_old + (header.offset.product) * 8),
+                     product_len
+                  );
+            header.offset.product += change_size_by_8;
+        }
+
+        /* Adjust length of the section */
+        if (f_type == 'c') 
+        {
+            *(fru_data_old + chassis_offset + 1) += change_size_by_8;
+        }
+        else if( f_type == 'b')
+        {
+            *(fru_data_new + board_offset + 1)   += change_size_by_8;
+        }
+        else if( f_type == 'p')
+        {
+            *(fru_data_new + product_offset + 1) += change_size_by_8;
+        }
+
+        /* Rebuild Header checksum */
+        {
+            unsigned char * pfru_header = (unsigned char *) &header;
+            header.checksum = 0;
+            for(counter = 0; counter < (sizeof(struct fru_header) -1); counter ++)
+            {
+                header.checksum += pfru_header[counter];
+            }
+            header.checksum = (0 - header.checksum);
+            memcpy(fru_data_new, pfru_header, sizeof(struct fru_header));
+        }
+
+        /* Move remaining sections in 1 copy */
+        printf("Moving Remaining Bytes (Multi-Rec , etc..), from %i to %i\n", 
+                    remaining_offset,
+                    ((header.offset.product + change_size_by_8) * 8) + product_len
+              ); 
+        memcpy( 
+                fru_data_new + ((header.offset.product + change_size_by_8) * 8) + product_len,
+                fru_data_old + remaining_offset,
+                fru.size - (((header.offset.product + change_size_by_8) * 8) + product_len)
+              );
+
+    }
+
+    /* Update only if it's fits padding length as defined in the spec, otherwise, it's an internal
+       error */
+    /*************************
+      6) Update Field and sections */
+    if( (padding_len >=0) && (padding_len < 8))
+    {
+        /* Do not requires any change in other section */
+
+        /* Change field length */
+        printf("Updating Field : '%s' with '%s' ... (Length from '%x' to '%x')\n", 
+            fru_area, f_string, *(fru_data_old + fru_field_offset_tmp), (0xc0 + strlen(f_string)));
+        *(fru_data_new + fru_field_offset_tmp) = (0xc0 + strlen(f_string));
+        memcpy(fru_data_new + fru_field_offset_tmp + 1, f_string, strlen(f_string));
+
+        /* Copy remaing bytes in section */
+        #ifdef DBG_RESIZE_FRU
+        printf("Copying remaining of sections: %lu \n",
+                 (
+                 (fru_data_old + header_offset + fru_section_len - 1) 
+                 - 
+                 (fru_data_old + fru_field_offset_tmp + strlen(f_string) + 1) 
+                ));
+        #endif
+
+        memcpy( 
+                (fru_data_new + fru_field_offset_tmp + 1 + strlen(f_string)), 
+                (fru_data_old + fru_field_offset_tmp + 1 + strlen(fru_area)), 
+                (
+                 (fru_data_old + header_offset + fru_section_len - 1) 
+                 - 
+                 (fru_data_old + fru_field_offset_tmp + strlen(f_string) + 1) 
+                )
+              );
+        
+
+        /* Add Padding if required */
+        for(counter = 0; counter < padding_len; counter ++)
+        {
+            *(fru_data_new + header_offset + fru_section_len - 1 - padding_len+ counter) = 0;
+        }
+
+        /* Calculate New Checksum */
+        cksum = 0;
+        for( counter = 0; counter <fru_section_len-1; counter ++ )
+        {
+            cksum += *(fru_data_new + header_offset + counter);
+        }
+        *(fru_data_new + header_offset + fru_section_len - 1) = (0 - cksum);
+
+        #ifdef DBG_RESIZE_FRU
+        printf("Calculate New Checksum: %x\n", (0 - cksum));
+        #endif
+
+        /****** ENABLE to show section modified before and after ********/
+        #if 0
+        printf("Section: ");
+        for( counter = 0; counter <old_section_len; counter ++ )
+        {
+            if((counter %16) == 0)
+            {
+                 printf("\n");
+            }
+            printf( "%02X ", *(fru_data_old + header_offset + counter) );
+        }
+        printf("\n");
+
+        printf("Section: ");
+        for( counter = 0; counter <fru_section_len; counter ++ )
+        {
+            if((counter %16) == 0)
+            {
+                 printf("\n");
+            }
+            printf( "%02X ", *(fru_data_new + header_offset + counter) );
+        }
+        printf("\n");
+        #endif
+    }
+    else
+    {
+        printf( "Internal error, padding length %i (must be from 0 to 7) ", padding_len );
+        free(fru_data_old);
+        free(fru_data_new);
+        return -1;
+    }
+
+    /*************************
+      7) Finally, write new FRU */
+    printf("Writing new FRU.\n");
+    if( write_fru_area( intf, &fru, fruId, 0, 0, fru.size, fru_data_new ) < 0 )
+    {
+        printf("Write to FRU data failed.\n");
+        free(fru_data_old);
+        free(fru_data_new);
+        return -1;
+    }
+
+    printf("Done.\n");
+          
+    free(fru_data_old);
+    free(fru_data_new);
+	return 1;
+}
diff --git a/lib/ipmi_fwum.c b/lib/ipmi_fwum.c
index 3a92a9c..e39db0a 100644
--- a/lib/ipmi_fwum.c
+++ b/lib/ipmi_fwum.c
@@ -1,1678 +1,1678 @@
-/*
- * Copyright (c) 2004 Kontron Canada, Inc.  All Rights Reserved.
- *
- * Base on code from
- * Copyright (c) 2003 Sun Microsystems, Inc.  All Rights Reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * Redistribution of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *
- * Redistribution in binary form must reproduce the above copyright
- * notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * Neither the name of Sun Microsystems, Inc. or the names of
- * contributors may be used to endorse or promote products derived
- * from this software without specific prior written permission.
- *
-  * This software is provided "AS IS," without a warranty of any kind.
- * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES,
- * INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A
- * PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY EXCLUDED.
- * SUN MICROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL NOT BE LIABLE
- * FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING
- * OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.  IN NO EVENT WILL
- * SUN OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA,
- * OR FOR DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR
- * PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF
- * LIABILITY, ARISING OUT OF THE USE OF OR INABILITY TO USE THIS SOFTWARE,
- * EVEN IF SUN HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
- */
-
-
-#include <string.h>
-#include <math.h>
-#include <time.h>
-#include <unistd.h>
-
-#include <ipmitool/helper.h>
-#include <ipmitool/ipmi.h>
-#include <ipmitool/ipmi_fwum.h>
-#include <ipmitool/ipmi_intf.h>
-#include <ipmitool/ipmi_mc.h>
-
-/******************************************************************************
-* HISTORY
-* ===========================================================================
-* 2007-01-11 [FI]
-*  - Incremented to version 1.3
-*  - Added lan packet size reduction mechanism to workaround fact
-*    that lan iface will not return C7 on excessive length
-*
-*****************************************************************************/
-
-#define VERSION_MAJ        1
-#define VERSION_MIN        3
-
-
-typedef enum eKFWUM_Task
-{
-   KFWUM_TASK_INFO,
-   KFWUM_TASK_STATUS,
-   KFWUM_TASK_DOWNLOAD,
-   KFWUM_TASK_UPGRADE,
-   KFWUM_TASK_START_UPGRADE,
-   KFWUM_TASK_ROLLBACK,
-   KFWUM_TASK_TRACELOG
-}tKFWUM_Task;
-
-typedef enum eKFWUM_BoardList
-{
-   KFWUM_BOARD_KONTRON_UNKNOWN   = 0,
-   KFWUM_BOARD_KONTRON_5002      = 5002,
-}tKFWUM_BoardList;
-
-typedef enum eKFWUM_IanaList
-{
-   KFWUM_IANA_KONTRON            = 15000,
-}tKFWUM_IanaList;
-
-typedef struct sKFWUM_BoardInfo
-{
-   tKFWUM_BoardList boardId;
-   tKFWUM_IanaList  iana;
-}tKFWUM_BoardInfo;
-
-typedef enum eKFWUM_Status
-{
-   KFWUM_STATUS_OK,
-   KFWUM_STATUS_ERROR
-}tKFWUM_Status;
-
-typedef enum eKFWUM_DownloadType
-{
-   KFWUM_DOWNLOAD_TYPE_ADDRESS = 0,
-	KFWUM_DOWNLOAD_TYPE_SEQUENCE,
-}tKFWUM_DownloadType;
-
-typedef enum eKFWUM_DownloadBuffferType
-{
-   KFWUM_SMALL_BUFFER_TYPE = 0,
-	KFUMW_BIG_BUFFER_TYPE
-}tKFWUM_DownloadBuffferType;
-
-typedef struct sKFWUM_InFirmwareInfo
-{
-   unsigned long   fileSize;
-   unsigned short  checksum;
-   unsigned short  sumToRemoveFromChecksum;
-                                  /* Since the checksum is added in the bin
-                                  after the checksum is calculated, we
-                                  need to remove the each byte value.  This
-                                  byte will contain the addition of both bytes*/
-   tKFWUM_BoardList boardId;
-   unsigned char   deviceId;
-   unsigned char   tableVers;
-   unsigned char   implRev;
-   unsigned char   versMajor;
-   unsigned char   versMinor;
-   unsigned char   versSubMinor;
-   unsigned char   sdrRev;
-   tKFWUM_IanaList iana;
-}tKFWUM_InFirmwareInfo;
-
-typedef struct sKFWUM_SaveFirmwareInfo
-{
-	tKFWUM_DownloadType downloadType;
-   unsigned char       bufferSize;
-   unsigned char       overheadSize;	
-}tKFWUM_SaveFirmwareInfo;	
-  
-#define KFWUM_SMALL_BUFFER     32 /* Minimum size (IPMB/IOL/old protocol) */
-#define KFWUM_BIG_BUFFER       32 /* Maximum size on KCS interface        */
-
-#define KFWUM_OLD_CMD_OVERHEAD 6  /*3 address + 1 size + 1 checksum + 1 command*/
-#define KFWUM_NEW_CMD_OVERHEAD 4  /*1 sequence+ 1 size + 1 checksum + 1 command*/
-#define KFWUM_PAGE_SIZE        256
-
-extern int verbose;
-static unsigned char fileName[512];
-static unsigned char firmBuf[1024*512];
-static tKFWUM_SaveFirmwareInfo saveFirmwareInfo;
-
-static void KfwumOutputHelp(void);
-static void KfwumMain(struct ipmi_intf * intf, tKFWUM_Task task);
-static tKFWUM_Status KfwumGetFileSize(unsigned char * pFileName,
-                                                     unsigned long * pFileSize);
-static tKFWUM_Status KfwumSetupBuffersFromFile(unsigned char * pFileName,
-                                                        unsigned long fileSize);
-static void KfwumShowProgress( const unsigned char * task,
-                                    unsigned long current, unsigned long total);
-static unsigned short KfwumCalculateChecksumPadding(unsigned char * pBuffer,
-                                                       unsigned long totalSize);
-
-
-static tKFWUM_Status KfwumGetInfo(struct ipmi_intf * intf, unsigned char output,
-                                                       unsigned char *pNumBank);
-static tKFWUM_Status KfwumGetDeviceInfo(struct ipmi_intf * intf,
-                           unsigned char output, tKFWUM_BoardInfo * pBoardInfo);
-static tKFWUM_Status KfwumGetStatus(struct ipmi_intf * intf);
-static tKFWUM_Status KfwumManualRollback(struct ipmi_intf * intf);
-static tKFWUM_Status KfwumStartFirmwareImage(struct ipmi_intf * intf,
-                                   unsigned long length,unsigned short padding);
-static tKFWUM_Status KfwumSaveFirmwareImage(struct ipmi_intf * intf,
-     unsigned char sequenceNumber, unsigned long address, 
-     unsigned char *pFirmBuf, unsigned char * pInBufLength);
-static tKFWUM_Status KfwumFinishFirmwareImage(struct ipmi_intf * intf,
-                                                tKFWUM_InFirmwareInfo firmInfo);
-static tKFWUM_Status KfwumUploadFirmware(struct ipmi_intf * intf,
-                              unsigned char * pBuffer, unsigned long totalSize);
-static tKFWUM_Status KfwumStartFirmwareUpgrade(struct ipmi_intf * intf);
-
-static tKFWUM_Status KfwumGetInfoFromFirmware(unsigned char * pBuf,
-                         unsigned long bufSize, tKFWUM_InFirmwareInfo * pInfo);
-static void KfwumFixTableVersionForOldFirmware(tKFWUM_InFirmwareInfo * pInfo);
-
-static tKFWUM_Status KfwumGetTraceLog(struct ipmi_intf * intf);
-
-tKFWUM_Status KfwumValidFirmwareForBoard(tKFWUM_BoardInfo boardInfo,
-                                                tKFWUM_InFirmwareInfo firmInfo);
-static void KfwumOutputInfo(tKFWUM_BoardInfo boardInfo,
-                                                tKFWUM_InFirmwareInfo firmInfo);
-
-
-/* ipmi_fwum_main  -  entry point for this ipmitool mode
- *
- * @intf:	  ipmi interface
- * @arc     : number of arguments
- * @argv    : point to argument array
- *
- * returns 0 on success
- * returns -1 on error
- */
-int ipmi_fwum_main(struct ipmi_intf * intf, int argc, char ** argv)
-{
-   printf("FWUM extension Version %d.%d\n", VERSION_MAJ, VERSION_MIN);
-   if ((!argc) || ( !strncmp(argv[0], "help", 4)))
-   {
-         KfwumOutputHelp();
-   }
-   else
-   {
-      if (!strncmp(argv[0], "info", 4))
-      {
-         KfwumMain(intf, KFWUM_TASK_INFO);
-      }
-      else if (!strncmp(argv[0], "status", 6))
-      {
-         KfwumMain(intf, KFWUM_TASK_STATUS);
-      }
-      else if (!strncmp(argv[0], "rollback", 8))
-      {
-         KfwumMain(intf, KFWUM_TASK_ROLLBACK);
-      }
-      else if (!strncmp(argv[0], "download", 8))
-      {
-         if((argc >= 2) && (strlen(argv[1]) > 0))
-         {
-            /* There is a file name in the parameters */
-            if(strlen(argv[1]) < 512)
-            {
-               strcpy((char *)fileName, argv[1]);
-               printf("Firmware File Name         : %s\n", fileName);
-
-               KfwumMain(intf, KFWUM_TASK_DOWNLOAD);
-            }
-            else
-            {
-               fprintf(stderr,"File name must be smaller than 512 bytes\n");
-            }
-         }
-         else
-         {
-            fprintf(stderr,"A path and a file name must be specified\n");
-         }
-      }
-      else if (!strncmp(argv[0], "upgrade", 7))
-      {
-         if((argc >= 2) && (strlen(argv[1]) > 0))
-         {
-            /* There is a file name in the parameters */
-            if(strlen(argv[1]) < 512)
-            {
-               strcpy((char *)fileName, argv[1]);
-               printf("Upgrading using file name %s\n", fileName);
-               KfwumMain(intf, KFWUM_TASK_UPGRADE);
-            }
-            else
-            {
-               fprintf(stderr,"File name must be smaller than 512 bytes\n");
-            }
-         }
-         else
-         {
-            KfwumMain(intf, KFWUM_TASK_START_UPGRADE);
-         }
-
-      }
-      else if (!strncmp(argv[0], "tracelog", 8))
-      {
-         KfwumMain(intf, KFWUM_TASK_TRACELOG);
-      }
-      else
-      {
-         printf("Invalid KFWUM command: %s\n", argv[0]);
-      }
-   }
-   return 0;
-}
-
-
-static void KfwumOutputHelp(void)
-{
-   printf("KFWUM Commands:  info status download upgrade rollback tracelog\n");
-}
-
-
-/****************************************/
-/**  private definitions and macros    **/
-/****************************************/
-typedef enum eFWUM_CmdId
-{
-   KFWUM_CMD_ID_GET_FIRMWARE_INFO                         = 0,
-   KFWUM_CMD_ID_KICK_IPMC_WATCHDOG                        = 1,
-   KFWUM_CMD_ID_GET_LAST_ANSWER                           = 2,
-   KFWUM_CMD_ID_BOOT_HANDSHAKE                            = 3,
-   KFWUM_CMD_ID_REPORT_STATUS                             = 4,
-   KFWUM_CMD_ID_GET_FIRMWARE_STATUS                       = 7,
-   KFWUM_CMD_ID_START_FIRMWARE_UPDATE                     = 9,
-   KFWUM_CMD_ID_START_FIRMWARE_IMAGE                      = 0x0a,
-   KFWUM_CMD_ID_SAVE_FIRMWARE_IMAGE                       = 0x0b,
-   KFWUM_CMD_ID_FINISH_FIRMWARE_IMAGE                     = 0x0c,
-   KFWUM_CMD_ID_READ_FIRMWARE_IMAGE                       = 0x0d,
-   KFWUM_CMD_ID_MANUAL_ROLLBACK                           = 0x0e,
-   KFWUM_CMD_ID_GET_TRACE_LOG                             = 0x0f,
-   KFWUM_CMD_ID_STD_MAX_CMD,
-   KFWUM_CMD_ID_EXTENDED_CMD                              = 0xC0
-}  tKFWUM_CmdId;
-
-
-
-/****************************************/
-/** global/static variables definition **/
-/****************************************/
-
-/****************************************/
-/**        functions definition        **/
-/****************************************/
-
-/*******************************************************************************
-*
-* Function Name:  KfwumMain
-*
-* Description:    This function implements the upload of the firware data
-*                 received as parameters.
-*
-* Restriction:    Called only from main
-*
-* Input:  unsigned char * pBuffer[] : The buffers
-*         unsigned long bufSize    : The size of the buffers
-*
-* Output: None
-*
-* Global: none
-*
-* Return: tIFWU_Status (success or failure)
-*
-*******************************************************************************/
-static void KfwumMain(struct ipmi_intf * intf, tKFWUM_Task task)
-{
-   tKFWUM_Status status = KFWUM_STATUS_OK;
-   tKFWUM_BoardInfo boardInfo;
-   tKFWUM_InFirmwareInfo firmInfo = { 0 };
-   unsigned long fileSize = 0;
-   static unsigned short padding;
-
-   if((status == KFWUM_STATUS_OK) && (task == KFWUM_TASK_INFO))
-   {
-      unsigned char notUsed;
-      if(verbose)
-      {
-         printf("Getting Kontron FWUM Info\n");
-      }
-      KfwumGetDeviceInfo(intf, 1, &boardInfo);
-      KfwumGetInfo(intf, 1, &notUsed);
-
-   }
-
-
-   if((status == KFWUM_STATUS_OK) && (task == KFWUM_TASK_STATUS))
-   {
-      if(verbose)
-      {
-         printf("Getting Kontron FWUM Status\n");
-      }
-      KfwumGetStatus(intf);
-   }
-
-   if( (status == KFWUM_STATUS_OK) && (task == KFWUM_TASK_ROLLBACK) )
-   {
-      status = KfwumManualRollback(intf);      
-   }
-
-   if(
-      (status == KFWUM_STATUS_OK) &&
-      (
-         (task == KFWUM_TASK_UPGRADE) || (task == KFWUM_TASK_DOWNLOAD)
-      )
-     )
-   {
-      status = KfwumGetFileSize(fileName, &fileSize);
-      if(status == KFWUM_STATUS_OK)
-      {
-         status = KfwumSetupBuffersFromFile(fileName, fileSize);
-         if(status == KFWUM_STATUS_OK)
-         {
-            padding = KfwumCalculateChecksumPadding(firmBuf, fileSize);
-         }
-      }
-      if(status == KFWUM_STATUS_OK)
-      {
-         status = KfwumGetInfoFromFirmware(firmBuf, fileSize, &firmInfo);
-      }
-      if(status == KFWUM_STATUS_OK)
-      {
-         status = KfwumGetDeviceInfo(intf, 0, &boardInfo);
-      }
-
-      if(status == KFWUM_STATUS_OK)
-      {
-         status = KfwumValidFirmwareForBoard(boardInfo,firmInfo);
-      }
-      
-      if (status == KFWUM_STATUS_OK)
-      {
-      	unsigned char notUsed;
-      	KfwumGetInfo(intf, 0, &notUsed);
-      }
-
-      KfwumOutputInfo(boardInfo,firmInfo);
-   }
-
-   if(
-      (status == KFWUM_STATUS_OK) &&
-      (
-         (task == KFWUM_TASK_UPGRADE) || (task == KFWUM_TASK_DOWNLOAD)
-      )
-     )
-   {
-      status = KfwumStartFirmwareImage(intf, fileSize, padding);
-   }
-
-
-   if(
-      (status == KFWUM_STATUS_OK) &&
-      (
-         (task == KFWUM_TASK_UPGRADE) || (task == KFWUM_TASK_DOWNLOAD)
-      )
-     )
-   {
-      status = KfwumUploadFirmware(intf, firmBuf, fileSize);
-   }
-
-   if(
-      (status == KFWUM_STATUS_OK) &&
-      (
-         (task == KFWUM_TASK_UPGRADE) || (task == KFWUM_TASK_DOWNLOAD)
-      )
-     )
-   {
-      status = KfwumFinishFirmwareImage(intf, firmInfo);
-   }
-
-   if(
-      (status == KFWUM_STATUS_OK) &&
-      (
-         (task == KFWUM_TASK_UPGRADE) || (task == KFWUM_TASK_DOWNLOAD)
-      )
-     )
-   {
-      status = KfwumGetStatus(intf);
-   }
-
-   if(
-      (status == KFWUM_STATUS_OK) &&
-      (
-         (task == KFWUM_TASK_UPGRADE) || (task == KFWUM_TASK_START_UPGRADE)
-      )
-     )
-   {
-      status = KfwumStartFirmwareUpgrade(intf);
-   }
-   
-   if((status == KFWUM_STATUS_OK) && (task == KFWUM_TASK_TRACELOG))
-   {
-      status = KfwumGetTraceLog(intf);
-   }
-
-
-}
-
-/* KfwumGetFileSize  -  gets the file size
- *
- * @pFileName : filename ptr
- * @pFileSize : output ptr for filesize
- *
- * returns KFWUM_STATUS_OK or KFWUM_STATUS_ERROR
- */
-static tKFWUM_Status KfwumGetFileSize(unsigned char * pFileName,
-                                                     unsigned long * pFileSize)
-{
-   tKFWUM_Status status = KFWUM_STATUS_ERROR;
-   FILE * pFileHandle;
-
-   pFileHandle = fopen((const char *)pFileName, "rb");
-
-   if(pFileHandle)
-   {
-      if(fseek(pFileHandle, 0L , SEEK_END) == (unsigned int) NULL)
-      {
-         *pFileSize     =    ftell(pFileHandle);
-
-         if( *pFileSize != 0)
-         {
-            status = KFWUM_STATUS_OK;
-         }
-      }
-      fclose(pFileHandle);
-   }
-
-   return(status);
-}
-
-/* KfwumSetupBuffersFromFile  -  small buffers are used to store the file data
- *
- * @pFileName : filename ptr
- * unsigned long : filesize
- *
- * returns KFWUM_STATUS_OK or KFWUM_STATUS_ERROR
- */
-#define MAX_BUFFER_SIZE          1024*16
-static tKFWUM_Status KfwumSetupBuffersFromFile(unsigned char * pFileName,
-                                                        unsigned long fileSize)
-{
-   tKFWUM_Status status = KFWUM_STATUS_OK;
-   FILE * pFileHandle;
-
-   pFileHandle = fopen((const char *)pFileName, "rb");
-
-   if(pFileHandle)
-   {
-      int count   = fileSize / MAX_BUFFER_SIZE;
-      int modulus = fileSize % MAX_BUFFER_SIZE;
-      int qty     =0;
-
-      rewind(pFileHandle);
-
-      for(qty=0;qty<count;qty++)
-      {
-         KfwumShowProgress((const unsigned char *)"Reading Firmware from File", qty, count );
-         if(fread(&firmBuf[qty*MAX_BUFFER_SIZE], 1, MAX_BUFFER_SIZE ,pFileHandle)
-            ==  MAX_BUFFER_SIZE)
-         {
-            status = KFWUM_STATUS_OK;
-         }
-      }
-      if( modulus )
-      {
-         if(fread(&firmBuf[qty*MAX_BUFFER_SIZE], 1, modulus, pFileHandle) == modulus)
-         {
-            status = KFWUM_STATUS_OK;
-         }
-      }
-      if(status == KFWUM_STATUS_OK)
-      {
-         KfwumShowProgress((const unsigned char *)"Reading Firmware from File", 100, 100);
-      }
-   }
-   return(status);
-}
-
-/* KfwumShowProgress  -  helper routine to display progress bar
- *
- * Converts current/total in percent
- * 
- * *task  : string identifying current operation
- * current: progress
- * total  : limit 
- */
-#define PROG_LENGTH 42
-void KfwumShowProgress( const unsigned char * task,  unsigned long current ,
-                                                           unsigned long total)
-{
-   static unsigned long staticProgress=0xffffffff;
-
-   unsigned char spaces[PROG_LENGTH + 1];
-   unsigned short hash;
-   float  percent = ((float)current/total);
-   unsigned long progress =  100*(percent);
-
-   if(staticProgress == progress)
-   {
-      /* We displayed the same last time.. so don't do it */
-   }
-   else
-   {
-      staticProgress = progress;
-
-
-      printf("%-25s : ",task);    /* total 20 bytes */
-
-      hash = ( percent * PROG_LENGTH );
-      memset(spaces,'#', hash);
-      spaces[ hash ] = '\0';
-      printf("%s", spaces );
-
-      memset(spaces,' ',( PROG_LENGTH - hash ) );
-      spaces[ ( PROG_LENGTH - hash ) ] = '\0';
-      printf("%s", spaces );
-
-
-      printf(" %3ld %%\r",progress); /* total 7 bytes */
-
-      if( progress == 100 )
-      {
-         printf("\n");
-      }
-      fflush(stdout);
-   }
-}
-
-/* KfwumCalculateChecksumPadding
- *
- * TBD
- * 
- */
-static unsigned short KfwumCalculateChecksumPadding(unsigned char * pBuffer,
-                                                       unsigned long totalSize)
-{
-   unsigned short sumOfBytes = 0;
-   unsigned short padding;
-   unsigned long  counter;
-
-   for(counter = 0; counter < totalSize; counter ++ )
-   {
-      sumOfBytes += pBuffer[counter];
-   }
-
-   padding = 0 - sumOfBytes;
-   return padding;
-}
-
-/******************************************************************************
-******************************* COMMANDS **************************************
-******************************************************************************/
-#ifdef PRAGMA_PACK
-#pramga pack(1)
-#endif
-struct KfwumGetInfoResp {
-   unsigned char protocolRevision;
-   unsigned char controllerDeviceId;
-   struct 
-   {
-      unsigned char mode:1;
-      unsigned char seqAdd:1;
-      unsigned char res : 6;
-   } byte;
-   unsigned char firmRev1;
-   unsigned char firmRev2;
-   unsigned char numBank;
-} ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
-#endif
-
-
-
-/* KfwumGetInfo  -  Get Firmware Update Manager (FWUM) information
- * 
- * * intf  : IPMI interface 
- * output  : when set to non zero, queried information is displayed
- * pNumBank: output ptr for number of banks
- */
-static tKFWUM_Status KfwumGetInfo(struct ipmi_intf * intf, unsigned char output,
-                                                       unsigned char *pNumBank)
-{
-   tKFWUM_Status status = KFWUM_STATUS_OK;
-   static struct KfwumGetInfoResp *pGetInfo;
-   struct ipmi_rs * rsp;
-   struct ipmi_rq req;
-
-   memset(&req, 0, sizeof(req));
-   req.msg.netfn = IPMI_NETFN_FIRMWARE;
-   req.msg.cmd = KFWUM_CMD_ID_GET_FIRMWARE_INFO;
-   req.msg.data_len = 0;
-
-   rsp = intf->sendrecv(intf, &req);
-
-   if (!rsp)
-   {
-      printf("Error in FWUM Firmware Get Info Command\n");
-      status = KFWUM_STATUS_ERROR;
-   }
-   else if (rsp->ccode)
-   {
-      printf("FWUM Firmware Get Info returned %x\n", rsp->ccode);
-      status = KFWUM_STATUS_ERROR;
-   }
-
-   if(status == KFWUM_STATUS_OK)
-   {
-      pGetInfo = (struct KfwumGetInfoResp *) rsp->data;
-      if(output)
-      {
-         printf("\nFWUM info\n");
-         printf("=========\n");
-         printf("Protocol Revision         : %02Xh\n",
-                                                    pGetInfo->protocolRevision);
-         printf("Controller Device Id      : %02Xh\n",
-                                                  pGetInfo->controllerDeviceId);
-         printf("Firmware Revision         : %u.%u%u",
-                                 pGetInfo->firmRev1, pGetInfo->firmRev2 >> 4,
-                                                     pGetInfo->firmRev2 & 0x0f);
-         if(pGetInfo->byte.mode != 0)
-         {
-            printf(" - DEBUG BUILD\n");
-         }
-         else
-         {
-            printf("\n");
-         }
-         printf("Number Of Memory Bank     : %u\n",pGetInfo->numBank);
-      }
-      * pNumBank = pGetInfo->numBank;
-      
-      /* Determine wich type of download to use: */
-      /* Old FWUM or Old IPMC fw (data_len < 7) -->
-          Address with small buffer size */
-      if ( (pGetInfo->protocolRevision) <= 0x05 || (rsp->data_len < 7 ) )
-      {
-      	saveFirmwareInfo.downloadType = KFWUM_DOWNLOAD_TYPE_ADDRESS;
-         saveFirmwareInfo.bufferSize   = KFWUM_SMALL_BUFFER;
-         saveFirmwareInfo.overheadSize = KFWUM_OLD_CMD_OVERHEAD;
-
-         if(verbose)
-         {
-            printf("Protocol Revision          :");
-            printf(" <= 5 detected, adjusting buffers\n");
-         }
-      }
-      else /* Both fw are using the new protocol */
-      {
-      	saveFirmwareInfo.downloadType = KFWUM_DOWNLOAD_TYPE_SEQUENCE;
-         saveFirmwareInfo.overheadSize = KFWUM_NEW_CMD_OVERHEAD;
-         /* Buffer size depending on access type (Local or remote) */
-         /* Look if we run remote or locally */
-
-         if(verbose)
-         {
-            printf("Protocol Revision          :");
-            printf(" > 5 optimizing buffers\n");
-         }
-
-         if(strstr(intf->name,"lan")!= NULL) /* also covers lanplus */
-         {
-            saveFirmwareInfo.bufferSize = KFWUM_SMALL_BUFFER;
-            if(verbose)
-            {
-               printf("IOL payload size           : %d\r\n"  ,
-                                                  saveFirmwareInfo.bufferSize);
-            }
-         }
-         else if
-         (
-           (strstr(intf->name,"open")!= NULL)
-           &&
-           intf->target_addr != IPMI_BMC_SLAVE_ADDR 
-           &&
-           (
-              intf->target_addr !=  intf->my_addr
-           )
-         )
-         {
-            saveFirmwareInfo.bufferSize = KFWUM_SMALL_BUFFER;
-            if(verbose)
-            {
-               printf("IPMB payload size          : %d\r\n"  , 
-                                                   saveFirmwareInfo.bufferSize);
-            }
-         }
-         else
-         {
-         	saveFirmwareInfo.bufferSize = KFWUM_BIG_BUFFER;
-            if(verbose)
-            {
-               printf("SMI payload size           : %d\r\n", 
-                                                  saveFirmwareInfo.bufferSize);
-            }
-         }
-      }
-   }
-   return status;
-}
-
-/* KfwumGetDeviceInfo  -  Get IPMC/Board information
- * 
- * * intf  : IPMI interface 
- * output  : when set to non zero, queried information is displayed
- * tKFWUM_BoardInfo: output ptr for IPMC/Board information
- */
-static tKFWUM_Status KfwumGetDeviceInfo(struct ipmi_intf * intf,
-                            unsigned char output, tKFWUM_BoardInfo * pBoardInfo)
-{
-   struct ipm_devid_rsp   *pGetDevId;
-   tKFWUM_Status status = KFWUM_STATUS_OK;
-   struct ipmi_rs * rsp;
-   struct ipmi_rq req;
-
-   /* Send Get Device Id */
-   if(status == KFWUM_STATUS_OK)
-   {
-      memset(&req, 0, sizeof(req));
-      req.msg.netfn = IPMI_NETFN_APP;
-      req.msg.cmd = BMC_GET_DEVICE_ID;
-      req.msg.data_len = 0;
-
-      rsp = intf->sendrecv(intf, &req);
-      if (!rsp)
-      {
-         printf("Error in Get Device Id Command\n");
-         status = KFWUM_STATUS_ERROR;
-      }
-      else if (rsp->ccode)
-      {
-         printf("Get Device Id returned %x\n", rsp->ccode);
-         status = KFWUM_STATUS_ERROR;
-      }
-   }
-
-   if(status == KFWUM_STATUS_OK)
-   {
-      pGetDevId = (struct ipm_devid_rsp *) rsp->data;
-      pBoardInfo->iana = IPM_DEV_MANUFACTURER_ID(pGetDevId->manufacturer_id);
-      pBoardInfo->boardId = buf2short(pGetDevId->product_id);
-      if(output)
-      {
-         printf("\nIPMC Info\n");
-         printf("=========\n");
-         printf("Manufacturer Id           : %u\n",pBoardInfo->iana);
-         printf("Board Id                  : %u\n",pBoardInfo->boardId);
-         printf("Firmware Revision         : %u.%u%u",
-                                 pGetDevId->fw_rev1, pGetDevId->fw_rev2 >> 4,
-                                                   pGetDevId->fw_rev2 & 0x0f);
-         if(
-            ( 
-               ( pBoardInfo->iana == KFWUM_IANA_KONTRON)
-               && 
-               (pBoardInfo->boardId = KFWUM_BOARD_KONTRON_5002)
-            )
-           )
-         {
-            printf(" SDR %u\n", pGetDevId->aux_fw_rev[0]);
-         }
-         else
-         {
-            printf("\n");
-         }
-      }
-   }
-
-   return status;
-}
-
-
-#ifdef PRAGMA_PACK
-#pramga pack(1)
-#endif
-struct KfwumGetStatusResp {
-   unsigned char bankState;
-   unsigned char firmLengthLSB;
-   unsigned char firmLengthMid;
-   unsigned char firmLengthMSB;
-   unsigned char firmRev1;
-   unsigned char firmRev2;
-   unsigned char firmRev3;
-} ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
-#endif
- 
-
-const struct valstr bankStateValS[] = {
-   { 0x00, "Not programmed" },
-   { 0x01, "New firmware" },
-   { 0x02, "Wait for validation" },
-   { 0x03, "Last Known Good" },
-   { 0x04, "Previous Good" }
-};
-
-/* KfwumGetStatus  -  Get (and prints) FWUM  banks information
- * 
- * * intf  : IPMI interface 
- */
-static tKFWUM_Status KfwumGetStatus(struct ipmi_intf * intf)
-{
-   tKFWUM_Status status = KFWUM_STATUS_OK;
-   struct ipmi_rs * rsp;
-   struct ipmi_rq req;
-   struct KfwumGetStatusResp *pGetStatus;
-   unsigned char numBank;
-   unsigned char counter;
-
-   if(verbose)
-   {
-      printf(" Getting Status!\n");
-   }
-
-   /* Retreive the number of bank */
-   status = KfwumGetInfo(intf, 0, &numBank);
-
-   for(
-         counter = 0;
-         (counter < numBank) && (status == KFWUM_STATUS_OK);
-         counter ++
-      )
-   {
-      /* Retreive the status of each bank */
-      memset(&req, 0, sizeof(req));
-      req.msg.netfn = IPMI_NETFN_FIRMWARE;
-      req.msg.cmd = KFWUM_CMD_ID_GET_FIRMWARE_STATUS;
-      req.msg.data = &counter;
-      req.msg.data_len = 1;
-
-      rsp = intf->sendrecv(intf, &req);
-
-      if (!rsp)
-      {
-         printf("Error in FWUM Firmware Get Status Command\n");
-         status = KFWUM_STATUS_ERROR;
-      }
-      else if (rsp->ccode)
-      {
-         printf("FWUM Firmware Get Status returned %x\n", rsp->ccode);
-         status = KFWUM_STATUS_ERROR;
-      }
-
-
-      if(status == KFWUM_STATUS_OK)
-      {
-         pGetStatus = (struct KfwumGetStatusResp *) rsp->data;
-         printf("\nBank State %d               : %s\n", counter, val2str(
-                                         pGetStatus->bankState, bankStateValS));
-         if(pGetStatus->bankState)
-         {
-            unsigned long firmLength;
-            firmLength  = pGetStatus->firmLengthMSB;
-            firmLength  = firmLength << 8;
-            firmLength |= pGetStatus->firmLengthMid;
-            firmLength  = firmLength << 8;
-            firmLength |= pGetStatus->firmLengthLSB;
-
-            printf("Firmware Length            : %ld bytes\n", firmLength);
-            printf("Firmware Revision          : %u.%u%u SDR %u\n",
-                              pGetStatus->firmRev1,  pGetStatus->firmRev2 >> 4,
-                           pGetStatus->firmRev2 & 0x0f, pGetStatus->firmRev3);
-         }
-      }
-   }
-   printf("\n");
-   return status;
-}
-
-#ifdef PRAGMA_PACK
-#pramga pack(1)
-#endif
-struct KfwumManualRollbackReq{
-   unsigned char type;
-} ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
-#endif
-
-
-/* KfwumManualRollback  -  Ask IPMC to rollback to previous version
- * 
- * * intf  : IPMI interface 
- */
-static tKFWUM_Status KfwumManualRollback(struct ipmi_intf * intf)
-{
-  tKFWUM_Status status = KFWUM_STATUS_OK;
-   struct ipmi_rs * rsp;
-   struct ipmi_rq req;
-   struct KfwumManualRollbackReq thisReq;
-
-
-   memset(&req, 0, sizeof(req));
-   req.msg.netfn = IPMI_NETFN_FIRMWARE;
-   req.msg.cmd = KFWUM_CMD_ID_MANUAL_ROLLBACK;
-
-   thisReq.type = 0;  /* Wait BMC shutdown */
-
-   req.msg.data = (unsigned char *) &thisReq;
-   req.msg.data_len = 1;
-
-   rsp = intf->sendrecv(intf, &req);
-
-   if (!rsp)
-   {
-      printf("Error in FWUM Manual Rollback Command\n");
-      status = KFWUM_STATUS_ERROR;
-   }
-   else if (rsp->ccode)
-   {
-      printf("Error in FWUM Manual Rollback Command returned %x\n",
-                                                                    rsp->ccode);
-      status = KFWUM_STATUS_ERROR;
-   }
-
-   if(status == KFWUM_STATUS_OK)
-   {
-      printf("FWUM Starting Manual Rollback \n");
-   }
-   return status;
-}
-
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+/*
+ * Copyright (c) 2004 Kontron Canada, Inc.  All Rights Reserved.
+ *
+ * Base on code from
+ * Copyright (c) 2003 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * Redistribution of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *
+ * Redistribution in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * Neither the name of Sun Microsystems, Inc. or the names of
+ * contributors may be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+  * This software is provided "AS IS," without a warranty of any kind.
+ * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES,
+ * INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A
+ * PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY EXCLUDED.
+ * SUN MICROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL NOT BE LIABLE
+ * FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING
+ * OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.  IN NO EVENT WILL
+ * SUN OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA,
+ * OR FOR DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR
+ * PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF
+ * LIABILITY, ARISING OUT OF THE USE OF OR INABILITY TO USE THIS SOFTWARE,
+ * EVEN IF SUN HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+ */
+
+
+#include <string.h>
+#include <math.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <ipmitool/helper.h>
+#include <ipmitool/ipmi.h>
+#include <ipmitool/ipmi_fwum.h>
+#include <ipmitool/ipmi_intf.h>
+#include <ipmitool/ipmi_mc.h>
+
+/******************************************************************************
+* HISTORY
+* ===========================================================================
+* 2007-01-11 [FI]
+*  - Incremented to version 1.3
+*  - Added lan packet size reduction mechanism to workaround fact
+*    that lan iface will not return C7 on excessive length
+*
+*****************************************************************************/
+
+#define VERSION_MAJ        1
+#define VERSION_MIN        3
+
+
+typedef enum eKFWUM_Task
+{
+   KFWUM_TASK_INFO,
+   KFWUM_TASK_STATUS,
+   KFWUM_TASK_DOWNLOAD,
+   KFWUM_TASK_UPGRADE,
+   KFWUM_TASK_START_UPGRADE,
+   KFWUM_TASK_ROLLBACK,
+   KFWUM_TASK_TRACELOG
+}tKFWUM_Task;
+
+typedef enum eKFWUM_BoardList
+{
+   KFWUM_BOARD_KONTRON_UNKNOWN   = 0,
+   KFWUM_BOARD_KONTRON_5002      = 5002,
+}tKFWUM_BoardList;
+
+typedef enum eKFWUM_IanaList
+{
+   KFWUM_IANA_KONTRON            = 15000,
+}tKFWUM_IanaList;
+
+typedef struct sKFWUM_BoardInfo
+{
+   tKFWUM_BoardList boardId;
+   tKFWUM_IanaList  iana;
+}tKFWUM_BoardInfo;
+
+typedef enum eKFWUM_Status
+{
+   KFWUM_STATUS_OK,
+   KFWUM_STATUS_ERROR
+}tKFWUM_Status;
+
+typedef enum eKFWUM_DownloadType
+{
+   KFWUM_DOWNLOAD_TYPE_ADDRESS = 0,
+	KFWUM_DOWNLOAD_TYPE_SEQUENCE,
+}tKFWUM_DownloadType;
+
+typedef enum eKFWUM_DownloadBuffferType
+{
+   KFWUM_SMALL_BUFFER_TYPE = 0,
+	KFUMW_BIG_BUFFER_TYPE
+}tKFWUM_DownloadBuffferType;
+
+typedef struct sKFWUM_InFirmwareInfo
+{
+   unsigned long   fileSize;
+   unsigned short  checksum;
+   unsigned short  sumToRemoveFromChecksum;
+                                  /* Since the checksum is added in the bin
+                                  after the checksum is calculated, we
+                                  need to remove the each byte value.  This
+                                  byte will contain the addition of both bytes*/
+   tKFWUM_BoardList boardId;
+   unsigned char   deviceId;
+   unsigned char   tableVers;
+   unsigned char   implRev;
+   unsigned char   versMajor;
+   unsigned char   versMinor;
+   unsigned char   versSubMinor;
+   unsigned char   sdrRev;
+   tKFWUM_IanaList iana;
+}tKFWUM_InFirmwareInfo;
+
+typedef struct sKFWUM_SaveFirmwareInfo
+{
+	tKFWUM_DownloadType downloadType;
+   unsigned char       bufferSize;
+   unsigned char       overheadSize;	
+}tKFWUM_SaveFirmwareInfo;	
+  
+#define KFWUM_SMALL_BUFFER     32 /* Minimum size (IPMB/IOL/old protocol) */
+#define KFWUM_BIG_BUFFER       32 /* Maximum size on KCS interface        */
+
+#define KFWUM_OLD_CMD_OVERHEAD 6  /*3 address + 1 size + 1 checksum + 1 command*/
+#define KFWUM_NEW_CMD_OVERHEAD 4  /*1 sequence+ 1 size + 1 checksum + 1 command*/
+#define KFWUM_PAGE_SIZE        256
+
+extern int verbose;
+static unsigned char fileName[512];
+static unsigned char firmBuf[1024*512];
+static tKFWUM_SaveFirmwareInfo saveFirmwareInfo;
+
+static void KfwumOutputHelp(void);
+static void KfwumMain(struct ipmi_intf * intf, tKFWUM_Task task);
+static tKFWUM_Status KfwumGetFileSize(unsigned char * pFileName,
+                                                     unsigned long * pFileSize);
+static tKFWUM_Status KfwumSetupBuffersFromFile(unsigned char * pFileName,
+                                                        unsigned long fileSize);
+static void KfwumShowProgress( const unsigned char * task,
+                                    unsigned long current, unsigned long total);
+static unsigned short KfwumCalculateChecksumPadding(unsigned char * pBuffer,
+                                                       unsigned long totalSize);
+
+
+static tKFWUM_Status KfwumGetInfo(struct ipmi_intf * intf, unsigned char output,
+                                                       unsigned char *pNumBank);
+static tKFWUM_Status KfwumGetDeviceInfo(struct ipmi_intf * intf,
+                           unsigned char output, tKFWUM_BoardInfo * pBoardInfo);
+static tKFWUM_Status KfwumGetStatus(struct ipmi_intf * intf);
+static tKFWUM_Status KfwumManualRollback(struct ipmi_intf * intf);
+static tKFWUM_Status KfwumStartFirmwareImage(struct ipmi_intf * intf,
+                                   unsigned long length,unsigned short padding);
+static tKFWUM_Status KfwumSaveFirmwareImage(struct ipmi_intf * intf,
+     unsigned char sequenceNumber, unsigned long address, 
+     unsigned char *pFirmBuf, unsigned char * pInBufLength);
+static tKFWUM_Status KfwumFinishFirmwareImage(struct ipmi_intf * intf,
+                                                tKFWUM_InFirmwareInfo firmInfo);
+static tKFWUM_Status KfwumUploadFirmware(struct ipmi_intf * intf,
+                              unsigned char * pBuffer, unsigned long totalSize);
+static tKFWUM_Status KfwumStartFirmwareUpgrade(struct ipmi_intf * intf);
+
+static tKFWUM_Status KfwumGetInfoFromFirmware(unsigned char * pBuf,
+                         unsigned long bufSize, tKFWUM_InFirmwareInfo * pInfo);
+static void KfwumFixTableVersionForOldFirmware(tKFWUM_InFirmwareInfo * pInfo);
+
+static tKFWUM_Status KfwumGetTraceLog(struct ipmi_intf * intf);
+
+tKFWUM_Status KfwumValidFirmwareForBoard(tKFWUM_BoardInfo boardInfo,
+                                                tKFWUM_InFirmwareInfo firmInfo);
+static void KfwumOutputInfo(tKFWUM_BoardInfo boardInfo,
+                                                tKFWUM_InFirmwareInfo firmInfo);
+
+
+/* ipmi_fwum_main  -  entry point for this ipmitool mode
+ *
+ * @intf:	  ipmi interface
+ * @arc     : number of arguments
+ * @argv    : point to argument array
+ *
+ * returns 0 on success
+ * returns -1 on error
+ */
+int ipmi_fwum_main(struct ipmi_intf * intf, int argc, char ** argv)
+{
+   printf("FWUM extension Version %d.%d\n", VERSION_MAJ, VERSION_MIN);
+   if ((!argc) || ( !strncmp(argv[0], "help", 4)))
+   {
+         KfwumOutputHelp();
+   }
+   else
+   {
+      if (!strncmp(argv[0], "info", 4))
+      {
+         KfwumMain(intf, KFWUM_TASK_INFO);
+      }
+      else if (!strncmp(argv[0], "status", 6))
+      {
+         KfwumMain(intf, KFWUM_TASK_STATUS);
+      }
+      else if (!strncmp(argv[0], "rollback", 8))
+      {
+         KfwumMain(intf, KFWUM_TASK_ROLLBACK);
+      }
+      else if (!strncmp(argv[0], "download", 8))
+      {
+         if((argc >= 2) && (strlen(argv[1]) > 0))
+         {
+            /* There is a file name in the parameters */
+            if(strlen(argv[1]) < 512)
+            {
+               strcpy((char *)fileName, argv[1]);
+               printf("Firmware File Name         : %s\n", fileName);
+
+               KfwumMain(intf, KFWUM_TASK_DOWNLOAD);
+            }
+            else
+            {
+               fprintf(stderr,"File name must be smaller than 512 bytes\n");
+            }
+         }
+         else
+         {
+            fprintf(stderr,"A path and a file name must be specified\n");
+         }
+      }
+      else if (!strncmp(argv[0], "upgrade", 7))
+      {
+         if((argc >= 2) && (strlen(argv[1]) > 0))
+         {
+            /* There is a file name in the parameters */
+            if(strlen(argv[1]) < 512)
+            {
+               strcpy((char *)fileName, argv[1]);
+               printf("Upgrading using file name %s\n", fileName);
+               KfwumMain(intf, KFWUM_TASK_UPGRADE);
+            }
+            else
+            {
+               fprintf(stderr,"File name must be smaller than 512 bytes\n");
+            }
+         }
+         else
+         {
+            KfwumMain(intf, KFWUM_TASK_START_UPGRADE);
+         }
+
+      }
+      else if (!strncmp(argv[0], "tracelog", 8))
+      {
+         KfwumMain(intf, KFWUM_TASK_TRACELOG);
+      }
+      else
+      {
+         printf("Invalid KFWUM command: %s\n", argv[0]);
+      }
+   }
+   return 0;
+}
+
+
+static void KfwumOutputHelp(void)
+{
+   printf("KFWUM Commands:  info status download upgrade rollback tracelog\n");
+}
+
+
+/****************************************/
+/**  private definitions and macros    **/
+/****************************************/
+typedef enum eFWUM_CmdId
+{
+   KFWUM_CMD_ID_GET_FIRMWARE_INFO                         = 0,
+   KFWUM_CMD_ID_KICK_IPMC_WATCHDOG                        = 1,
+   KFWUM_CMD_ID_GET_LAST_ANSWER                           = 2,
+   KFWUM_CMD_ID_BOOT_HANDSHAKE                            = 3,
+   KFWUM_CMD_ID_REPORT_STATUS                             = 4,
+   KFWUM_CMD_ID_GET_FIRMWARE_STATUS                       = 7,
+   KFWUM_CMD_ID_START_FIRMWARE_UPDATE                     = 9,
+   KFWUM_CMD_ID_START_FIRMWARE_IMAGE                      = 0x0a,
+   KFWUM_CMD_ID_SAVE_FIRMWARE_IMAGE                       = 0x0b,
+   KFWUM_CMD_ID_FINISH_FIRMWARE_IMAGE                     = 0x0c,
+   KFWUM_CMD_ID_READ_FIRMWARE_IMAGE                       = 0x0d,
+   KFWUM_CMD_ID_MANUAL_ROLLBACK                           = 0x0e,
+   KFWUM_CMD_ID_GET_TRACE_LOG                             = 0x0f,
+   KFWUM_CMD_ID_STD_MAX_CMD,
+   KFWUM_CMD_ID_EXTENDED_CMD                              = 0xC0
+}  tKFWUM_CmdId;
+
+
+
+/****************************************/
+/** global/static variables definition **/
+/****************************************/
+
+/****************************************/
+/**        functions definition        **/
+/****************************************/
+
+/*******************************************************************************
+*
+* Function Name:  KfwumMain
+*
+* Description:    This function implements the upload of the firware data
+*                 received as parameters.
+*
+* Restriction:    Called only from main
+*
+* Input:  unsigned char * pBuffer[] : The buffers
+*         unsigned long bufSize    : The size of the buffers
+*
+* Output: None
+*
+* Global: none
+*
+* Return: tIFWU_Status (success or failure)
+*
+*******************************************************************************/
+static void KfwumMain(struct ipmi_intf * intf, tKFWUM_Task task)
+{
+   tKFWUM_Status status = KFWUM_STATUS_OK;
+   tKFWUM_BoardInfo boardInfo;
+   tKFWUM_InFirmwareInfo firmInfo = { 0 };
+   unsigned long fileSize = 0;
+   static unsigned short padding;
+
+   if((status == KFWUM_STATUS_OK) && (task == KFWUM_TASK_INFO))
+   {
+      unsigned char notUsed;
+      if(verbose)
+      {
+         printf("Getting Kontron FWUM Info\n");
+      }
+      KfwumGetDeviceInfo(intf, 1, &boardInfo);
+      KfwumGetInfo(intf, 1, &notUsed);
+
+   }
+
+
+   if((status == KFWUM_STATUS_OK) && (task == KFWUM_TASK_STATUS))
+   {
+      if(verbose)
+      {
+         printf("Getting Kontron FWUM Status\n");
+      }
+      KfwumGetStatus(intf);
+   }
+
+   if( (status == KFWUM_STATUS_OK) && (task == KFWUM_TASK_ROLLBACK) )
+   {
+      status = KfwumManualRollback(intf);      
+   }
+
+   if(
+      (status == KFWUM_STATUS_OK) &&
+      (
+         (task == KFWUM_TASK_UPGRADE) || (task == KFWUM_TASK_DOWNLOAD)
+      )
+     )
+   {
+      status = KfwumGetFileSize(fileName, &fileSize);
+      if(status == KFWUM_STATUS_OK)
+      {
+         status = KfwumSetupBuffersFromFile(fileName, fileSize);
+         if(status == KFWUM_STATUS_OK)
+         {
+            padding = KfwumCalculateChecksumPadding(firmBuf, fileSize);
+         }
+      }
+      if(status == KFWUM_STATUS_OK)
+      {
+         status = KfwumGetInfoFromFirmware(firmBuf, fileSize, &firmInfo);
+      }
+      if(status == KFWUM_STATUS_OK)
+      {
+         status = KfwumGetDeviceInfo(intf, 0, &boardInfo);
+      }
+
+      if(status == KFWUM_STATUS_OK)
+      {
+         status = KfwumValidFirmwareForBoard(boardInfo,firmInfo);
+      }
+      
+      if (status == KFWUM_STATUS_OK)
+      {
+      	unsigned char notUsed;
+      	KfwumGetInfo(intf, 0, &notUsed);
+      }
+
+      KfwumOutputInfo(boardInfo,firmInfo);
+   }
+
+   if(
+      (status == KFWUM_STATUS_OK) &&
+      (
+         (task == KFWUM_TASK_UPGRADE) || (task == KFWUM_TASK_DOWNLOAD)
+      )
+     )
+   {
+      status = KfwumStartFirmwareImage(intf, fileSize, padding);
+   }
+
+
+   if(
+      (status == KFWUM_STATUS_OK) &&
+      (
+         (task == KFWUM_TASK_UPGRADE) || (task == KFWUM_TASK_DOWNLOAD)
+      )
+     )
+   {
+      status = KfwumUploadFirmware(intf, firmBuf, fileSize);
+   }
+
+   if(
+      (status == KFWUM_STATUS_OK) &&
+      (
+         (task == KFWUM_TASK_UPGRADE) || (task == KFWUM_TASK_DOWNLOAD)
+      )
+     )
+   {
+      status = KfwumFinishFirmwareImage(intf, firmInfo);
+   }
+
+   if(
+      (status == KFWUM_STATUS_OK) &&
+      (
+         (task == KFWUM_TASK_UPGRADE) || (task == KFWUM_TASK_DOWNLOAD)
+      )
+     )
+   {
+      status = KfwumGetStatus(intf);
+   }
+
+   if(
+      (status == KFWUM_STATUS_OK) &&
+      (
+         (task == KFWUM_TASK_UPGRADE) || (task == KFWUM_TASK_START_UPGRADE)
+      )
+     )
+   {
+      status = KfwumStartFirmwareUpgrade(intf);
+   }
+   
+   if((status == KFWUM_STATUS_OK) && (task == KFWUM_TASK_TRACELOG))
+   {
+      status = KfwumGetTraceLog(intf);
+   }
+
+
+}
+
+/* KfwumGetFileSize  -  gets the file size
+ *
+ * @pFileName : filename ptr
+ * @pFileSize : output ptr for filesize
+ *
+ * returns KFWUM_STATUS_OK or KFWUM_STATUS_ERROR
+ */
+static tKFWUM_Status KfwumGetFileSize(unsigned char * pFileName,
+                                                     unsigned long * pFileSize)
+{
+   tKFWUM_Status status = KFWUM_STATUS_ERROR;
+   FILE * pFileHandle;
+
+   pFileHandle = fopen((const char *)pFileName, "rb");
+
+   if(pFileHandle)
+   {
+      if(fseek(pFileHandle, 0L , SEEK_END) == (unsigned int) NULL)
+      {
+         *pFileSize     =    ftell(pFileHandle);
+
+         if( *pFileSize != 0)
+         {
+            status = KFWUM_STATUS_OK;
+         }
+      }
+      fclose(pFileHandle);
+   }
+
+   return(status);
+}
+
+/* KfwumSetupBuffersFromFile  -  small buffers are used to store the file data
+ *
+ * @pFileName : filename ptr
+ * unsigned long : filesize
+ *
+ * returns KFWUM_STATUS_OK or KFWUM_STATUS_ERROR
+ */
+#define MAX_BUFFER_SIZE          1024*16
+static tKFWUM_Status KfwumSetupBuffersFromFile(unsigned char * pFileName,
+                                                        unsigned long fileSize)
+{
+   tKFWUM_Status status = KFWUM_STATUS_OK;
+   FILE * pFileHandle;
+
+   pFileHandle = fopen((const char *)pFileName, "rb");
+
+   if(pFileHandle)
+   {
+      int count   = fileSize / MAX_BUFFER_SIZE;
+      int modulus = fileSize % MAX_BUFFER_SIZE;
+      int qty     =0;
+
+      rewind(pFileHandle);
+
+      for(qty=0;qty<count;qty++)
+      {
+         KfwumShowProgress((const unsigned char *)"Reading Firmware from File", qty, count );
+         if(fread(&firmBuf[qty*MAX_BUFFER_SIZE], 1, MAX_BUFFER_SIZE ,pFileHandle)
+            ==  MAX_BUFFER_SIZE)
+         {
+            status = KFWUM_STATUS_OK;
+         }
+      }
+      if( modulus )
+      {
+         if(fread(&firmBuf[qty*MAX_BUFFER_SIZE], 1, modulus, pFileHandle) == modulus)
+         {
+            status = KFWUM_STATUS_OK;
+         }
+      }
+      if(status == KFWUM_STATUS_OK)
+      {
+         KfwumShowProgress((const unsigned char *)"Reading Firmware from File", 100, 100);
+      }
+   }
+   return(status);
+}
+
+/* KfwumShowProgress  -  helper routine to display progress bar
+ *
+ * Converts current/total in percent
+ * 
+ * *task  : string identifying current operation
+ * current: progress
+ * total  : limit 
+ */
+#define PROG_LENGTH 42
+void KfwumShowProgress( const unsigned char * task,  unsigned long current ,
+                                                           unsigned long total)
+{
+   static unsigned long staticProgress=0xffffffff;
+
+   unsigned char spaces[PROG_LENGTH + 1];
+   unsigned short hash;
+   float  percent = ((float)current/total);
+   unsigned long progress =  100*(percent);
+
+   if(staticProgress == progress)
+   {
+      /* We displayed the same last time.. so don't do it */
+   }
+   else
+   {
+      staticProgress = progress;
+
+
+      printf("%-25s : ",task);    /* total 20 bytes */
+
+      hash = ( percent * PROG_LENGTH );
+      memset(spaces,'#', hash);
+      spaces[ hash ] = '\0';
+      printf("%s", spaces );
+
+      memset(spaces,' ',( PROG_LENGTH - hash ) );
+      spaces[ ( PROG_LENGTH - hash ) ] = '\0';
+      printf("%s", spaces );
+
+
+      printf(" %3ld %%\r",progress); /* total 7 bytes */
+
+      if( progress == 100 )
+      {
+         printf("\n");
+      }
+      fflush(stdout);
+   }
+}
+
+/* KfwumCalculateChecksumPadding
+ *
+ * TBD
+ * 
+ */
+static unsigned short KfwumCalculateChecksumPadding(unsigned char * pBuffer,
+                                                       unsigned long totalSize)
+{
+   unsigned short sumOfBytes = 0;
+   unsigned short padding;
+   unsigned long  counter;
+
+   for(counter = 0; counter < totalSize; counter ++ )
+   {
+      sumOfBytes += pBuffer[counter];
+   }
+
+   padding = 0 - sumOfBytes;
+   return padding;
+}
+
+/******************************************************************************
+******************************* COMMANDS **************************************
+******************************************************************************/
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
-struct KfwumStartFirmwareDownloadReq{
-   unsigned char lengthLSB;
-   unsigned char lengthMid;
-   unsigned char lengthMSB;
-   unsigned char paddingLSB;
-   unsigned char paddingMSB;
-	unsigned char useSequence;
+struct KfwumGetInfoResp {
+   unsigned char protocolRevision;
+   unsigned char controllerDeviceId;
+   struct 
+   {
+      unsigned char mode:1;
+      unsigned char seqAdd:1;
+      unsigned char res : 6;
+   } byte;
+   unsigned char firmRev1;
+   unsigned char firmRev2;
+   unsigned char numBank;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+
+
+/* KfwumGetInfo  -  Get Firmware Update Manager (FWUM) information
+ * 
+ * * intf  : IPMI interface 
+ * output  : when set to non zero, queried information is displayed
+ * pNumBank: output ptr for number of banks
+ */
+static tKFWUM_Status KfwumGetInfo(struct ipmi_intf * intf, unsigned char output,
+                                                       unsigned char *pNumBank)
+{
+   tKFWUM_Status status = KFWUM_STATUS_OK;
+   static struct KfwumGetInfoResp *pGetInfo;
+   struct ipmi_rs * rsp;
+   struct ipmi_rq req;
+
+   memset(&req, 0, sizeof(req));
+   req.msg.netfn = IPMI_NETFN_FIRMWARE;
+   req.msg.cmd = KFWUM_CMD_ID_GET_FIRMWARE_INFO;
+   req.msg.data_len = 0;
+
+   rsp = intf->sendrecv(intf, &req);
+
+   if (!rsp)
+   {
+      printf("Error in FWUM Firmware Get Info Command\n");
+      status = KFWUM_STATUS_ERROR;
+   }
+   else if (rsp->ccode)
+   {
+      printf("FWUM Firmware Get Info returned %x\n", rsp->ccode);
+      status = KFWUM_STATUS_ERROR;
+   }
+
+   if(status == KFWUM_STATUS_OK)
+   {
+      pGetInfo = (struct KfwumGetInfoResp *) rsp->data;
+      if(output)
+      {
+         printf("\nFWUM info\n");
+         printf("=========\n");
+         printf("Protocol Revision         : %02Xh\n",
+                                                    pGetInfo->protocolRevision);
+         printf("Controller Device Id      : %02Xh\n",
+                                                  pGetInfo->controllerDeviceId);
+         printf("Firmware Revision         : %u.%u%u",
+                                 pGetInfo->firmRev1, pGetInfo->firmRev2 >> 4,
+                                                     pGetInfo->firmRev2 & 0x0f);
+         if(pGetInfo->byte.mode != 0)
+         {
+            printf(" - DEBUG BUILD\n");
+         }
+         else
+         {
+            printf("\n");
+         }
+         printf("Number Of Memory Bank     : %u\n",pGetInfo->numBank);
+      }
+      * pNumBank = pGetInfo->numBank;
+      
+      /* Determine wich type of download to use: */
+      /* Old FWUM or Old IPMC fw (data_len < 7) -->
+          Address with small buffer size */
+      if ( (pGetInfo->protocolRevision) <= 0x05 || (rsp->data_len < 7 ) )
+      {
+      	saveFirmwareInfo.downloadType = KFWUM_DOWNLOAD_TYPE_ADDRESS;
+         saveFirmwareInfo.bufferSize   = KFWUM_SMALL_BUFFER;
+         saveFirmwareInfo.overheadSize = KFWUM_OLD_CMD_OVERHEAD;
+
+         if(verbose)
+         {
+            printf("Protocol Revision          :");
+            printf(" <= 5 detected, adjusting buffers\n");
+         }
+      }
+      else /* Both fw are using the new protocol */
+      {
+      	saveFirmwareInfo.downloadType = KFWUM_DOWNLOAD_TYPE_SEQUENCE;
+         saveFirmwareInfo.overheadSize = KFWUM_NEW_CMD_OVERHEAD;
+         /* Buffer size depending on access type (Local or remote) */
+         /* Look if we run remote or locally */
+
+         if(verbose)
+         {
+            printf("Protocol Revision          :");
+            printf(" > 5 optimizing buffers\n");
+         }
+
+         if(strstr(intf->name,"lan")!= NULL) /* also covers lanplus */
+         {
+            saveFirmwareInfo.bufferSize = KFWUM_SMALL_BUFFER;
+            if(verbose)
+            {
+               printf("IOL payload size           : %d\r\n"  ,
+                                                  saveFirmwareInfo.bufferSize);
+            }
+         }
+         else if
+         (
+           (strstr(intf->name,"open")!= NULL)
+           &&
+           intf->target_addr != IPMI_BMC_SLAVE_ADDR 
+           &&
+           (
+              intf->target_addr !=  intf->my_addr
+           )
+         )
+         {
+            saveFirmwareInfo.bufferSize = KFWUM_SMALL_BUFFER;
+            if(verbose)
+            {
+               printf("IPMB payload size          : %d\r\n"  , 
+                                                   saveFirmwareInfo.bufferSize);
+            }
+         }
+         else
+         {
+         	saveFirmwareInfo.bufferSize = KFWUM_BIG_BUFFER;
+            if(verbose)
+            {
+               printf("SMI payload size           : %d\r\n", 
+                                                  saveFirmwareInfo.bufferSize);
+            }
+         }
+      }
+   }
+   return status;
+}
+
+/* KfwumGetDeviceInfo  -  Get IPMC/Board information
+ * 
+ * * intf  : IPMI interface 
+ * output  : when set to non zero, queried information is displayed
+ * tKFWUM_BoardInfo: output ptr for IPMC/Board information
+ */
+static tKFWUM_Status KfwumGetDeviceInfo(struct ipmi_intf * intf,
+                            unsigned char output, tKFWUM_BoardInfo * pBoardInfo)
+{
+   struct ipm_devid_rsp   *pGetDevId;
+   tKFWUM_Status status = KFWUM_STATUS_OK;
+   struct ipmi_rs * rsp;
+   struct ipmi_rq req;
+
+   /* Send Get Device Id */
+   if(status == KFWUM_STATUS_OK)
+   {
+      memset(&req, 0, sizeof(req));
+      req.msg.netfn = IPMI_NETFN_APP;
+      req.msg.cmd = BMC_GET_DEVICE_ID;
+      req.msg.data_len = 0;
+
+      rsp = intf->sendrecv(intf, &req);
+      if (!rsp)
+      {
+         printf("Error in Get Device Id Command\n");
+         status = KFWUM_STATUS_ERROR;
+      }
+      else if (rsp->ccode)
+      {
+         printf("Get Device Id returned %x\n", rsp->ccode);
+         status = KFWUM_STATUS_ERROR;
+      }
+   }
+
+   if(status == KFWUM_STATUS_OK)
+   {
+      pGetDevId = (struct ipm_devid_rsp *) rsp->data;
+      pBoardInfo->iana = IPM_DEV_MANUFACTURER_ID(pGetDevId->manufacturer_id);
+      pBoardInfo->boardId = buf2short(pGetDevId->product_id);
+      if(output)
+      {
+         printf("\nIPMC Info\n");
+         printf("=========\n");
+         printf("Manufacturer Id           : %u\n",pBoardInfo->iana);
+         printf("Board Id                  : %u\n",pBoardInfo->boardId);
+         printf("Firmware Revision         : %u.%u%u",
+                                 pGetDevId->fw_rev1, pGetDevId->fw_rev2 >> 4,
+                                                   pGetDevId->fw_rev2 & 0x0f);
+         if(
+            ( 
+               ( pBoardInfo->iana == KFWUM_IANA_KONTRON)
+               && 
+               (pBoardInfo->boardId = KFWUM_BOARD_KONTRON_5002)
+            )
+           )
+         {
+            printf(" SDR %u\n", pGetDevId->aux_fw_rev[0]);
+         }
+         else
+         {
+            printf("\n");
+         }
+      }
+   }
+
+   return status;
+}
+
+
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
-struct KfwumStartFirmwareDownloadResp {
-   unsigned char bank;
+struct KfwumGetStatusResp {
+   unsigned char bankState;
+   unsigned char firmLengthLSB;
+   unsigned char firmLengthMid;
+   unsigned char firmLengthMSB;
+   unsigned char firmRev1;
+   unsigned char firmRev2;
+   unsigned char firmRev3;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
-
-static tKFWUM_Status KfwumStartFirmwareImage(struct ipmi_intf * intf,
-                                   unsigned long length,unsigned short padding)
-{
-   tKFWUM_Status status = KFWUM_STATUS_OK;
-   struct ipmi_rs * rsp;
-   struct ipmi_rq req;
-   struct KfwumStartFirmwareDownloadResp *pResp;
-   struct KfwumStartFirmwareDownloadReq thisReq;
-
-   thisReq.lengthLSB  = length         & 0x000000ff;
-   thisReq.lengthMid  = (length >>  8) & 0x000000ff;
-   thisReq.lengthMSB  = (length >> 16) & 0x000000ff;
-   thisReq.paddingLSB = padding        & 0x00ff;
-   thisReq.paddingMSB = (padding>>  8) & 0x00ff;
-	thisReq.useSequence = 0x01;
-
-   memset(&req, 0, sizeof(req));
-   req.msg.netfn = IPMI_NETFN_FIRMWARE;
-   req.msg.cmd = KFWUM_CMD_ID_START_FIRMWARE_IMAGE;
-   req.msg.data = (unsigned char *) &thisReq;
-   
-   /* Look for download type */
-   if ( saveFirmwareInfo.downloadType == KFWUM_DOWNLOAD_TYPE_ADDRESS )
-   {
-   	req.msg.data_len = 5;
-   }
-   else
-   {
-   	req.msg.data_len = 6;
-   }
-      
-   rsp = intf->sendrecv(intf, &req);
-
-   if (!rsp)
-   {
-      printf("Error in FWUM Firmware Start Firmware Image Download Command\n");
-      status = KFWUM_STATUS_ERROR;
-   }
-   else if (rsp->ccode)
-   {
-      printf("FWUM Firmware Start Firmware Image Download returned %x\n",
-                                                                    rsp->ccode);
-      status = KFWUM_STATUS_ERROR;
-   }
-
-   if(status == KFWUM_STATUS_OK)
-   {
-      pResp = (struct KfwumStartFirmwareDownloadResp *) rsp->data;
-      printf("Bank holding new firmware  : %d\n", pResp->bank);
-      sleep(5);
-   }
-   return status;
-}
-
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+ 
+
+const struct valstr bankStateValS[] = {
+   { 0x00, "Not programmed" },
+   { 0x01, "New firmware" },
+   { 0x02, "Wait for validation" },
+   { 0x03, "Last Known Good" },
+   { 0x04, "Previous Good" }
+};
+
+/* KfwumGetStatus  -  Get (and prints) FWUM  banks information
+ * 
+ * * intf  : IPMI interface 
+ */
+static tKFWUM_Status KfwumGetStatus(struct ipmi_intf * intf)
+{
+   tKFWUM_Status status = KFWUM_STATUS_OK;
+   struct ipmi_rs * rsp;
+   struct ipmi_rq req;
+   struct KfwumGetStatusResp *pGetStatus;
+   unsigned char numBank;
+   unsigned char counter;
+
+   if(verbose)
+   {
+      printf(" Getting Status!\n");
+   }
+
+   /* Retreive the number of bank */
+   status = KfwumGetInfo(intf, 0, &numBank);
+
+   for(
+         counter = 0;
+         (counter < numBank) && (status == KFWUM_STATUS_OK);
+         counter ++
+      )
+   {
+      /* Retreive the status of each bank */
+      memset(&req, 0, sizeof(req));
+      req.msg.netfn = IPMI_NETFN_FIRMWARE;
+      req.msg.cmd = KFWUM_CMD_ID_GET_FIRMWARE_STATUS;
+      req.msg.data = &counter;
+      req.msg.data_len = 1;
+
+      rsp = intf->sendrecv(intf, &req);
+
+      if (!rsp)
+      {
+         printf("Error in FWUM Firmware Get Status Command\n");
+         status = KFWUM_STATUS_ERROR;
+      }
+      else if (rsp->ccode)
+      {
+         printf("FWUM Firmware Get Status returned %x\n", rsp->ccode);
+         status = KFWUM_STATUS_ERROR;
+      }
+
+
+      if(status == KFWUM_STATUS_OK)
+      {
+         pGetStatus = (struct KfwumGetStatusResp *) rsp->data;
+         printf("\nBank State %d               : %s\n", counter, val2str(
+                                         pGetStatus->bankState, bankStateValS));
+         if(pGetStatus->bankState)
+         {
+            unsigned long firmLength;
+            firmLength  = pGetStatus->firmLengthMSB;
+            firmLength  = firmLength << 8;
+            firmLength |= pGetStatus->firmLengthMid;
+            firmLength  = firmLength << 8;
+            firmLength |= pGetStatus->firmLengthLSB;
+
+            printf("Firmware Length            : %ld bytes\n", firmLength);
+            printf("Firmware Revision          : %u.%u%u SDR %u\n",
+                              pGetStatus->firmRev1,  pGetStatus->firmRev2 >> 4,
+                           pGetStatus->firmRev2 & 0x0f, pGetStatus->firmRev3);
+         }
+      }
+   }
+   printf("\n");
+   return status;
+}
+
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
+struct KfwumManualRollbackReq{
+   unsigned char type;
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
+
+
+/* KfwumManualRollback  -  Ask IPMC to rollback to previous version
+ * 
+ * * intf  : IPMI interface 
+ */
+static tKFWUM_Status KfwumManualRollback(struct ipmi_intf * intf)
+{
+  tKFWUM_Status status = KFWUM_STATUS_OK;
+   struct ipmi_rs * rsp;
+   struct ipmi_rq req;
+   struct KfwumManualRollbackReq thisReq;
+
+
+   memset(&req, 0, sizeof(req));
+   req.msg.netfn = IPMI_NETFN_FIRMWARE;
+   req.msg.cmd = KFWUM_CMD_ID_MANUAL_ROLLBACK;
+
+   thisReq.type = 0;  /* Wait BMC shutdown */
+
+   req.msg.data = (unsigned char *) &thisReq;
+   req.msg.data_len = 1;
+
+   rsp = intf->sendrecv(intf, &req);
+
+   if (!rsp)
+   {
+      printf("Error in FWUM Manual Rollback Command\n");
+      status = KFWUM_STATUS_ERROR;
+   }
+   else if (rsp->ccode)
+   {
+      printf("Error in FWUM Manual Rollback Command returned %x\n",
+                                                                    rsp->ccode);
+      status = KFWUM_STATUS_ERROR;
+   }
+
+   if(status == KFWUM_STATUS_OK)
+   {
+      printf("FWUM Starting Manual Rollback \n");
+   }
+   return status;
+}
+
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
-struct KfwumSaveFirmwareAddressReq
-{
- 	unsigned char addressLSB;
-   unsigned char addressMid;
-   unsigned char addressMSB;
-   unsigned char numBytes;
-   unsigned char txBuf[KFWUM_SMALL_BUFFER-KFWUM_OLD_CMD_OVERHEAD];
+struct KfwumStartFirmwareDownloadReq{
+   unsigned char lengthLSB;
+   unsigned char lengthMid;
+   unsigned char lengthMSB;
+   unsigned char paddingLSB;
+   unsigned char paddingMSB;
+	unsigned char useSequence;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
-struct KfwumSaveFirmwareSequenceReq
-{
- 	unsigned char sequenceNumber;
-   unsigned char txBuf[KFWUM_BIG_BUFFER];
+struct KfwumStartFirmwareDownloadResp {
+   unsigned char bank;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
-
-
-#define FWUM_SAVE_FIRMWARE_NO_RESPONSE_LIMIT ((unsigned char)6)
-
-static tKFWUM_Status KfwumSaveFirmwareImage(struct ipmi_intf * intf,
-     unsigned char sequenceNumber, unsigned long address, unsigned char *pFirmBuf, 
-     unsigned char * pInBufLength)
-{
-   tKFWUM_Status status = KFWUM_STATUS_OK;
-   struct ipmi_rs * rsp;
-   struct ipmi_rq req;
-   unsigned char out = 0;
-   unsigned char retry = 0;
-   unsigned char noResponse = 0 ;
-   
-   struct KfwumSaveFirmwareAddressReq  addressReq;
-   struct KfwumSaveFirmwareSequenceReq sequenceReq;
-
-   do
-   {
-   	memset(&req, 0, sizeof(req));
-      req.msg.netfn = IPMI_NETFN_FIRMWARE;
-      req.msg.cmd = KFWUM_CMD_ID_SAVE_FIRMWARE_IMAGE;
-      
-   	if (saveFirmwareInfo.downloadType == KFWUM_DOWNLOAD_TYPE_ADDRESS )
-   	{
-      	addressReq.addressLSB  = address         & 0x000000ff;
-         addressReq.addressMid  = (address >>  8) & 0x000000ff;
-         addressReq.addressMSB  = (address >> 16) & 0x000000ff;
-         addressReq.numBytes    = (* pInBufLength);
-         memcpy(addressReq.txBuf, pFirmBuf, (* pInBufLength));
-         req.msg.data = (unsigned char *) &addressReq;
-         req.msg.data_len = (* pInBufLength)+4;
-   	}
-      else
-      {
-      	sequenceReq.sequenceNumber = sequenceNumber;
-         memcpy(sequenceReq.txBuf, pFirmBuf, (* pInBufLength));
-         req.msg.data = (unsigned char *) &sequenceReq;
-         req.msg.data_len = (* pInBufLength)+sizeof(unsigned char); /* + 1 => sequenceNumber*/
-      }
-      						
-      rsp = intf->sendrecv(intf, &req);
-
-      if (!rsp)
-      {
-         printf("Error in FWUM Firmware Save Firmware Image Download Command\n");
-
-         out = 0;
-         status = KFWUM_STATUS_OK;
-         
-         /* With IOL, we don't receive "C7" on errors, instead we receive
-            nothing */
-         if(strstr(intf->name,"lan")!= NULL)
-         {
-            noResponse++;
-
-            if(noResponse < FWUM_SAVE_FIRMWARE_NO_RESPONSE_LIMIT )
-            {
-               (* pInBufLength) -= 1;
-               out = 0;
-            }
-            else
-            {
-               printf("Error, too many commands without response\n");
-               (* pInBufLength) = 0 ;               
-               out = 1;
-            }
-         } /* For other interface keep trying */
-      }
-      else if (rsp->ccode)
-      {
-         if(rsp->ccode == 0xc0)
-         {
-            status = KFWUM_STATUS_OK;
-            sleep(1);
-         }
-         else if(
-                  (rsp->ccode == 0xc7)
-                  ||
-                  (
-                     (rsp->ccode == 0xC3) &&
-                     (sequenceNumber == 0)
-                  )
-                )
-         {
-            (* pInBufLength) -= 1;
-            status = KFWUM_STATUS_OK;
-            retry = 1;
-         }
-         else if(rsp->ccode == 0x82)
-         {
-            /* Double sent, continue */
-            status = KFWUM_STATUS_OK;
-            out = 1;
-         }
-         else if(rsp->ccode == 0x83)
-         {
-            if(retry == 0)
-            {
-               retry = 1;
-               status = KFWUM_STATUS_OK;
-            }
-            else
-            {
-               status = KFWUM_STATUS_ERROR;
-               out = 1;
-            }
-         }
-         else if(rsp->ccode == 0xcf) /* Ok if receive duplicated request */
-         {
-            retry = 1;
-            status = KFWUM_STATUS_OK;
-         }
-         else if(rsp->ccode == 0xC3)
-         {
-            if(retry == 0)
-           {
-               retry = 1;
-               status = KFWUM_STATUS_OK;
-            }
-            else
-            {
-               status = KFWUM_STATUS_ERROR;
-               out = 1;
-            }
-         }
-         else
-         {
-            printf("FWUM Firmware Save Firmware Image Download returned %x\n",
-                                                                     rsp->ccode);
-            status = KFWUM_STATUS_ERROR;
-            out = 1;
-         }
-      }
-      else
-      {
-         out = 1;
-      }
-   }while(out == 0);
-   return status;
-}
-
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+
+static tKFWUM_Status KfwumStartFirmwareImage(struct ipmi_intf * intf,
+                                   unsigned long length,unsigned short padding)
+{
+   tKFWUM_Status status = KFWUM_STATUS_OK;
+   struct ipmi_rs * rsp;
+   struct ipmi_rq req;
+   struct KfwumStartFirmwareDownloadResp *pResp;
+   struct KfwumStartFirmwareDownloadReq thisReq;
+
+   thisReq.lengthLSB  = length         & 0x000000ff;
+   thisReq.lengthMid  = (length >>  8) & 0x000000ff;
+   thisReq.lengthMSB  = (length >> 16) & 0x000000ff;
+   thisReq.paddingLSB = padding        & 0x00ff;
+   thisReq.paddingMSB = (padding>>  8) & 0x00ff;
+	thisReq.useSequence = 0x01;
+
+   memset(&req, 0, sizeof(req));
+   req.msg.netfn = IPMI_NETFN_FIRMWARE;
+   req.msg.cmd = KFWUM_CMD_ID_START_FIRMWARE_IMAGE;
+   req.msg.data = (unsigned char *) &thisReq;
+   
+   /* Look for download type */
+   if ( saveFirmwareInfo.downloadType == KFWUM_DOWNLOAD_TYPE_ADDRESS )
+   {
+   	req.msg.data_len = 5;
+   }
+   else
+   {
+   	req.msg.data_len = 6;
+   }
+      
+   rsp = intf->sendrecv(intf, &req);
+
+   if (!rsp)
+   {
+      printf("Error in FWUM Firmware Start Firmware Image Download Command\n");
+      status = KFWUM_STATUS_ERROR;
+   }
+   else if (rsp->ccode)
+   {
+      printf("FWUM Firmware Start Firmware Image Download returned %x\n",
+                                                                    rsp->ccode);
+      status = KFWUM_STATUS_ERROR;
+   }
+
+   if(status == KFWUM_STATUS_OK)
+   {
+      pResp = (struct KfwumStartFirmwareDownloadResp *) rsp->data;
+      printf("Bank holding new firmware  : %d\n", pResp->bank);
+      sleep(5);
+   }
+   return status;
+}
+
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
-struct KfwumFinishFirmwareDownloadReq{
-   unsigned char versionMaj;
-   unsigned char versionMinSub;
-   unsigned char versionSdr;
-   unsigned char reserved;
+struct KfwumSaveFirmwareAddressReq
+{
+ 	unsigned char addressLSB;
+   unsigned char addressMid;
+   unsigned char addressMSB;
+   unsigned char numBytes;
+   unsigned char txBuf[KFWUM_SMALL_BUFFER-KFWUM_OLD_CMD_OVERHEAD];
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-static tKFWUM_Status KfwumFinishFirmwareImage(struct ipmi_intf * intf,
-                                                 tKFWUM_InFirmwareInfo firmInfo)
-{
-   tKFWUM_Status status = KFWUM_STATUS_OK;
-   struct ipmi_rs * rsp;
-   struct ipmi_rq req;
-   struct KfwumFinishFirmwareDownloadReq thisReq;
-
-   thisReq.versionMaj     = firmInfo.versMajor;
-   thisReq.versionMinSub  = ((firmInfo.versMinor <<4) | firmInfo.versSubMinor);
-   thisReq.versionSdr     = firmInfo.sdrRev;
-   thisReq.reserved       = 0;
-   /* Byte 4 reserved, write 0 */
-
-   memset(&req, 0, sizeof(req));
-   req.msg.netfn = IPMI_NETFN_FIRMWARE;
-   req.msg.cmd = KFWUM_CMD_ID_FINISH_FIRMWARE_IMAGE;
-   req.msg.data = (unsigned char *) &thisReq;
-   req.msg.data_len = 4;
-   											       
-   do
-   {
-   	rsp = intf->sendrecv(intf, &req);
-   }while (rsp->ccode == 0xc0); 
-
-   if (!rsp)
-   {
-      printf("Error in FWUM Firmware Finish Firmware Image Download Command\n");
-      status = KFWUM_STATUS_ERROR;
-   }
-   else if (rsp->ccode)
-   {
-      printf("FWUM Firmware Finish Firmware Image Download returned %x\n",
-                                                                    rsp->ccode);
-      status = KFWUM_STATUS_ERROR;
-   }
-
-   return status;
-}
-
-
-#define FWUM_MAX_UPLOAD_RETRY 6
-static tKFWUM_Status KfwumUploadFirmware(struct ipmi_intf * intf,
-                               unsigned char * pBuffer, unsigned long totalSize)
-{
-   tKFWUM_Status status = KFWUM_STATUS_ERROR;
-   unsigned long address    = 0x0;
-   unsigned char writeSize;
-   unsigned char oldWriteSize;
-   unsigned long lastAddress = 0;
-   unsigned char sequenceNumber = 0;
-   unsigned char retry = FWUM_MAX_UPLOAD_RETRY;
-   unsigned char isLengthValid = 1;
-
-   do
-   {
-      writeSize = saveFirmwareInfo.bufferSize - saveFirmwareInfo.overheadSize;
-           
-      /* Reach the end */
-      if( address + writeSize > totalSize )
-      {
-         writeSize = (totalSize - address);
-      }
-      /* Reach boundary end */
-      else if(((address % KFWUM_PAGE_SIZE) + writeSize) > KFWUM_PAGE_SIZE)
-      {
-         writeSize = (KFWUM_PAGE_SIZE - (address % KFWUM_PAGE_SIZE));
-      }
-
-      oldWriteSize = writeSize;
-      status = KfwumSaveFirmwareImage(intf, sequenceNumber, address, 
-                                                &pBuffer[address], &writeSize);
- 
-      if((status != KFWUM_STATUS_OK) && (retry-- != 0))
-      {
-         address = lastAddress;
-         status = KFWUM_STATUS_OK;
-      }
-      else if( writeSize == 0 )
-      {
-         status = KFWUM_STATUS_ERROR;     
-      }
-      else
-      {
-         if(writeSize != oldWriteSize)
-         {
-            printf("Adjusting length to %d bytes \n", writeSize);
-            saveFirmwareInfo.bufferSize -= (oldWriteSize - writeSize);
-         }
-         
-         retry = FWUM_MAX_UPLOAD_RETRY;
-         lastAddress = address;
-         address+= writeSize;
-      }
-
-      if(status == KFWUM_STATUS_OK)
-      {
-         if((address % 1024) == 0)
-         {
-            KfwumShowProgress((const unsigned char *)\
-                                 "Writting Firmware in Flash",address,totalSize);
-         }
-         sequenceNumber++;
-      }
-
-   }while((status == KFWUM_STATUS_OK) && (address < totalSize  ));
-
-   if(status == KFWUM_STATUS_OK)
-   {
-      KfwumShowProgress((const unsigned char *)\
-                                       "Writting Firmware in Flash", 100 , 100 );
-   }
-
-   return(status);
-}
-
-static tKFWUM_Status KfwumStartFirmwareUpgrade(struct ipmi_intf * intf)
-{
-   tKFWUM_Status status = KFWUM_STATUS_OK;
-   struct ipmi_rs * rsp;
-   struct ipmi_rq req;
-   unsigned char upgType = 0 ;  /* Upgrade type, wait BMC shutdown */
-
-   memset(&req, 0, sizeof(req));
-   req.msg.netfn = IPMI_NETFN_FIRMWARE;
-   req.msg.cmd = KFWUM_CMD_ID_START_FIRMWARE_UPDATE;
-   req.msg.data = (unsigned char *) &upgType;
-   req.msg.data_len = 1;
-
-   rsp = intf->sendrecv(intf, &req);
-
-   if (!rsp)
-   {
-      printf("Error in FWUM Firmware Start Firmware Upgrade Command\n");
-      status = KFWUM_STATUS_ERROR;
-   }
-   else if (rsp->ccode)
-   {
-      if(rsp->ccode == 0xd5)
-      {
-         printf("No firmware available for upgrade.  Download Firmware first\n");
-      }
-      else
-      {
-         printf("FWUM Firmware Start Firmware Upgrade returned %x\n",
-                                                                    rsp->ccode);
-      }
-      status = KFWUM_STATUS_ERROR;
-   }
-
-   return status;              
-}
-
-#define TRACE_LOG_CHUNK_COUNT 7
-#define TRACE_LOG_CHUNK_SIZE  7
-#define TRACE_LOG_ATT_COUNT   3
-/* String table */
-/* Must match eFWUM_CmdId */
-static const char* CMD_ID_STRING[] = {
-                "GetFwInfo",
-                "KickWatchdog",
-                "GetLastAnswer",
-                "BootHandshake",
-                "ReportStatus",
-                "CtrlIPMBLine",
-                "SetFwState",                
-                "GetFwStatus",
-                "GetSpiMemStatus",
-                "StartFwUpdate",
-                "StartFwImage",
-                "SaveFwImage",
-                "FinishFwImage",
-                "ReadFwImage",
-                "ManualRollback",
-                "GetTraceLog" };
-                
-static const char* EXT_CMD_ID_STRING[] = {
-                "FwUpgradeLock",
-                "ProcessFwUpg",
-                "ProcessFwRb",
-                "WaitHSAfterUpg",
-                "WaitFirstHSUpg",
-                "FwInfoStateChange" };
-               
-                
-static const char* CMD_STATE_STRING[] = {
-                "Invalid",
-                "Begin",
-                "Progress",
-                "Completed" };
-
-
-static tKFWUM_Status KfwumGetTraceLog(struct ipmi_intf * intf)
-{
-   tKFWUM_Status status = KFWUM_STATUS_OK;
-   struct ipmi_rs *rsp;
-   struct ipmi_rq req;
-   unsigned char  chunkIdx;
-   unsigned char  cmdIdx;
-
-   if(verbose)
-   {
-      printf(" Getting Trace Log!\n");
-   }
-   
-   for( chunkIdx = 0; (chunkIdx < TRACE_LOG_CHUNK_COUNT) && (status == KFWUM_STATUS_OK); chunkIdx++ )
-   {
-      /* Retreive each log chunk and print it */
-      memset(&req, 0, sizeof(req));
-      req.msg.netfn = IPMI_NETFN_FIRMWARE;
-      req.msg.cmd = KFWUM_CMD_ID_GET_TRACE_LOG;
-      req.msg.data = &chunkIdx;
-      req.msg.data_len = 1;
-
-      rsp = intf->sendrecv(intf, &req);
-      
-      if (!rsp)
-      {
-         printf("Error in FWUM Firmware Get Trace Log Command\n");
-         status = KFWUM_STATUS_ERROR;
-      }
-      else if (rsp->ccode)
-      {
-         printf("FWUM Firmware Get Trace Log returned %x\n", rsp->ccode);
-         status = KFWUM_STATUS_ERROR;
-      } 
-
-      if(status == KFWUM_STATUS_OK)
-      {
-         for (cmdIdx=0; cmdIdx < TRACE_LOG_CHUNK_SIZE; cmdIdx++)
-         {
-            /* Don't diplay commands with an invalid state */
-            if ( (rsp->data[TRACE_LOG_ATT_COUNT*cmdIdx+1] != 0) && 
-                 (rsp->data[TRACE_LOG_ATT_COUNT*cmdIdx] < KFWUM_CMD_ID_STD_MAX_CMD))
-            {
-               printf("  Cmd ID: %17s -- CmdState: %10s -- CompCode: %2x\n", 
-                                             CMD_ID_STRING[rsp->data[TRACE_LOG_ATT_COUNT*cmdIdx]],
-                                             CMD_STATE_STRING[rsp->data[TRACE_LOG_ATT_COUNT*cmdIdx+1]],
-                                             rsp->data[TRACE_LOG_ATT_COUNT*cmdIdx+2]);
-            }
-            else if ( (rsp->data[TRACE_LOG_ATT_COUNT*cmdIdx+1] != 0) && 
-                      (rsp->data[TRACE_LOG_ATT_COUNT*cmdIdx] >= KFWUM_CMD_ID_EXTENDED_CMD))
-            {
-               printf("  Cmd ID: %17s -- CmdState: %10s -- CompCode: %2x\n", 
-                                             EXT_CMD_ID_STRING[rsp->data[TRACE_LOG_ATT_COUNT*cmdIdx] - KFWUM_CMD_ID_EXTENDED_CMD],
-                                             CMD_STATE_STRING[rsp->data[TRACE_LOG_ATT_COUNT*cmdIdx+1]],
-                                             rsp->data[TRACE_LOG_ATT_COUNT*cmdIdx+2]);
-            }
-         }
-      }
-   }    
-   printf("\n");
-   return status;
-}
-
-
-/*******************************************************************************
-* Function Name: KfwumGetInfoFromFirmware
-*
-* Description: This function retreive from the firmare the following info :
-*
-*              o Checksum
-*              o File size (expected)
-*              o Board Id
-*              o Device Id
-*
-* Restriction: None
-*
-* Input: char * fileName - File to get info from
-*
-* Output: pInfo - container that will hold all the informations gattered.
-*                 see structure for all details
-*
-* Global: None
-*
-* Return: IFWU_SUCCESS - file ok
-*         IFWU_ERROR   - file error
-*
-*******************************************************************************/
-#define IN_FIRMWARE_INFO_OFFSET_LOCATION           0x5a0
-#define IN_FIRMWARE_INFO_SIZE                      20
-#define IN_FIRMWARE_INFO_OFFSET_FILE_SIZE          0
-#define IN_FIRMWARE_INFO_OFFSET_CHECKSUM           4
-#define IN_FIRMWARE_INFO_OFFSET_BOARD_ID           6
-#define IN_FIRMWARE_INFO_OFFSET_DEVICE_ID          8
-#define IN_FIRMWARE_INFO_OFFSET_TABLE_VERSION      9
-#define IN_FIRMWARE_INFO_OFFSET_IMPLEMENT_REV      10
-#define IN_FIRMWARE_INFO_OFFSET_VERSION_MAJOR      11
-#define IN_FIRMWARE_INFO_OFFSET_VERSION_MINSUB     12
-#define IN_FIRMWARE_INFO_OFFSET_SDR_REV            13
-#define IN_FIRMWARE_INFO_OFFSET_IANA0              14
-#define IN_FIRMWARE_INFO_OFFSET_IANA1              15
-#define IN_FIRMWARE_INFO_OFFSET_IANA2              16
-
-#define KWUM_GET_BYTE_AT_OFFSET(pBuffer,os)            pBuffer[os]
-
-tKFWUM_Status KfwumGetInfoFromFirmware(unsigned char * pBuf,
-                         unsigned long bufSize,  tKFWUM_InFirmwareInfo * pInfo)
-{
-   tKFWUM_Status status = KFWUM_STATUS_ERROR;
-
-   if(bufSize >= (IN_FIRMWARE_INFO_OFFSET_LOCATION + IN_FIRMWARE_INFO_SIZE))
-   {
-      unsigned long offset = IN_FIRMWARE_INFO_OFFSET_LOCATION;
-
-      /* Now, fill the structure with read informations */
-      pInfo->checksum  =  (unsigned short)KWUM_GET_BYTE_AT_OFFSET(pBuf,
-                           offset+0+IN_FIRMWARE_INFO_OFFSET_CHECKSUM ) << 8;
-      pInfo->checksum |= (unsigned short)KWUM_GET_BYTE_AT_OFFSET(pBuf,
-                           offset+1+IN_FIRMWARE_INFO_OFFSET_CHECKSUM );
-
-
-      pInfo->sumToRemoveFromChecksum=
-         KWUM_GET_BYTE_AT_OFFSET(pBuf,
-                              offset+IN_FIRMWARE_INFO_OFFSET_CHECKSUM);
-
-      pInfo->sumToRemoveFromChecksum+=
-        KWUM_GET_BYTE_AT_OFFSET(pBuf ,
-                             offset+IN_FIRMWARE_INFO_OFFSET_CHECKSUM+1);
-
-      pInfo->fileSize  =
-         KWUM_GET_BYTE_AT_OFFSET(pBuf ,
-                              offset+IN_FIRMWARE_INFO_OFFSET_FILE_SIZE+0) << 24;
-      pInfo->fileSize |=
-         (unsigned long)KWUM_GET_BYTE_AT_OFFSET(pBuf,
-                              offset+IN_FIRMWARE_INFO_OFFSET_FILE_SIZE+1) << 16;
-      pInfo->fileSize |=
-         (unsigned long)KWUM_GET_BYTE_AT_OFFSET(pBuf,
-                              offset+IN_FIRMWARE_INFO_OFFSET_FILE_SIZE+2) << 8;
-      pInfo->fileSize |=
-         (unsigned long)KWUM_GET_BYTE_AT_OFFSET(pBuf,
-                              offset+IN_FIRMWARE_INFO_OFFSET_FILE_SIZE+3);
-
-      pInfo->boardId   =
-         KWUM_GET_BYTE_AT_OFFSET(pBuf,
-                              offset+IN_FIRMWARE_INFO_OFFSET_BOARD_ID+0) << 8;
-      pInfo->boardId  |=
-         KWUM_GET_BYTE_AT_OFFSET(pBuf,
-                              offset+IN_FIRMWARE_INFO_OFFSET_BOARD_ID+1);
-
-      pInfo->deviceId  =
-         KWUM_GET_BYTE_AT_OFFSET(pBuf,
-                              offset+IN_FIRMWARE_INFO_OFFSET_DEVICE_ID);
-
-      pInfo->tableVers     =
-         KWUM_GET_BYTE_AT_OFFSET(pBuf,
-                              offset+IN_FIRMWARE_INFO_OFFSET_TABLE_VERSION);
-      pInfo->implRev       =
-         KWUM_GET_BYTE_AT_OFFSET(pBuf,
-                              offset+IN_FIRMWARE_INFO_OFFSET_IMPLEMENT_REV);
-      pInfo->versMajor     =
-         (KWUM_GET_BYTE_AT_OFFSET(pBuf,
-                      offset+IN_FIRMWARE_INFO_OFFSET_VERSION_MAJOR)) & 0x0f;
-      pInfo->versMinor     =
-         (KWUM_GET_BYTE_AT_OFFSET(pBuf,
-                 offset+IN_FIRMWARE_INFO_OFFSET_VERSION_MINSUB)>>4) & 0x0f;
-      pInfo->versSubMinor  =
-         (KWUM_GET_BYTE_AT_OFFSET(pBuf,
-                    offset+IN_FIRMWARE_INFO_OFFSET_VERSION_MINSUB)) & 0x0f;
-      pInfo->sdrRev        =
-         KWUM_GET_BYTE_AT_OFFSET(pBuf,
-                              offset+IN_FIRMWARE_INFO_OFFSET_SDR_REV);
-      pInfo->iana  =
-         KWUM_GET_BYTE_AT_OFFSET(pBuf ,
-                              offset+IN_FIRMWARE_INFO_OFFSET_IANA2) << 16;
-      pInfo->iana |=
-         (unsigned long)KWUM_GET_BYTE_AT_OFFSET(pBuf,
-                              offset+IN_FIRMWARE_INFO_OFFSET_IANA1) << 8;
-      pInfo->iana |=
-         (unsigned long)KWUM_GET_BYTE_AT_OFFSET(pBuf,
-                              offset+IN_FIRMWARE_INFO_OFFSET_IANA0);
-
-      KfwumFixTableVersionForOldFirmware(pInfo);
-
-      status = KFWUM_STATUS_OK;
-   }
-   return(status);
-}
-
-
-void KfwumFixTableVersionForOldFirmware(tKFWUM_InFirmwareInfo * pInfo)
-{
-   switch(pInfo->boardId)
-   {
-      case KFWUM_BOARD_KONTRON_UNKNOWN:
-         pInfo->tableVers = 0xff;
-      break;
-      default:
-         /* pInfo->tableVers is already set for the right version */
-      break;
-   }
-}
-
-
-tKFWUM_Status KfwumValidFirmwareForBoard(tKFWUM_BoardInfo boardInfo,
-                                                tKFWUM_InFirmwareInfo firmInfo)
-{
-   tKFWUM_Status status = KFWUM_STATUS_OK;
-
-   if(boardInfo.iana != firmInfo.iana)
-   {
-      printf("Board IANA does not match firmware IANA\n");
-      status = KFWUM_STATUS_ERROR;
-   }
-
-   if(boardInfo.boardId != firmInfo.boardId)
-   {
-      printf("Board IANA does not match firmware IANA\n");
-      status = KFWUM_STATUS_ERROR;
-   }
-
-
-   if(status == KFWUM_STATUS_ERROR)
-   {
-      printf("Firmware invalid for target board.  Download of upgrade aborted\n");
-   }
-   return status;
-}
-
-
-static void KfwumOutputInfo(tKFWUM_BoardInfo boardInfo,
-                                                tKFWUM_InFirmwareInfo firmInfo)
-{
-   printf("Target Board Id            : %u\n",boardInfo.boardId);
-   printf("Target IANA number         : %u\n",boardInfo.iana);
-   printf("File Size                  : %lu bytes\n",firmInfo.fileSize);
-   printf("Firmware Version           : %d.%d%d SDR %d\n",firmInfo.versMajor,
-                   firmInfo.versMinor, firmInfo.versSubMinor, firmInfo.sdrRev);
-}
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
+struct KfwumSaveFirmwareSequenceReq
+{
+ 	unsigned char sequenceNumber;
+   unsigned char txBuf[KFWUM_BIG_BUFFER];
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
+
+
+#define FWUM_SAVE_FIRMWARE_NO_RESPONSE_LIMIT ((unsigned char)6)
+
+static tKFWUM_Status KfwumSaveFirmwareImage(struct ipmi_intf * intf,
+     unsigned char sequenceNumber, unsigned long address, unsigned char *pFirmBuf, 
+     unsigned char * pInBufLength)
+{
+   tKFWUM_Status status = KFWUM_STATUS_OK;
+   struct ipmi_rs * rsp;
+   struct ipmi_rq req;
+   unsigned char out = 0;
+   unsigned char retry = 0;
+   unsigned char noResponse = 0 ;
+   
+   struct KfwumSaveFirmwareAddressReq  addressReq;
+   struct KfwumSaveFirmwareSequenceReq sequenceReq;
+
+   do
+   {
+   	memset(&req, 0, sizeof(req));
+      req.msg.netfn = IPMI_NETFN_FIRMWARE;
+      req.msg.cmd = KFWUM_CMD_ID_SAVE_FIRMWARE_IMAGE;
+      
+   	if (saveFirmwareInfo.downloadType == KFWUM_DOWNLOAD_TYPE_ADDRESS )
+   	{
+      	addressReq.addressLSB  = address         & 0x000000ff;
+         addressReq.addressMid  = (address >>  8) & 0x000000ff;
+         addressReq.addressMSB  = (address >> 16) & 0x000000ff;
+         addressReq.numBytes    = (* pInBufLength);
+         memcpy(addressReq.txBuf, pFirmBuf, (* pInBufLength));
+         req.msg.data = (unsigned char *) &addressReq;
+         req.msg.data_len = (* pInBufLength)+4;
+   	}
+      else
+      {
+      	sequenceReq.sequenceNumber = sequenceNumber;
+         memcpy(sequenceReq.txBuf, pFirmBuf, (* pInBufLength));
+         req.msg.data = (unsigned char *) &sequenceReq;
+         req.msg.data_len = (* pInBufLength)+sizeof(unsigned char); /* + 1 => sequenceNumber*/
+      }
+      						
+      rsp = intf->sendrecv(intf, &req);
+
+      if (!rsp)
+      {
+         printf("Error in FWUM Firmware Save Firmware Image Download Command\n");
+
+         out = 0;
+         status = KFWUM_STATUS_OK;
+         
+         /* With IOL, we don't receive "C7" on errors, instead we receive
+            nothing */
+         if(strstr(intf->name,"lan")!= NULL)
+         {
+            noResponse++;
+
+            if(noResponse < FWUM_SAVE_FIRMWARE_NO_RESPONSE_LIMIT )
+            {
+               (* pInBufLength) -= 1;
+               out = 0;
+            }
+            else
+            {
+               printf("Error, too many commands without response\n");
+               (* pInBufLength) = 0 ;               
+               out = 1;
+            }
+         } /* For other interface keep trying */
+      }
+      else if (rsp->ccode)
+      {
+         if(rsp->ccode == 0xc0)
+         {
+            status = KFWUM_STATUS_OK;
+            sleep(1);
+         }
+         else if(
+                  (rsp->ccode == 0xc7)
+                  ||
+                  (
+                     (rsp->ccode == 0xC3) &&
+                     (sequenceNumber == 0)
+                  )
+                )
+         {
+            (* pInBufLength) -= 1;
+            status = KFWUM_STATUS_OK;
+            retry = 1;
+         }
+         else if(rsp->ccode == 0x82)
+         {
+            /* Double sent, continue */
+            status = KFWUM_STATUS_OK;
+            out = 1;
+         }
+         else if(rsp->ccode == 0x83)
+         {
+            if(retry == 0)
+            {
+               retry = 1;
+               status = KFWUM_STATUS_OK;
+            }
+            else
+            {
+               status = KFWUM_STATUS_ERROR;
+               out = 1;
+            }
+         }
+         else if(rsp->ccode == 0xcf) /* Ok if receive duplicated request */
+         {
+            retry = 1;
+            status = KFWUM_STATUS_OK;
+         }
+         else if(rsp->ccode == 0xC3)
+         {
+            if(retry == 0)
+           {
+               retry = 1;
+               status = KFWUM_STATUS_OK;
+            }
+            else
+            {
+               status = KFWUM_STATUS_ERROR;
+               out = 1;
+            }
+         }
+         else
+         {
+            printf("FWUM Firmware Save Firmware Image Download returned %x\n",
+                                                                     rsp->ccode);
+            status = KFWUM_STATUS_ERROR;
+            out = 1;
+         }
+      }
+      else
+      {
+         out = 1;
+      }
+   }while(out == 0);
+   return status;
+}
+
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
+struct KfwumFinishFirmwareDownloadReq{
+   unsigned char versionMaj;
+   unsigned char versionMinSub;
+   unsigned char versionSdr;
+   unsigned char reserved;
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
+
+static tKFWUM_Status KfwumFinishFirmwareImage(struct ipmi_intf * intf,
+                                                 tKFWUM_InFirmwareInfo firmInfo)
+{
+   tKFWUM_Status status = KFWUM_STATUS_OK;
+   struct ipmi_rs * rsp;
+   struct ipmi_rq req;
+   struct KfwumFinishFirmwareDownloadReq thisReq;
+
+   thisReq.versionMaj     = firmInfo.versMajor;
+   thisReq.versionMinSub  = ((firmInfo.versMinor <<4) | firmInfo.versSubMinor);
+   thisReq.versionSdr     = firmInfo.sdrRev;
+   thisReq.reserved       = 0;
+   /* Byte 4 reserved, write 0 */
+
+   memset(&req, 0, sizeof(req));
+   req.msg.netfn = IPMI_NETFN_FIRMWARE;
+   req.msg.cmd = KFWUM_CMD_ID_FINISH_FIRMWARE_IMAGE;
+   req.msg.data = (unsigned char *) &thisReq;
+   req.msg.data_len = 4;
+   											       
+   do
+   {
+   	rsp = intf->sendrecv(intf, &req);
+   }while (rsp->ccode == 0xc0); 
+
+   if (!rsp)
+   {
+      printf("Error in FWUM Firmware Finish Firmware Image Download Command\n");
+      status = KFWUM_STATUS_ERROR;
+   }
+   else if (rsp->ccode)
+   {
+      printf("FWUM Firmware Finish Firmware Image Download returned %x\n",
+                                                                    rsp->ccode);
+      status = KFWUM_STATUS_ERROR;
+   }
+
+   return status;
+}
+
+
+#define FWUM_MAX_UPLOAD_RETRY 6
+static tKFWUM_Status KfwumUploadFirmware(struct ipmi_intf * intf,
+                               unsigned char * pBuffer, unsigned long totalSize)
+{
+   tKFWUM_Status status = KFWUM_STATUS_ERROR;
+   unsigned long address    = 0x0;
+   unsigned char writeSize;
+   unsigned char oldWriteSize;
+   unsigned long lastAddress = 0;
+   unsigned char sequenceNumber = 0;
+   unsigned char retry = FWUM_MAX_UPLOAD_RETRY;
+   unsigned char isLengthValid = 1;
+
+   do
+   {
+      writeSize = saveFirmwareInfo.bufferSize - saveFirmwareInfo.overheadSize;
+           
+      /* Reach the end */
+      if( address + writeSize > totalSize )
+      {
+         writeSize = (totalSize - address);
+      }
+      /* Reach boundary end */
+      else if(((address % KFWUM_PAGE_SIZE) + writeSize) > KFWUM_PAGE_SIZE)
+      {
+         writeSize = (KFWUM_PAGE_SIZE - (address % KFWUM_PAGE_SIZE));
+      }
+
+      oldWriteSize = writeSize;
+      status = KfwumSaveFirmwareImage(intf, sequenceNumber, address, 
+                                                &pBuffer[address], &writeSize);
+ 
+      if((status != KFWUM_STATUS_OK) && (retry-- != 0))
+      {
+         address = lastAddress;
+         status = KFWUM_STATUS_OK;
+      }
+      else if( writeSize == 0 )
+      {
+         status = KFWUM_STATUS_ERROR;     
+      }
+      else
+      {
+         if(writeSize != oldWriteSize)
+         {
+            printf("Adjusting length to %d bytes \n", writeSize);
+            saveFirmwareInfo.bufferSize -= (oldWriteSize - writeSize);
+         }
+         
+         retry = FWUM_MAX_UPLOAD_RETRY;
+         lastAddress = address;
+         address+= writeSize;
+      }
+
+      if(status == KFWUM_STATUS_OK)
+      {
+         if((address % 1024) == 0)
+         {
+            KfwumShowProgress((const unsigned char *)\
+                                 "Writting Firmware in Flash",address,totalSize);
+         }
+         sequenceNumber++;
+      }
+
+   }while((status == KFWUM_STATUS_OK) && (address < totalSize  ));
+
+   if(status == KFWUM_STATUS_OK)
+   {
+      KfwumShowProgress((const unsigned char *)\
+                                       "Writting Firmware in Flash", 100 , 100 );
+   }
+
+   return(status);
+}
+
+static tKFWUM_Status KfwumStartFirmwareUpgrade(struct ipmi_intf * intf)
+{
+   tKFWUM_Status status = KFWUM_STATUS_OK;
+   struct ipmi_rs * rsp;
+   struct ipmi_rq req;
+   unsigned char upgType = 0 ;  /* Upgrade type, wait BMC shutdown */
+
+   memset(&req, 0, sizeof(req));
+   req.msg.netfn = IPMI_NETFN_FIRMWARE;
+   req.msg.cmd = KFWUM_CMD_ID_START_FIRMWARE_UPDATE;
+   req.msg.data = (unsigned char *) &upgType;
+   req.msg.data_len = 1;
+
+   rsp = intf->sendrecv(intf, &req);
+
+   if (!rsp)
+   {
+      printf("Error in FWUM Firmware Start Firmware Upgrade Command\n");
+      status = KFWUM_STATUS_ERROR;
+   }
+   else if (rsp->ccode)
+   {
+      if(rsp->ccode == 0xd5)
+      {
+         printf("No firmware available for upgrade.  Download Firmware first\n");
+      }
+      else
+      {
+         printf("FWUM Firmware Start Firmware Upgrade returned %x\n",
+                                                                    rsp->ccode);
+      }
+      status = KFWUM_STATUS_ERROR;
+   }
+
+   return status;              
+}
+
+#define TRACE_LOG_CHUNK_COUNT 7
+#define TRACE_LOG_CHUNK_SIZE  7
+#define TRACE_LOG_ATT_COUNT   3
+/* String table */
+/* Must match eFWUM_CmdId */
+static const char* CMD_ID_STRING[] = {
+                "GetFwInfo",
+                "KickWatchdog",
+                "GetLastAnswer",
+                "BootHandshake",
+                "ReportStatus",
+                "CtrlIPMBLine",
+                "SetFwState",                
+                "GetFwStatus",
+                "GetSpiMemStatus",
+                "StartFwUpdate",
+                "StartFwImage",
+                "SaveFwImage",
+                "FinishFwImage",
+                "ReadFwImage",
+                "ManualRollback",
+                "GetTraceLog" };
+                
+static const char* EXT_CMD_ID_STRING[] = {
+                "FwUpgradeLock",
+                "ProcessFwUpg",
+                "ProcessFwRb",
+                "WaitHSAfterUpg",
+                "WaitFirstHSUpg",
+                "FwInfoStateChange" };
+               
+                
+static const char* CMD_STATE_STRING[] = {
+                "Invalid",
+                "Begin",
+                "Progress",
+                "Completed" };
+
+
+static tKFWUM_Status KfwumGetTraceLog(struct ipmi_intf * intf)
+{
+   tKFWUM_Status status = KFWUM_STATUS_OK;
+   struct ipmi_rs *rsp;
+   struct ipmi_rq req;
+   unsigned char  chunkIdx;
+   unsigned char  cmdIdx;
+
+   if(verbose)
+   {
+      printf(" Getting Trace Log!\n");
+   }
+   
+   for( chunkIdx = 0; (chunkIdx < TRACE_LOG_CHUNK_COUNT) && (status == KFWUM_STATUS_OK); chunkIdx++ )
+   {
+      /* Retreive each log chunk and print it */
+      memset(&req, 0, sizeof(req));
+      req.msg.netfn = IPMI_NETFN_FIRMWARE;
+      req.msg.cmd = KFWUM_CMD_ID_GET_TRACE_LOG;
+      req.msg.data = &chunkIdx;
+      req.msg.data_len = 1;
+
+      rsp = intf->sendrecv(intf, &req);
+      
+      if (!rsp)
+      {
+         printf("Error in FWUM Firmware Get Trace Log Command\n");
+         status = KFWUM_STATUS_ERROR;
+      }
+      else if (rsp->ccode)
+      {
+         printf("FWUM Firmware Get Trace Log returned %x\n", rsp->ccode);
+         status = KFWUM_STATUS_ERROR;
+      } 
+
+      if(status == KFWUM_STATUS_OK)
+      {
+         for (cmdIdx=0; cmdIdx < TRACE_LOG_CHUNK_SIZE; cmdIdx++)
+         {
+            /* Don't diplay commands with an invalid state */
+            if ( (rsp->data[TRACE_LOG_ATT_COUNT*cmdIdx+1] != 0) && 
+                 (rsp->data[TRACE_LOG_ATT_COUNT*cmdIdx] < KFWUM_CMD_ID_STD_MAX_CMD))
+            {
+               printf("  Cmd ID: %17s -- CmdState: %10s -- CompCode: %2x\n", 
+                                             CMD_ID_STRING[rsp->data[TRACE_LOG_ATT_COUNT*cmdIdx]],
+                                             CMD_STATE_STRING[rsp->data[TRACE_LOG_ATT_COUNT*cmdIdx+1]],
+                                             rsp->data[TRACE_LOG_ATT_COUNT*cmdIdx+2]);
+            }
+            else if ( (rsp->data[TRACE_LOG_ATT_COUNT*cmdIdx+1] != 0) && 
+                      (rsp->data[TRACE_LOG_ATT_COUNT*cmdIdx] >= KFWUM_CMD_ID_EXTENDED_CMD))
+            {
+               printf("  Cmd ID: %17s -- CmdState: %10s -- CompCode: %2x\n", 
+                                             EXT_CMD_ID_STRING[rsp->data[TRACE_LOG_ATT_COUNT*cmdIdx] - KFWUM_CMD_ID_EXTENDED_CMD],
+                                             CMD_STATE_STRING[rsp->data[TRACE_LOG_ATT_COUNT*cmdIdx+1]],
+                                             rsp->data[TRACE_LOG_ATT_COUNT*cmdIdx+2]);
+            }
+         }
+      }
+   }    
+   printf("\n");
+   return status;
+}
+
+
+/*******************************************************************************
+* Function Name: KfwumGetInfoFromFirmware
+*
+* Description: This function retreive from the firmare the following info :
+*
+*              o Checksum
+*              o File size (expected)
+*              o Board Id
+*              o Device Id
+*
+* Restriction: None
+*
+* Input: char * fileName - File to get info from
+*
+* Output: pInfo - container that will hold all the informations gattered.
+*                 see structure for all details
+*
+* Global: None
+*
+* Return: IFWU_SUCCESS - file ok
+*         IFWU_ERROR   - file error
+*
+*******************************************************************************/
+#define IN_FIRMWARE_INFO_OFFSET_LOCATION           0x5a0
+#define IN_FIRMWARE_INFO_SIZE                      20
+#define IN_FIRMWARE_INFO_OFFSET_FILE_SIZE          0
+#define IN_FIRMWARE_INFO_OFFSET_CHECKSUM           4
+#define IN_FIRMWARE_INFO_OFFSET_BOARD_ID           6
+#define IN_FIRMWARE_INFO_OFFSET_DEVICE_ID          8
+#define IN_FIRMWARE_INFO_OFFSET_TABLE_VERSION      9
+#define IN_FIRMWARE_INFO_OFFSET_IMPLEMENT_REV      10
+#define IN_FIRMWARE_INFO_OFFSET_VERSION_MAJOR      11
+#define IN_FIRMWARE_INFO_OFFSET_VERSION_MINSUB     12
+#define IN_FIRMWARE_INFO_OFFSET_SDR_REV            13
+#define IN_FIRMWARE_INFO_OFFSET_IANA0              14
+#define IN_FIRMWARE_INFO_OFFSET_IANA1              15
+#define IN_FIRMWARE_INFO_OFFSET_IANA2              16
+
+#define KWUM_GET_BYTE_AT_OFFSET(pBuffer,os)            pBuffer[os]
+
+tKFWUM_Status KfwumGetInfoFromFirmware(unsigned char * pBuf,
+                         unsigned long bufSize,  tKFWUM_InFirmwareInfo * pInfo)
+{
+   tKFWUM_Status status = KFWUM_STATUS_ERROR;
+
+   if(bufSize >= (IN_FIRMWARE_INFO_OFFSET_LOCATION + IN_FIRMWARE_INFO_SIZE))
+   {
+      unsigned long offset = IN_FIRMWARE_INFO_OFFSET_LOCATION;
+
+      /* Now, fill the structure with read informations */
+      pInfo->checksum  =  (unsigned short)KWUM_GET_BYTE_AT_OFFSET(pBuf,
+                           offset+0+IN_FIRMWARE_INFO_OFFSET_CHECKSUM ) << 8;
+      pInfo->checksum |= (unsigned short)KWUM_GET_BYTE_AT_OFFSET(pBuf,
+                           offset+1+IN_FIRMWARE_INFO_OFFSET_CHECKSUM );
+
+
+      pInfo->sumToRemoveFromChecksum=
+         KWUM_GET_BYTE_AT_OFFSET(pBuf,
+                              offset+IN_FIRMWARE_INFO_OFFSET_CHECKSUM);
+
+      pInfo->sumToRemoveFromChecksum+=
+        KWUM_GET_BYTE_AT_OFFSET(pBuf ,
+                             offset+IN_FIRMWARE_INFO_OFFSET_CHECKSUM+1);
+
+      pInfo->fileSize  =
+         KWUM_GET_BYTE_AT_OFFSET(pBuf ,
+                              offset+IN_FIRMWARE_INFO_OFFSET_FILE_SIZE+0) << 24;
+      pInfo->fileSize |=
+         (unsigned long)KWUM_GET_BYTE_AT_OFFSET(pBuf,
+                              offset+IN_FIRMWARE_INFO_OFFSET_FILE_SIZE+1) << 16;
+      pInfo->fileSize |=
+         (unsigned long)KWUM_GET_BYTE_AT_OFFSET(pBuf,
+                              offset+IN_FIRMWARE_INFO_OFFSET_FILE_SIZE+2) << 8;
+      pInfo->fileSize |=
+         (unsigned long)KWUM_GET_BYTE_AT_OFFSET(pBuf,
+                              offset+IN_FIRMWARE_INFO_OFFSET_FILE_SIZE+3);
+
+      pInfo->boardId   =
+         KWUM_GET_BYTE_AT_OFFSET(pBuf,
+                              offset+IN_FIRMWARE_INFO_OFFSET_BOARD_ID+0) << 8;
+      pInfo->boardId  |=
+         KWUM_GET_BYTE_AT_OFFSET(pBuf,
+                              offset+IN_FIRMWARE_INFO_OFFSET_BOARD_ID+1);
+
+      pInfo->deviceId  =
+         KWUM_GET_BYTE_AT_OFFSET(pBuf,
+                              offset+IN_FIRMWARE_INFO_OFFSET_DEVICE_ID);
+
+      pInfo->tableVers     =
+         KWUM_GET_BYTE_AT_OFFSET(pBuf,
+                              offset+IN_FIRMWARE_INFO_OFFSET_TABLE_VERSION);
+      pInfo->implRev       =
+         KWUM_GET_BYTE_AT_OFFSET(pBuf,
+                              offset+IN_FIRMWARE_INFO_OFFSET_IMPLEMENT_REV);
+      pInfo->versMajor     =
+         (KWUM_GET_BYTE_AT_OFFSET(pBuf,
+                      offset+IN_FIRMWARE_INFO_OFFSET_VERSION_MAJOR)) & 0x0f;
+      pInfo->versMinor     =
+         (KWUM_GET_BYTE_AT_OFFSET(pBuf,
+                 offset+IN_FIRMWARE_INFO_OFFSET_VERSION_MINSUB)>>4) & 0x0f;
+      pInfo->versSubMinor  =
+         (KWUM_GET_BYTE_AT_OFFSET(pBuf,
+                    offset+IN_FIRMWARE_INFO_OFFSET_VERSION_MINSUB)) & 0x0f;
+      pInfo->sdrRev        =
+         KWUM_GET_BYTE_AT_OFFSET(pBuf,
+                              offset+IN_FIRMWARE_INFO_OFFSET_SDR_REV);
+      pInfo->iana  =
+         KWUM_GET_BYTE_AT_OFFSET(pBuf ,
+                              offset+IN_FIRMWARE_INFO_OFFSET_IANA2) << 16;
+      pInfo->iana |=
+         (unsigned long)KWUM_GET_BYTE_AT_OFFSET(pBuf,
+                              offset+IN_FIRMWARE_INFO_OFFSET_IANA1) << 8;
+      pInfo->iana |=
+         (unsigned long)KWUM_GET_BYTE_AT_OFFSET(pBuf,
+                              offset+IN_FIRMWARE_INFO_OFFSET_IANA0);
+
+      KfwumFixTableVersionForOldFirmware(pInfo);
+
+      status = KFWUM_STATUS_OK;
+   }
+   return(status);
+}
+
+
+void KfwumFixTableVersionForOldFirmware(tKFWUM_InFirmwareInfo * pInfo)
+{
+   switch(pInfo->boardId)
+   {
+      case KFWUM_BOARD_KONTRON_UNKNOWN:
+         pInfo->tableVers = 0xff;
+      break;
+      default:
+         /* pInfo->tableVers is already set for the right version */
+      break;
+   }
+}
+
+
+tKFWUM_Status KfwumValidFirmwareForBoard(tKFWUM_BoardInfo boardInfo,
+                                                tKFWUM_InFirmwareInfo firmInfo)
+{
+   tKFWUM_Status status = KFWUM_STATUS_OK;
+
+   if(boardInfo.iana != firmInfo.iana)
+   {
+      printf("Board IANA does not match firmware IANA\n");
+      status = KFWUM_STATUS_ERROR;
+   }
+
+   if(boardInfo.boardId != firmInfo.boardId)
+   {
+      printf("Board IANA does not match firmware IANA\n");
+      status = KFWUM_STATUS_ERROR;
+   }
+
+
+   if(status == KFWUM_STATUS_ERROR)
+   {
+      printf("Firmware invalid for target board.  Download of upgrade aborted\n");
+   }
+   return status;
+}
+
+
+static void KfwumOutputInfo(tKFWUM_BoardInfo boardInfo,
+                                                tKFWUM_InFirmwareInfo firmInfo)
+{
+   printf("Target Board Id            : %u\n",boardInfo.boardId);
+   printf("Target IANA number         : %u\n",boardInfo.iana);
+   printf("File Size                  : %lu bytes\n",firmInfo.fileSize);
+   printf("Firmware Version           : %d.%d%d SDR %d\n",firmInfo.versMajor,
+                   firmInfo.versMinor, firmInfo.versSubMinor, firmInfo.sdrRev);
+}
diff --git a/lib/ipmi_hpmfwupg.c b/lib/ipmi_hpmfwupg.c
index 848aafd..fbcec9e 100644
--- a/lib/ipmi_hpmfwupg.c
+++ b/lib/ipmi_hpmfwupg.c
@@ -6,7 +6,7 @@
  * modification, are permitted provided that the following conditions
  * are met:
  *
- * Redistribution of source code must retain the above copyright       
+ * Redistribution of source code must retain the above copyright
  * notice, this list of conditions and the following disclaimer.
  *
  * Redistribution in binary form must reproduce the above copyright
@@ -35,7 +35,7 @@
 #include <ipmitool/ipmi_mc.h>
 #include <ipmitool/ipmi_hpmfwupg.h>
 #include <ipmitool/helper.h>
-#include <ipmitool/ipmi_strings.h> 
+#include <ipmitool/ipmi_strings.h>
 #include <ipmitool/log.h>
 #include "../src/plugins/lan/md5.h"
 #include <stdio.h>
@@ -49,41 +49,42 @@
 *
 *       Copyright (c) 2006 Kontron Canada, Inc.  All Rights Reserved.
 *
-*                              HPM.1 
+*                              HPM.1
 *                    Hardware Platform Management
 *              IPM Controller Firmware Upgrade Procedure
 *
 *  This module implements an Upgrade Agent for the IPM Controller
 *  Firmware Upgrade Procedure (HPM.1) specification version 1.0.
 *
-* author: 
+* author:
 * Frederic.Lelievre@ca.kontron.com
 * Francois.Isabelle@ca.kontron.com
 * Jean-Michel.Audet@ca.kontron.com
+* MarieJosee.Blais@ca.kontron.com
 *
 *****************************************************************************
 *
 * HISTORY
 * ===========================================================================
-* 2007-01-11 
+* 2007-01-11
 *
 *  - Incremented to version 0.2
 *  - Added lan packet size reduction mechanism to workaround fact
 *    that lan iface will not return C7 on excessive length
 *  - Fixed some typos
 *  - now uses lprintf()
-* 
-* - Incremented to version 0.3    
+*
+* - Incremented to version 0.3
 * - added patch for openipmi si driver V39 (send message in driver does not
 *    retry on 82/83 completion code and return 82/83 as response from target
 *    [conditionnaly built with ENABLE_OPENIPMI_V39_PATCH]
 *
 *    see: ipmi-fix-send-msg-retry.pacth in openipmi-developer mailing list
 *
-* 2007-01-16 
+* 2007-01-16
 *
 *  - Incremented to version 0.4
-*  - Fixed lan iface inaccesiblity timeout handling. Waiting for firmware 
+*  - Fixed lan iface inaccesiblity timeout handling. Waiting for firmware
 *    activation completion (fixed sleep) before re-opening a session and
 *    get the final firmware upgrade status.
 *  - Fixed some user interface stuff.
@@ -98,20 +99,53 @@
 *  - Modified the display of upgrade of Firmware version.
 *  - Added new options like "check" and "component" and "all" to hpm commands.
 *  - By default we skip the upgrade if we have the same firmware version
-*    as compared to the Image file (*.hpm).This will ensure that user does 
+*    as compared to the Image file (*.hpm).This will ensure that user does
 *    not update the target incase its already been updated
 *
 * 2008-01-25
 *  - Reduce buffer length more aggressively when no response from iol.
 *  - Incremented version to 1.02
 *
+*  2009-02-11
+*  - With multi-component HPM file, if one component need to be skipped because
+*    the component is already up-to-date,  ipmitool sends "Initiate upgrade
+*    action / Upload for upgrade" anyway.
+*
+*    If the component needs to be skipped, ipmitool will not send "Initiate
+*    upgrade action / Upload for upgrade"
+*
+*  - Incremented version to 1.03
+*
+*  2009-02-11
+*  - Fixed side effect introduced by last version, "forced" update didn't
+*    work anymore
+*  - Incremented version to 1.04
+*
+*  2009-03-25
+*  - Fix the case where ipmitool loses the iol connection during the upload
+*    block process.  Once IPMITool was successfully sent the first byte,
+*    IPMITool will not resize the block size.
+*
+*  2009-03-26
+*  - Fix the problem when we try to upgrade specific component and the component
+*     is already updated, IPMITool sends a "prepare action"  but IPMITool skips
+*     the upload firmware block process. 
+*     So, if we specify a specific component, we want to force to upload this 
+*     specific component.
+*  - Incremented version to 1.05
+*
+* 2009-04-20
+*  - Reworked previous update, when 'component' is specified, the other 
+*    components are now skipped.
+*  - Incremented version to 1.06
+*
 * ===========================================================================
 * TODO
 * ===========================================================================
 * 2007-01-11
 * - Add interpretation of GetSelftestResults
 * - Add interpretation of component ID string
-* 
+*
 *****************************************************************************/
 
 extern int verbose;
@@ -119,18 +153,18 @@ extern int verbose;
 /*
  *  Agent version
  */
-#define HPMFWUPG_VERSION_MAJOR    1 
+#define HPMFWUPG_VERSION_MAJOR    1
 #define HPMFWUPG_VERSION_MINOR    0
-#define HPMFWUPG_VERSION_SUBMINOR 2
+#define HPMFWUPG_VERSION_SUBMINOR 8
 
-/* 
+/*
  *  HPM.1 FIRMWARE UPGRADE COMMANDS (part of PICMG)
  */
 
 #define HPMFWUPG_GET_TARGET_UPG_CAPABILITIES 0x2E
-#define HPMFWUPG_GET_COMPONENT_PROPERTIES    0x2F  
-#define HPMFWUPG_ABORT_UPGRADE               0x30  
-#define HPMFWUPG_INITIATE_UPGRADE_ACTION     0x31  
+#define HPMFWUPG_GET_COMPONENT_PROPERTIES    0x2F
+#define HPMFWUPG_ABORT_UPGRADE               0x30
+#define HPMFWUPG_INITIATE_UPGRADE_ACTION     0x31
 #define HPMFWUPG_UPLOAD_FIRMWARE_BLOCK       0x32
 #define HPMFWUPG_FINISH_FIRMWARE_UPLOAD      0x33
 #define HPMFWUPG_GET_UPGRADE_STATUS          0x34
@@ -157,12 +191,12 @@ extern int verbose;
 #define HPMFWUPG_FW_MISMATCH          0x83
 #define HPMFWUPG_ROLLBACK_DENIED      0x83
 
-/* 
+/*
  * This error code is used as a temporary PATCH to
  * the latest Open ipmi driver.  This PATCH
  * will be removed once a new Open IPMI driver is released.
  * (Buggy version = 39)
- */ 
+ */
 #define ENABLE_OPENIPMI_V39_PATCH
 
 #ifdef ENABLE_OPENIPMI_V39_PATCH
@@ -172,12 +206,12 @@ extern int verbose;
 static int errorCount;
 
 #define HPMFWUPG_IS_RETRYABLE(error)                                          \
-((((error==0x83)||(error==0x82)) && (errorCount++<RETRY_COUNT_MAX))?TRUE:FALSE)
+((((error==0x83)||(error==0x82)||(error==0x80)) && (errorCount++<RETRY_COUNT_MAX))?TRUE:FALSE)
 #else
 #define HPMFWUPG_IS_RETRYABLE(error) FALSE
 #endif
 
-/* 
+/*
  *  HPM FIRMWARE UPGRADE GENERAL DEFINITIONS
  */
 
@@ -200,10 +234,10 @@ typedef enum eHpmfwupgComponentId
    HPMFWUPG_COMPONENT_ID_6,
    HPMFWUPG_COMPONENT_ID_7,
    HPMFWUPG_COMPONENT_ID_MAX
-} tHpmfwupgComponentId;   
+} tHpmfwupgComponentId;
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgComponentBitMask
 {
@@ -225,17 +259,17 @@ struct HpmfwupgComponentBitMask
          unsigned char component0 : 1;
          unsigned char component1 : 1;
          unsigned char component2 : 1;
-         unsigned char component3 : 1;      
+         unsigned char component3 : 1;
          unsigned char component4 : 1;
          unsigned char component5 : 1;
          unsigned char component6 : 1;
          unsigned char component7 : 1;
          #endif
-      }bitField;
-   }ComponentBits;
+      }ATTRIBUTE_PACKING bitField;
+   }ATTRIBUTE_PACKING ComponentBits;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
 
@@ -246,23 +280,23 @@ static const int HPMFWUPG_UPLOAD_BLOCK_LENGTH  = 1;
 static const int HPMFWUPG_UPLOAD_RETRY         = 2;
 
 
-/* 
+/*
  *  TARGET UPGRADE CAPABILITIES DEFINITIONS
  */
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgGetTargetUpgCapabilitiesReq
 {
    unsigned char picmgId;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgGetTargetUpgCapabilitiesResp
 {
@@ -278,7 +312,7 @@ struct HpmfwupgGetTargetUpgCapabilitiesResp
          unsigned char autRollbackOverride : 1;
          unsigned char ipmcDegradedDurinUpg: 1;
          unsigned char deferActivation     : 1;
-         unsigned char servAffectDuringUpg : 1;         
+         unsigned char servAffectDuringUpg : 1;
          unsigned char manualRollback      : 1;
          unsigned char autRollback         : 1;
          unsigned char ipmcSelftestCap     : 1;
@@ -288,51 +322,51 @@ struct HpmfwupgGetTargetUpgCapabilitiesResp
          unsigned char manualRollback      : 1;
          unsigned char servAffectDuringUpg : 1;
          unsigned char deferActivation     : 1;
-         unsigned char ipmcDegradedDurinUpg: 1;      
-         unsigned char autRollbackOverride : 1;      
+         unsigned char ipmcDegradedDurinUpg: 1;
+         unsigned char autRollbackOverride : 1;
          unsigned char fwUpgUndesirable    : 1;
          #endif
-      }bitField;
-   }GlobalCapabilities;
+      }ATTRIBUTE_PACKING bitField;
+   }ATTRIBUTE_PACKING GlobalCapabilities;
    unsigned char upgradeTimeout;
    unsigned char selftestTimeout;
    unsigned char rollbackTimeout;
    unsigned char inaccessTimeout;
    struct HpmfwupgComponentBitMask componentsPresent;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgGetTargetUpgCapabilitiesCtx
 {
    struct HpmfwupgGetTargetUpgCapabilitiesReq  req;
    struct HpmfwupgGetTargetUpgCapabilitiesResp resp;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-/* 
+/*
  *  COMPONENT PROPERTIES DEFINITIONS
  */
- 
+
 typedef enum eHpmfwupgCompPropertiesSelect
 {
    HPMFWUPG_COMP_GEN_PROPERTIES = 0,
-   HPMFWUPG_COMP_CURRENT_VERSION, 
+   HPMFWUPG_COMP_CURRENT_VERSION,
    HPMFWUPG_COMP_DESCRIPTION_STRING,
    HPMFWUPG_COMP_ROLLBACK_FIRMWARE_VERSION,
    HPMFWUPG_COMP_DEFERRED_FIRMWARE_VERSION,
    HPMFWUPG_COMP_RESERVED,
-   HPMFWUPG_COMP_OEM_PROPERTIES = 192   
-} tHpmfwupgCompPropertiesSelect; 
+   HPMFWUPG_COMP_OEM_PROPERTIES = 192
+} tHpmfwupgCompPropertiesSelect;
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgGetComponentPropertiesReq
 {
@@ -340,14 +374,14 @@ struct HpmfwupgGetComponentPropertiesReq
    unsigned char componentId;
    unsigned char selector;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
-struct HpmfwupgGetGeneralPropResp 
+struct HpmfwupgGetGeneralPropResp
 {
    unsigned char picmgId;
    union
@@ -356,7 +390,7 @@ struct HpmfwupgGetGeneralPropResp
       struct
       {
       	#if WORDS_BIGENDIAN
-         unsigned char reserved           : 2;      
+         unsigned char reserved           : 2;
          unsigned char payloadColdReset   : 1;
          unsigned char deferredActivation : 1;
          unsigned char comparisonSupport  : 1;
@@ -370,79 +404,79 @@ struct HpmfwupgGetGeneralPropResp
          unsigned char payloadColdReset   : 1;
          unsigned char reserved           : 2;
          #endif
-      }bitfield;
-   }GeneralCompProperties;
+      }ATTRIBUTE_PACKING bitfield;
+   }ATTRIBUTE_PACKING GeneralCompProperties;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
-struct HpmfwupgGetCurrentVersionResp 
+struct HpmfwupgGetCurrentVersionResp
 {
    unsigned char picmgId;
    unsigned char currentVersion[HPMFWUPG_VERSION_SIZE];
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
-struct HpmfwupgGetDescStringResp 
+struct HpmfwupgGetDescStringResp
 {
    unsigned char picmgId;
    char descString[HPMFWUPG_DESC_STRING_LENGTH];
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
-struct HpmfwupgGetRollbackFwVersionResp 
+struct HpmfwupgGetRollbackFwVersionResp
 {
    unsigned char picmgId;
    unsigned char rollbackFwVersion[HPMFWUPG_VERSION_SIZE];
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
-struct HpmfwupgGetDeferredFwVersionResp 
+struct HpmfwupgGetDeferredFwVersionResp
 {
    unsigned char picmgId;
    unsigned char deferredFwVersion[HPMFWUPG_VERSION_SIZE];
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-/* 
+/*
  * GetComponentProperties - OEM properties (192)
  */
 #define HPMFWUPG_OEM_LENGTH         4
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
-struct HpmfwupgGetOemProperties 
+struct HpmfwupgGetOemProperties
 {
    unsigned char picmgId;
    unsigned char oemRspData[HPMFWUPG_OEM_LENGTH];
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgGetComponentPropertiesResp
 {
@@ -454,63 +488,63 @@ struct HpmfwupgGetComponentPropertiesResp
       struct HpmfwupgGetRollbackFwVersionResp rollbackFwVersionResp;
       struct HpmfwupgGetDeferredFwVersionResp deferredFwVersionResp;
       struct HpmfwupgGetOemProperties         oemProperties;
-   }Response;
+   }ATTRIBUTE_PACKING Response;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgGetComponentPropertiesCtx
 {
    struct HpmfwupgGetComponentPropertiesReq  req;
    struct HpmfwupgGetComponentPropertiesResp resp;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
 
-/* 
+/*
  *  ABORT UPGRADE DEFINITIONS
  */
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgAbortUpgradeReq
 {
    unsigned char picmgId;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgAbortUpgradeResp
 {
    unsigned char picmgId;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgAbortUpgradeCtx
 {
    struct HpmfwupgAbortUpgradeReq  req;
    struct HpmfwupgAbortUpgradeResp resp;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-/* 
+/*
  * UPGRADE ACTIONS DEFINITIONS
  */
 typedef enum eHpmfwupgUpgradeAction
@@ -522,8 +556,8 @@ typedef enum eHpmfwupgUpgradeAction
    HPMFWUPG_UPGRADE_ACTION_INVALID = 0xff
 }  tHpmfwupgUpgradeAction;
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgInitiateUpgradeActionReq
 {
@@ -531,45 +565,45 @@ struct HpmfwupgInitiateUpgradeActionReq
    struct HpmfwupgComponentBitMask componentsMask;
    unsigned char upgradeAction;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgInitiateUpgradeActionResp
 {
    unsigned char picmgId;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgInitiateUpgradeActionCtx
 {
    struct HpmfwupgInitiateUpgradeActionReq  req;
    struct HpmfwupgInitiateUpgradeActionResp resp;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-/* 
+/*
  *  UPLOAD FIRMWARE BLOCK DEFINITIONS
  */
 
-#define HPMFWUPG_SEND_DATA_COUNT_MAX   32
+#define HPMFWUPG_SEND_DATA_COUNT_MAX   256
 #define HPMFWUPG_SEND_DATA_COUNT_KCS   30
 #define HPMFWUPG_SEND_DATA_COUNT_LAN   25
 #define HPMFWUPG_SEND_DATA_COUNT_IPMB  26
 #define HPMFWUPG_SEND_DATA_COUNT_IPMBL 26
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgUploadFirmwareBlockReq
 {
@@ -577,32 +611,32 @@ struct HpmfwupgUploadFirmwareBlockReq
    unsigned char blockNumber;
    unsigned char data[HPMFWUPG_SEND_DATA_COUNT_MAX];
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgUploadFirmwareBlockResp
 {
   unsigned char picmgId;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgUploadFirmwareBlockCtx
 {
    struct HpmfwupgUploadFirmwareBlockReq  req;
    struct HpmfwupgUploadFirmwareBlockResp resp;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
 
@@ -612,8 +646,8 @@ struct HpmfwupgUploadFirmwareBlockCtx
 
 #define HPMFWUPG_IMAGE_SIZE_BYTE_COUNT 4
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgFinishFirmwareUploadReq
 {
@@ -621,88 +655,88 @@ struct HpmfwupgFinishFirmwareUploadReq
    unsigned char componentId;
    unsigned char imageLength[HPMFWUPG_IMAGE_SIZE_BYTE_COUNT];
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgFinishFirmwareUploadResp
 {
    unsigned char picmgId;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgFinishFirmwareUploadCtx
 {
    struct HpmfwupgFinishFirmwareUploadReq  req;
    struct HpmfwupgFinishFirmwareUploadResp resp;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
 /*
  *   ACTIVATE FW DEFINITIONS
  */
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgActivateFirmwareReq
 {
    unsigned char picmgId;
    unsigned char rollback_override;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgActivateFirmwareResp
 {
    unsigned char picmgId;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgActivateFirmwareCtx
 {
    struct HpmfwupgActivateFirmwareReq  req;
    struct HpmfwupgActivateFirmwareResp resp;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-                                                     
+
 /*
  *   GET UPGRADE STATUS DEFINITIONS
  */
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgGetUpgradeStatusReq
 {
    unsigned char picmgId;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgGetUpgradeStatusResp
 {
@@ -710,114 +744,114 @@ struct HpmfwupgGetUpgradeStatusResp
    unsigned char cmdInProcess;
    unsigned char lastCmdCompCode;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgGetUpgradeStatusCtx
 {
    struct HpmfwupgGetUpgradeStatusReq  req;
    struct HpmfwupgGetUpgradeStatusResp resp;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
-                         
+
 /*
  *   MANUAL FW ROLLBACK DEFINITIONS
  */
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgManualFirmwareRollbackReq
 {
    unsigned char picmgId;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgManualFirmwareRollbackResp
 {
    unsigned char picmgId;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 struct HpmfwupgManualFirmwareRollbackCtx
 {
    struct HpmfwupgManualFirmwareRollbackReq  req;
    struct HpmfwupgManualFirmwareRollbackResp resp;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
 /*
  *   QUERY ROLLBACK STATUS DEFINITIONS
  */
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgQueryRollbackStatusReq
 {
    unsigned char picmgId;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgQueryRollbackStatusResp
 {
    unsigned char picmgId;
    struct HpmfwupgComponentBitMask rollbackComp;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgQueryRollbackStatusCtx
 {
    struct HpmfwupgQueryRollbackStatusReq  req;
    struct HpmfwupgQueryRollbackStatusResp resp;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
 /*
  *   QUERY SELF TEST RESULT DEFINITIONS
  */
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct  HpmfwupgQuerySelftestResultReq
 {
    unsigned char picmgId;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct  HpmfwupgQuerySelftestResultResp
 {
@@ -825,24 +859,24 @@ struct  HpmfwupgQuerySelftestResultResp
    unsigned char result1;
    unsigned char result2;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgQuerySelftestResultCtx
 {
    struct HpmfwupgQuerySelftestResultReq  req;
    struct HpmfwupgQuerySelftestResultResp resp;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 /*
  *  HPM.1 IMAGE DEFINITIONS
- */ 
+ */
 
 #define HPMFWUPG_HEADER_SIGNATURE_LENGTH 8
 #define HPMFWUPG_MANUFATURER_ID_LENGTH   3
@@ -851,11 +885,11 @@ struct HpmfwupgQuerySelftestResultCtx
 #define HPMFWUPG_TIMEOUT_LENGTH          1
 #define HPMFWUPG_COMP_REVISION_LENGTH    2
 #define HPMFWUPG_FIRM_REVISION_LENGTH    6
-#define HPMFWUPG_IMAGE_HEADER_VERSION    0 
+#define HPMFWUPG_IMAGE_HEADER_VERSION    0
 #define HPMFWUPG_IMAGE_SIGNATURE "PICMGFWU"
- 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgImageHeader
 {
@@ -865,13 +899,13 @@ struct HpmfwupgImageHeader
   unsigned char  manId[HPMFWUPG_MANUFATURER_ID_LENGTH];
   unsigned char  prodId[HPMFWUPG_PRODUCT_ID_LENGTH];
   unsigned char  time[HPMFWUPG_TIME_LENGTH];
-  union	
+  union
   {
- 	 struct 
+ 	 struct
  	 {
  	 	#if WORDS_BIGENDIAN
  		unsigned char imageSelfTest   : 1;
-      unsigned char autRollback     : 1;      
+      unsigned char autRollback     : 1;
  	 	unsigned char manRollback     : 1;
  	 	unsigned char servAffected    : 1;
  	 	unsigned char reserved        : 4;
@@ -882,9 +916,9 @@ struct HpmfwupgImageHeader
       unsigned char autRollback     : 1;
  		unsigned char imageSelfTest   : 1;
  	 	#endif
- 	 }	bitField;
+ 	 } ATTRIBUTE_PACKING bitField;
 	 unsigned char byte;
-  }imageCapabilities;
+  }ATTRIBUTE_PACKING imageCapabilities;
   struct HpmfwupgComponentBitMask components;
   unsigned char  selfTestTimeout;
   unsigned char  rollbackTimeout;
@@ -893,15 +927,15 @@ struct HpmfwupgImageHeader
   unsigned char  firmRevision[HPMFWUPG_FIRM_REVISION_LENGTH];
   unsigned short oemDataLength;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
 
 #define HPMFWUPG_DESCRIPTION_LENGTH   21
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgActionRecord
 {
@@ -909,14 +943,14 @@ struct HpmfwupgActionRecord
    struct HpmfwupgComponentBitMask components;
    unsigned char  checksum;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
 #define HPMFWUPG_FIRMWARE_SIZE_LENGTH 4
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgFirmwareImage
 {
@@ -924,15 +958,16 @@ struct HpmfwupgFirmwareImage
    char          desc[HPMFWUPG_DESCRIPTION_LENGTH];
    unsigned char length[HPMFWUPG_FIRMWARE_SIZE_LENGTH];
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
-#ifdef PRAGMA_PACK
-#pramga pack(1)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
 #endif
 struct HpmfwupgUpgradeCtx
 {
+   struct HpmfwupgComponentBitMask compUpdateMask;
    unsigned int   imageSize;
    unsigned char* pImageData;
    unsigned char  componentId;
@@ -940,8 +975,8 @@ struct HpmfwupgUpgradeCtx
    struct HpmfwupgGetGeneralPropResp           genCompProp[HPMFWUPG_COMPONENT_ID_MAX];
    struct ipm_devid_rsp                        devId;
 } ATTRIBUTE_PACKING;
-#ifdef PRAGMA_PACK
-#pramga pack(0)
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
 #endif
 
 typedef enum eHpmfwupgActionType
@@ -963,25 +998,28 @@ typedef enum eHpmfwupgActionType
 /*
  *  Options added for user to check the version and to view both the FILE and TARGET Version
  */
-#define VERSIONCHECK_MODE                       0x01
-#define VIEW_MODE                               0x02
-#define DEBUG_MODE                              0x04
-#define FORCE_MODE_ALL                          0x08
-#define FORCE_MODE_COMPONENT                    0x10
-#define FORCE_MODE                              (FORCE_MODE_ALL|FORCE_MODE_COMPONENT)
+#define VERSIONCHECK_MODE             0x01
+#define VIEW_MODE                     0x02
+#define DEBUG_MODE                    0x04
+#define FORCE_MODE_ALL                0x08
+#define FORCE_MODE_COMPONENT          0x10
+#define FORCE_MODE                    (FORCE_MODE_ALL|FORCE_MODE_COMPONENT)
 
 typedef struct _VERSIONINFO
 {
-    int componentId;
-    int targetMajor;
-    int targetMinor;
-    int rollbackMajor;
-    int rollbackMinor;
-    int imageMajor;
-    int imageMinor;
-    int coldResetRequired;
-    int rollbackSupported;
-    int skipUpgrade;
+    unsigned char componentId;
+    unsigned char targetMajor;
+    unsigned char targetMinor;
+    unsigned char targetAux[4];
+    unsigned char rollbackMajor;
+    unsigned char rollbackMinor;
+    unsigned char rollbackAux[4];
+    unsigned char imageMajor;
+    unsigned char imageMinor;
+    unsigned char imageAux[4];
+    unsigned char coldResetRequired;
+    unsigned char rollbackSupported;
+    unsigned char skipUpgrade;
     char descString[15];
 }VERSIONINFO, *PVERSIONINFO;
 
@@ -994,43 +1032,43 @@ VERSIONINFO gVersionInfo[HPMFWUPG_COMPONENT_ID_MAX];
 
 
 
-static int HpmfwupgUpgrade(struct ipmi_intf *intf, char* imageFilename, int activate, int,int); 
+static int HpmfwupgUpgrade(struct ipmi_intf *intf, char* imageFilename, int activate, int,int);
 static int HpmfwupgValidateImageIntegrity(struct HpmfwupgUpgradeCtx* pFwupgCtx);
-static int HpmfwupgPreparationStage(    struct ipmi_intf *intf, 
+static int HpmfwupgPreparationStage(    struct ipmi_intf *intf,
                                         struct HpmfwupgUpgradeCtx* pFwupgCtx, int option);
-static int HpmfwupgUpgradeStage (       struct ipmi_intf *intf, 
+static int HpmfwupgUpgradeStage (       struct ipmi_intf *intf,
                                         struct HpmfwupgUpgradeCtx* pFwupgCtx, int compToUpload ,int option);
-static int HpmfwupgActivationStage(struct ipmi_intf *intf, 
+static int HpmfwupgActivationStage(struct ipmi_intf *intf,
                                   struct HpmfwupgUpgradeCtx* pFwupgCtx);
-static int HpmfwupgGetTargetUpgCapabilities(struct ipmi_intf *intf, 
+static int HpmfwupgGetTargetUpgCapabilities(struct ipmi_intf *intf,
                                              struct HpmfwupgGetTargetUpgCapabilitiesCtx* pCtx);
-static int HpmfwupgGetComponentProperties(struct ipmi_intf *intf, 
+static int HpmfwupgGetComponentProperties(struct ipmi_intf *intf,
                                           struct HpmfwupgGetComponentPropertiesCtx* pCtx);
-static int HpmfwupgQuerySelftestResult(struct ipmi_intf *intf, 
+static int HpmfwupgQuerySelftestResult(struct ipmi_intf *intf,
                                        struct HpmfwupgQuerySelftestResultCtx* pCtx,
                                        struct HpmfwupgUpgradeCtx* pFwupgCtx);
-static int HpmfwupgQueryRollbackStatus(struct ipmi_intf *intf, 
+static int HpmfwupgQueryRollbackStatus(struct ipmi_intf *intf,
                                        struct HpmfwupgQueryRollbackStatusCtx* pCtx,
                                        struct HpmfwupgUpgradeCtx* pFwupgCtx);
-static int HpmfwupgAbortUpgrade(struct ipmi_intf *intf, 
-                                struct HpmfwupgAbortUpgradeCtx* pCtx);    
-static int HpmfwupgInitiateUpgradeAction(struct ipmi_intf *intf, 
+static int HpmfwupgAbortUpgrade(struct ipmi_intf *intf,
+                                struct HpmfwupgAbortUpgradeCtx* pCtx);
+static int HpmfwupgInitiateUpgradeAction(struct ipmi_intf *intf,
                                          struct HpmfwupgInitiateUpgradeActionCtx* pCtx,
-                                         struct HpmfwupgUpgradeCtx* pFwupgCtx);  
-static int HpmfwupgUploadFirmwareBlock(struct ipmi_intf *intf, 
-                                       struct HpmfwupgUploadFirmwareBlockCtx* pCtx, 
+                                         struct HpmfwupgUpgradeCtx* pFwupgCtx);
+static int HpmfwupgUploadFirmwareBlock(struct ipmi_intf *intf,
+                                       struct HpmfwupgUploadFirmwareBlockCtx* pCtx,
                                        struct HpmfwupgUpgradeCtx* pFwupgCtx, int count ,
                                        unsigned int *pOffset, unsigned int *blockLen);
-static int HpmfwupgFinishFirmwareUpload(struct ipmi_intf *intf, 
+static int HpmfwupgFinishFirmwareUpload(struct ipmi_intf *intf,
                                         struct HpmfwupgFinishFirmwareUploadCtx* pCtx,
                                         struct HpmfwupgUpgradeCtx* pFwupgCtx);
-static int HpmfwupgActivateFirmware(struct ipmi_intf *intf, 
+static int HpmfwupgActivateFirmware(struct ipmi_intf *intf,
                                     struct HpmfwupgActivateFirmwareCtx* pCtx,
                                     struct HpmfwupgUpgradeCtx* pFwupgCtx);
-static int HpmfwupgGetUpgradeStatus(struct ipmi_intf *intf, 
-                                    struct HpmfwupgGetUpgradeStatusCtx* pCtxstruct, 
+static int HpmfwupgGetUpgradeStatus(struct ipmi_intf *intf,
+                                    struct HpmfwupgGetUpgradeStatusCtx* pCtxstruct,
                                     struct HpmfwupgUpgradeCtx* pFwupgCtx);
-static int HpmfwupgManualFirmwareRollback(struct ipmi_intf *intf, 
+static int HpmfwupgManualFirmwareRollback(struct ipmi_intf *intf,
                                           struct HpmfwupgManualFirmwareRollbackCtx* pCtx,
                                           struct HpmfwupgUpgradeCtx* pFwupgCtx);
 static void HpmfwupgPrintUsage(void);
@@ -1041,7 +1079,19 @@ static int HpmfwupgWaitLongDurationCmd(struct ipmi_intf *intf, struct HpmfwupgUp
 
 static struct ipmi_rs *  HpmfwupgSendCmd(struct ipmi_intf *intf, struct ipmi_rq req,
                                          struct HpmfwupgUpgradeCtx* pFwupgCtx);
-                                    
+
+
+static int HpmFwupgActionUploadFirmware
+(
+   struct HpmfwupgComponentBitMask components, 
+   struct HpmfwupgUpgradeCtx* pFwupgCtx,
+   unsigned char** pImagePtr,
+   int componentToUpload,
+   struct ipmi_intf *intf,
+   int option,
+   int* pFlagColdReset
+);
+
 /****************************************************************************
 *
 * Function Name:  HpmGetuserInput
@@ -1060,7 +1110,7 @@ int HpmGetUserInput(char *str)
         return 1;
     }
     return 0;
-}       
+}
 /****************************************************************************
 *
 * Function Name:  HpmDisplayLine
@@ -1084,10 +1134,10 @@ void HpmDisplayLine(char *s, int n)
 void HpmDisplayUpgradeHeader(int option)
 {
     printf("\n");
-    HpmDisplayLine("-",79 );
-    printf("|ID | Name      |    Versions           |    Upload Progress  | Upload| Image |\n");
-    printf("|   |           | Active| Backup| File  |0%%       50%%     100%%| Time  | Size  |\n");
-    printf("|---|-----------|-------|-------|-------||----+----+----+----||-------|-------|\n");
+    HpmDisplayLine("-",78 );
+    printf("|ID | Name      |                     Versions                        |  %%   |\n");
+    printf("|   |           |      Active     |      Backup     |      File       |      |\n");
+    printf("|---|-----------|-----------------|-----------------|-----------------|------|\n");    
 }
 
 /****************************************************************************
@@ -1098,60 +1148,57 @@ void HpmDisplayUpgradeHeader(int option)
 * every 5% of its completion.
 *
 *****************************************************************************/
-void HpmDisplayUpgrade( int skip, unsigned int totalSent, 
+void HpmDisplayUpgrade( int skip, unsigned int totalSent,
                         unsigned int displayFWLength,time_t timeElapsed)
 {
     int percent;
     static int old_percent=1;
-    if (skip) 
-    { 
-        printf("|       Skip        || --.-- | ----- |\n");
+    if (skip)
+    {
+        printf(" Skip |\n");
         return;
     }
     fflush(stdout);
-    
+
     percent = ((float)totalSent/displayFWLength)*100;
-    if (((percent % 5) == 0))
+    if (percent != old_percent)
     {
-        if (percent != old_percent) 
-        {
-            if ( percent == 0 ) printf("|");                
-            else if (percent == 100) printf("|");
-                 else printf(".");
-            old_percent = percent;
-        }
+        if ( percent == 0 ) printf("  0 %% |");
+        else if (percent == 100) printf("\b\b\b\b\b\b\b100 %% |\n");
+        else printf("\b\b\b\b\b\b\b%3d %% |", percent);
+           old_percent = percent;
     }
 
     if (totalSent== displayFWLength)
     {
         /* Display the time taken to complete the upgrade */
-        printf("| %02d.%02d | %05x |\n",timeElapsed/60,timeElapsed%60,totalSent);
+        printf("|   | Upload Time: %02d.%02d          | Image Size: %05x                        |\n",
+         timeElapsed/60,timeElapsed%60,totalSent);
     }
-}        
+}
 
 /****************************************************************************
 *
 * Function Name:  HpmDisplayVersionHeader
 *
-* Description: This function displays the information about version header 
+* Description: This function displays the information about version header
 *
 *****************************************************************************/
 int HpmDisplayVersionHeader(int mode)
 {
-
    if ( mode & IMAGE_VER)
    {
-        HpmDisplayLine("-",41 );
-        printf("|ID | Name      |        Versions       |\n");
-        printf("|   |           | Active| Backup| File  |\n");
-        HpmDisplayLine("-",41 );        
+        HpmDisplayLine("-",71 );
+        printf("|ID | Name      |                     Versions                        |\n");
+        printf("|   |           |     Active      |     Backup      |      File       |\n");
+        HpmDisplayLine("-",71 );
    }
    else
    {
-        HpmDisplayLine("-",33 );           
-        printf("|ID | Name      |    Versions   |\n");
-        printf("|   |           | Active| Backup|\n");
-        HpmDisplayLine("-",33 );        
+        HpmDisplayLine("-",53 );
+        printf("|ID | Name      |             Versions              |\n");
+        printf("|   |           |     Active      |     Backup      |\n");
+        HpmDisplayLine("-",53 );
    }
 }
 
@@ -1171,39 +1218,58 @@ int HpmDisplayVersion(int mode,VERSIONINFO *pVersion)
        * is more than required it does not give problem in displaying it
        */
       strncpy(descString,pVersion->descString,11);
-      /* 
-       * If the cold reset is required then we can display * on it 
+      /*
+       * If the cold reset is required then we can display * on it
        * so that user is aware that he needs to do payload power
        * cycle after upgrade
        */
       printf("|%c%-2d|%-11s|",pVersion->coldResetRequired?'*':' ',pVersion->componentId,descString);
 
-      if (mode & TARGET_VER)  
+      if (mode & TARGET_VER)
       {
               if (pVersion->targetMajor == 0xFF && pVersion->targetMinor == 0xFF)
-                printf(" --.-- |");
+                printf(" ---.-- -------- |");
               else
-                printf("%3d.%02x |",pVersion->targetMajor,pVersion->targetMinor);
-      
+                printf(" %3d.%02x %02X%02X%02X%02X |",
+                 pVersion->targetMajor,
+                 pVersion->targetMinor,
+                 pVersion->targetAux[0],
+                 pVersion->targetAux[1],
+                 pVersion->targetAux[2],
+                 pVersion->targetAux[3]
+                 );
+
               if (mode & ROLLBACK_VER)
               {
                     if (pVersion->rollbackMajor == 0xFF && pVersion->rollbackMinor == 0xFF)
-                        printf(" --.-- |");
+                        printf(" ---.-- -------- |");
                     else
-                        printf("%3d.%02x |",pVersion->rollbackMajor,pVersion->rollbackMinor);
+                        printf(" %3d.%02x %02X%02X%02X%02X |",
+                         pVersion->rollbackMajor,
+                         pVersion->rollbackMinor,
+                         pVersion->rollbackAux[0],
+                         pVersion->rollbackAux[1],
+                 	     pVersion->rollbackAux[2],
+                 	     pVersion->rollbackAux[3]);
               }
               else
               {
-                    printf(" --.-- |");
+                    printf(" ---.-- -------- |");
               }
       }
 
-      if (mode & IMAGE_VER)  
+      if (mode & IMAGE_VER)
       {
               if (pVersion->imageMajor == 0xFF && pVersion->imageMinor == 0xFF)
-                printf(" --.-- |");
+                printf(" ---.-- |");
               else
-                printf("%3d.%02x |",pVersion->imageMajor,pVersion->imageMinor);
+                printf(" %3d.%02x %02X%02X%02X%02X |",
+                 pVersion->imageMajor,
+                 pVersion->imageMinor,
+                 pVersion->imageAux[0],
+                 pVersion->imageAux[1],
+                 pVersion->imageAux[2],
+                 pVersion->imageAux[3]);
       }
 }
 
@@ -1220,7 +1286,7 @@ int HpmfwupgTargetCheck(struct ipmi_intf * intf, int option)
 {
     struct HpmfwupgUpgradeCtx  fwupgCtx;
     struct HpmfwupgGetTargetUpgCapabilitiesCtx targetCapCmd;
-    int    rc = HPMFWUPG_SUCCESS;   
+    int    rc = HPMFWUPG_SUCCESS;
     int    componentId = 0;
     int    flagColdReset = FALSE;
     struct ipm_devid_rsp devIdrsp;
@@ -1256,7 +1322,7 @@ int HpmfwupgTargetCheck(struct ipmi_intf * intf, int option)
                                                 val2str(buf2short(devIdrsp.manufacturer_id),ipmi_oem_info));
         HpmDisplayVersionHeader(TARGET_VER|ROLLBACK_VER);
     }
-    
+
     for ( componentId = HPMFWUPG_COMPONENT_ID_0; componentId < HPMFWUPG_COMPONENT_ID_MAX;
                      componentId++ )
     {
@@ -1302,6 +1368,14 @@ int HpmfwupgTargetCheck(struct ipmi_intf * intf, int option)
                 currentVersionResp.currentVersion[0];
             gVersionInfo[componentId].targetMinor = getCompProp.resp.Response.
                 currentVersionResp.currentVersion[1];
+            gVersionInfo[componentId].targetAux[0] = getCompProp.resp.Response.
+                currentVersionResp.currentVersion[2];
+            gVersionInfo[componentId].targetAux[1] = getCompProp.resp.Response.
+                currentVersionResp.currentVersion[3];
+            gVersionInfo[componentId].targetAux[2] = getCompProp.resp.Response.
+                currentVersionResp.currentVersion[4];
+            gVersionInfo[componentId].targetAux[3] = getCompProp.resp.Response.
+                currentVersionResp.currentVersion[5];                
             mode = TARGET_VER;
 
             if (gVersionInfo[componentId].rollbackSupported)
@@ -1316,14 +1390,22 @@ int HpmfwupgTargetCheck(struct ipmi_intf * intf, int option)
                       .Response.rollbackFwVersionResp.rollbackFwVersion[0];
                     gVersionInfo[componentId].rollbackMinor = getCompProp.resp
                       .Response.rollbackFwVersionResp.rollbackFwVersion[1];
+                    gVersionInfo[componentId].rollbackAux[0] = getCompProp.resp.Response.
+                     rollbackFwVersionResp.rollbackFwVersion[2];
+                    gVersionInfo[componentId].rollbackAux[1] = getCompProp.resp.Response.
+                     rollbackFwVersionResp.rollbackFwVersion[3];
+                    gVersionInfo[componentId].rollbackAux[2] = getCompProp.resp.Response.
+                     rollbackFwVersionResp.rollbackFwVersion[4];
+                    gVersionInfo[componentId].rollbackAux[3] = getCompProp.resp.Response.
+                     rollbackFwVersionResp.rollbackFwVersion[5];
                 }
                 mode |= ROLLBACK_VER;
             }
 
             if (gVersionInfo[componentId].coldResetRequired)
             {
-                /* 
-                 * If any of the component indicates that the Payload Cold reset is required 
+                /*
+                 * If any of the component indicates that the Payload Cold reset is required
                  * then set the flag
                  */
                 flagColdReset = TRUE;
@@ -1335,10 +1417,10 @@ int HpmfwupgTargetCheck(struct ipmi_intf * intf, int option)
             }
         }
     }
-    
+
     if (option & VIEW_MODE)
     {
-        HpmDisplayLine("-",33 );
+        HpmDisplayLine("-",53 );
         if (flagColdReset)
         {
             fflush(stdout);
@@ -1357,23 +1439,23 @@ int HpmfwupgTargetCheck(struct ipmi_intf * intf, int option)
 *              version 1.0
 *
 *****************************************************************************/
-int HpmfwupgUpgrade(struct ipmi_intf *intf, char* imageFilename, 
+int HpmfwupgUpgrade(struct ipmi_intf *intf, char* imageFilename,
                     int activate,int componentToUpload, int option)
 {
    int rc = HPMFWUPG_SUCCESS;
    struct HpmfwupgImageHeader imageHeader;
    struct HpmfwupgUpgradeCtx  fwupgCtx;
-   
+
    /*
     *  GET IMAGE BUFFER FROM FILE
     */
-    
+
    rc = HpmfwupgGetBufferFromFile(imageFilename, &fwupgCtx);
-   
+
    /*
     *  VALIDATE IMAGE INTEGRITY
-    */  
-    
+    */
+
    if ( rc == HPMFWUPG_SUCCESS )
    {
       printf("Validating firmware image integrity...");
@@ -1389,11 +1471,11 @@ int HpmfwupgUpgrade(struct ipmi_intf *intf, char* imageFilename,
          free(fwupgCtx.pImageData);
       }
    }
-   
+
    /*
     *  PREPARATION STAGE
     */
-   
+
    if ( rc == HPMFWUPG_SUCCESS )
    {
       printf("Performing preparation stage...");
@@ -1409,11 +1491,11 @@ int HpmfwupgUpgrade(struct ipmi_intf *intf, char* imageFilename,
          free(fwupgCtx.pImageData);
       }
    }
-   
+
    /*
     *  UPGRADE STAGE
     */
-    
+
    if ( rc == HPMFWUPG_SUCCESS )
    {
       if (option & VIEW_MODE)
@@ -1430,11 +1512,14 @@ int HpmfwupgUpgrade(struct ipmi_intf *intf, char* imageFilename,
       }
       else
       {
-          rc = HpmfwupgPreUpgradeCheck(intf, &fwupgCtx,componentToUpload,0);
-          if (rc == HPMFWUPG_SUCCESS )
-          {
-              rc = HpmfwupgUpgradeStage(intf, &fwupgCtx,componentToUpload,option);
-          }
+          rc = HpmfwupgPreUpgradeCheck(intf, &fwupgCtx,componentToUpload,option);
+			 if (rc == HPMFWUPG_SUCCESS )
+			 {
+				 if( verbose ) {
+					 printf("Component update mask : 0x%02x\n", fwupgCtx.compUpdateMask.ComponentBits.byte);
+				 }
+				 rc = HpmfwupgUpgradeStage(intf, &fwupgCtx,componentToUpload,option);
+			 }
       }
 
       if ( rc != HPMFWUPG_SUCCESS )
@@ -1442,7 +1527,7 @@ int HpmfwupgUpgrade(struct ipmi_intf *intf, char* imageFilename,
          free(fwupgCtx.pImageData);
       }
    }
-      
+
    /*
     *  ACTIVATION STAGE
     */
@@ -1455,7 +1540,7 @@ int HpmfwupgUpgrade(struct ipmi_intf *intf, char* imageFilename,
          free(fwupgCtx.pImageData);
       }
    }
-   
+
    if ( rc == HPMFWUPG_SUCCESS )
    {
       if (option & VIEW_MODE)
@@ -1473,16 +1558,16 @@ int HpmfwupgUpgrade(struct ipmi_intf *intf, char* imageFilename,
    {
       lprintf(LOG_NOTICE,"Firmware upgrade procedure failed\n");
    }
-      
+
    return rc;
-}                                         
- 
+}
+
 /****************************************************************************
 *
 * Function Name:  HpmfwupgValidateImageIntegrity
 *
 * Description: This function validates a HPM.1 firmware image file as defined
-*              in section 4 of the IPM Controller Firmware Upgrade 
+*              in section 4 of the IPM Controller Firmware Upgrade
 *              Specification version 1.0
 *
 *****************************************************************************/
@@ -1493,15 +1578,15 @@ int HpmfwupgValidateImageIntegrity(struct HpmfwupgUpgradeCtx* pFwupgCtx)
                                                          pFwupgCtx->pImageData;
    md5_state_t ctx;
 	static unsigned char md[HPMFWUPG_MD5_SIGNATURE_LENGTH];
-   unsigned char* pMd5Sig = pFwupgCtx->pImageData + 
-                           (pFwupgCtx->imageSize - 
+   unsigned char* pMd5Sig = pFwupgCtx->pImageData +
+                           (pFwupgCtx->imageSize -
                             HPMFWUPG_MD5_SIGNATURE_LENGTH);
-                                             
+
    /* Validate MD5 checksum */
    memset(md, 0, HPMFWUPG_MD5_SIGNATURE_LENGTH);
    memset(&ctx, 0, sizeof(md5_state_t));
    md5_init(&ctx);
-   md5_append(&ctx, pFwupgCtx->pImageData, pFwupgCtx->imageSize - 
+   md5_append(&ctx, pFwupgCtx->pImageData, pFwupgCtx->imageSize -
                                            HPMFWUPG_MD5_SIGNATURE_LENGTH);
    md5_finish(&ctx, md);
    if ( memcmp(md, pMd5Sig,HPMFWUPG_MD5_SIGNATURE_LENGTH) != 0 )
@@ -1509,7 +1594,7 @@ int HpmfwupgValidateImageIntegrity(struct HpmfwupgUpgradeCtx* pFwupgCtx)
       lprintf(LOG_NOTICE,"\n    Invalid MD5 signature");
       rc = HPMFWUPG_ERROR;
    }
-   
+
    if ( rc == HPMFWUPG_SUCCESS )
    {
       /* Validate Header signature */
@@ -1519,9 +1604,9 @@ int HpmfwupgValidateImageIntegrity(struct HpmfwupgUpgradeCtx* pFwupgCtx)
          if ( pImageHeader->formatVersion == HPMFWUPG_IMAGE_HEADER_VERSION )
          {
             /* Validate header checksum */
-            if ( HpmfwupgCalculateChecksum((unsigned char*)pImageHeader, 
-                                           sizeof(struct HpmfwupgImageHeader) + 
-                                           pImageHeader->oemDataLength + 
+            if ( HpmfwupgCalculateChecksum((unsigned char*)pImageHeader,
+                                           sizeof(struct HpmfwupgImageHeader) +
+                                           pImageHeader->oemDataLength +
                                            sizeof(unsigned char)/*checksum*/) != 0 )
             {
                lprintf(LOG_NOTICE,"\n    Invalid header checksum");
@@ -1541,14 +1626,14 @@ int HpmfwupgValidateImageIntegrity(struct HpmfwupgUpgradeCtx* pFwupgCtx)
       }
    }
    return rc;
-} 
+}
 
 /****************************************************************************
 *
 * Function Name:  HpmfwupgPreparationStage
 *
-* Description: This function the preperation stage of a firmware upgrade 
-*              procedure as defined in section 3.2 of the IPM Controller 
+* Description: This function the preperation stage of a firmware upgrade
+*              procedure as defined in section 3.2 of the IPM Controller
 *              Firmware Upgrade Specification version 1.0
 *
 *****************************************************************************/
@@ -1557,10 +1642,10 @@ int HpmfwupgPreparationStage(struct ipmi_intf *intf, struct HpmfwupgUpgradeCtx*
    int rc = HPMFWUPG_SUCCESS;
    struct HpmfwupgImageHeader* pImageHeader = (struct HpmfwupgImageHeader*)
                                                          pFwupgCtx->pImageData;
-   
+
    /* Get device ID */
    rc = HpmfwupgGetDeviceId(intf, &pFwupgCtx->devId);
-   
+
    /* Match current IPMC IDs with upgrade image */
    if ( rc == HPMFWUPG_SUCCESS )
    {
@@ -1571,21 +1656,21 @@ int HpmfwupgPreparationStage(struct ipmi_intf *intf, struct HpmfwupgUpgradeCtx*
          if ( memcmp(pImageHeader->prodId, pFwupgCtx->devId.product_id, HPMFWUPG_PRODUCT_ID_LENGTH ) == 0 )
          {
             /* Validate man ID */
-            if ( memcmp(pImageHeader->manId, pFwupgCtx->devId.manufacturer_id, 
+            if ( memcmp(pImageHeader->manId, pFwupgCtx->devId.manufacturer_id,
                                                      HPMFWUPG_MANUFATURER_ID_LENGTH ) != 0 )
             {
-               lprintf(LOG_NOTICE,"\n    Invalid image file for manufacturer %u", 
-                                      buf2short(pFwupgCtx->devId.manufacturer_id)); 
+               lprintf(LOG_NOTICE,"\n    Invalid image file for manufacturer %u",
+                                      buf2short(pFwupgCtx->devId.manufacturer_id));
                rc = HPMFWUPG_ERROR;
             }
          }
          else
          {
-            lprintf(LOG_NOTICE,"\n    Invalid image file for product %u", 
+            lprintf(LOG_NOTICE,"\n    Invalid image file for product %u",
                                             buf2short(pFwupgCtx->devId.product_id));
             rc = HPMFWUPG_ERROR;
          }
-      
+
       }
       else
       {
@@ -1595,7 +1680,7 @@ int HpmfwupgPreparationStage(struct ipmi_intf *intf, struct HpmfwupgUpgradeCtx*
 
       if (rc != HPMFWUPG_SUCCESS)
       {
-        /* 
+        /*
          * Giving one more chance to user to check whether its OK to continue even if the
          * product ID does not match. This is helpful as sometimes we just want to update
          * and dont care whether we have a different product Id. If the user says NO then
@@ -1606,12 +1691,12 @@ int HpmfwupgPreparationStage(struct ipmi_intf *intf, struct HpmfwupgUpgradeCtx*
             printf("\n    Image Information");
             printf("\n        Device Id : 0x%x",pImageHeader->deviceId);
             printf("\n        Prod   Id : 0x%02x%02x",pImageHeader->prodId[1], pImageHeader->prodId[0]);
-            printf("\n        Manuf  Id : 0x%02x%02x%02x",pImageHeader->manId[2], 
+            printf("\n        Manuf  Id : 0x%02x%02x%02x",pImageHeader->manId[2],
                             pImageHeader->manId[1],pImageHeader->manId[0]);
             printf("\n    Board Information");
             printf("\n        Device Id : 0x%x", pFwupgCtx->devId.device_id);
             printf("\n        Prod   Id : 0x%02x%02x",pFwupgCtx->devId.product_id[1], pFwupgCtx->devId.product_id[0]);
-            printf("\n        Manuf  Id : 0x%02x%02x%02x",pFwupgCtx->devId.manufacturer_id[2], 
+            printf("\n        Manuf  Id : 0x%02x%02x%02x",pFwupgCtx->devId.manufacturer_id[2],
                             pFwupgCtx->devId.manufacturer_id[1],pFwupgCtx->devId.manufacturer_id[0]);
             if (HpmGetUserInput("\n Continue ignoring DeviceID/ProductID/ManufacturingID (Y/N) :"))
                 rc = HPMFWUPG_SUCCESS;
@@ -1619,20 +1704,20 @@ int HpmfwupgPreparationStage(struct ipmi_intf *intf, struct HpmfwupgUpgradeCtx*
         else
         {
             /*
-             *  If you use all option its kind of FORCE command where we need to upgrade all the components 
+             *  If you use all option its kind of FORCE command where we need to upgrade all the components
              */
             printf("\n\n Use \"all\" option for uploading all the components\n");
         }
       }
    }
-   
+
    /* Validate earliest compatible revision */
    if ( rc == HPMFWUPG_SUCCESS )
    {
       /* Validate major & minor revision */
       if ( pImageHeader->compRevision[0] < pFwupgCtx->devId.fw_rev1 )
       {
-         /* Do nothing, upgrade accepted */            
+         /* Do nothing, upgrade accepted */
       }
       else if ( pImageHeader->compRevision[0] == pFwupgCtx->devId.fw_rev1 )
       {
@@ -1656,7 +1741,7 @@ int HpmfwupgPreparationStage(struct ipmi_intf *intf, struct HpmfwupgUpgradeCtx*
          lprintf(LOG_NOTICE,"    Not compatible with ");
          lprintf(LOG_NOTICE,"    Version: Major: %d", pFwupgCtx->devId.fw_rev1);
          lprintf(LOG_NOTICE,"             Minor: %x", pFwupgCtx->devId.fw_rev2);
-         rc = HPMFWUPG_ERROR;                                                     
+         rc = HPMFWUPG_ERROR;
       }
 
       if (rc != HPMFWUPG_SUCCESS)
@@ -1669,19 +1754,19 @@ int HpmfwupgPreparationStage(struct ipmi_intf *intf, struct HpmfwupgUpgradeCtx*
         }
      }
    }
-   
+
    /* Get target upgrade capabilities */
    if ( rc == HPMFWUPG_SUCCESS )
    {
       struct HpmfwupgGetTargetUpgCapabilitiesCtx targetCapCmd;
-   
+
       rc = HpmfwupgGetTargetUpgCapabilities(intf, &targetCapCmd);
-      
+
       if ( rc == HPMFWUPG_SUCCESS )
       {
          /* Copy response to context */
-         memcpy(&pFwupgCtx->targetCap, 
-                &targetCapCmd.resp, 
+         memcpy(&pFwupgCtx->targetCap,
+                &targetCapCmd.resp,
                 sizeof(struct HpmfwupgGetTargetUpgCapabilitiesResp));
 
          if (option & VIEW_MODE)
@@ -1690,7 +1775,7 @@ int HpmfwupgPreparationStage(struct ipmi_intf *intf, struct HpmfwupgUpgradeCtx*
          }
          else
          {
-             /* Make sure all component IDs defined in the upgrade  
+             /* Make sure all component IDs defined in the upgrade
                 image are supported by the IPMC */
              if ( (pImageHeader->components.ComponentBits.byte &
                    pFwupgCtx->targetCap.componentsPresent.ComponentBits.byte ) !=
@@ -1699,15 +1784,15 @@ int HpmfwupgPreparationStage(struct ipmi_intf *intf, struct HpmfwupgUpgradeCtx*
                 lprintf(LOG_NOTICE,"\n    Some components present in the image file are not supported by the IPMC");
                 rc = HPMFWUPG_ERROR;
              }
-             
+
              /* Make sure the upgrade is desirable rigth now */
              if ( pFwupgCtx->targetCap.GlobalCapabilities.bitField.fwUpgUndesirable == 1 )
              {
                 lprintf(LOG_NOTICE,"\n    Upgrade undesirable at this moment");
                 rc = HPMFWUPG_ERROR;
              }
-             
-             /* Get confimation from the user if he wants to continue when service 
+
+             /* Get confimation from the user if he wants to continue when service
                 affected during upgrade */
              if ( pFwupgCtx->targetCap.GlobalCapabilities.bitField.servAffectDuringUpg == 1 ||
                   pImageHeader->imageCapabilities.bitField.servAffected == 1 )
@@ -1724,34 +1809,34 @@ int HpmfwupgPreparationStage(struct ipmi_intf *intf, struct HpmfwupgUpgradeCtx*
          }
       }
    }
-   
+
    /* Get the general properties of each component present in image */
    if ( rc == HPMFWUPG_SUCCESS )
    {
       int componentId;
 
-      for ( componentId = HPMFWUPG_COMPONENT_ID_0; 
+      for ( componentId = HPMFWUPG_COMPONENT_ID_0;
             componentId < HPMFWUPG_COMPONENT_ID_MAX;
             componentId++ )
       {
          /* Reset component properties */
          memset(&pFwupgCtx->genCompProp[componentId], 0, sizeof (struct HpmfwupgGetGeneralPropResp));
-         
+
          if ( (1 << componentId & pImageHeader->components.ComponentBits.byte) )
          {
             struct HpmfwupgGetComponentPropertiesCtx getCompPropCmd;
-            
+
             /* Get general component properties */
             getCompPropCmd.req.componentId = componentId;
             getCompPropCmd.req.selector    = HPMFWUPG_COMP_GEN_PROPERTIES;
-            
+
             rc = HpmfwupgGetComponentProperties(intf, &getCompPropCmd);
-            
+
             if ( rc == HPMFWUPG_SUCCESS )
             {
                /* Copy response to context */
-               memcpy(&pFwupgCtx->genCompProp[componentId], 
-                      &getCompPropCmd.resp, 
+               memcpy(&pFwupgCtx->genCompProp[componentId],
+                      &getCompPropCmd.resp,
                       sizeof(struct HpmfwupgGetGeneralPropResp));
             }
          }
@@ -1780,36 +1865,36 @@ int HpmfwupgPreUpgradeCheck(struct ipmi_intf *intf, struct HpmfwupgUpgradeCtx* p
    int flagColdReset = FALSE;
    struct HpmfwupgImageHeader* pImageHeader = (struct HpmfwupgImageHeader*)
                                                          pFwupgCtx->pImageData;
-   
+
    /* Put pointer after image header */
-   pImagePtr = (unsigned char*) 
+   pImagePtr = (unsigned char*)
                (pFwupgCtx->pImageData + sizeof(struct HpmfwupgImageHeader) +
                 pImageHeader->oemDataLength + sizeof(unsigned char)/*checksum*/);
-            
-   /* Deternime actions size */            
-   actionsSize = pFwupgCtx->imageSize - sizeof(struct HpmfwupgImageHeader);   
-   
+
+   /* Deternime actions size */
+   actionsSize = pFwupgCtx->imageSize - sizeof(struct HpmfwupgImageHeader);
+
    if (option & VIEW_MODE)
    {
        HpmDisplayVersionHeader(TARGET_VER|ROLLBACK_VER|IMAGE_VER);
    }
 
    /* Perform actions defined in the image */
-   while( ( pImagePtr < (pFwupgCtx->pImageData + pFwupgCtx->imageSize - 
+   while( ( pImagePtr < (pFwupgCtx->pImageData + pFwupgCtx->imageSize -
             HPMFWUPG_MD5_SIGNATURE_LENGTH)) &&
           ( rc == HPMFWUPG_SUCCESS) )
    {
       /* Get action record */
       pActionRecord = (struct HpmfwupgActionRecord*)pImagePtr;
-      
+
       /* Validate action record checksum */
-      if ( HpmfwupgCalculateChecksum((unsigned char*)pActionRecord, 
+      if ( HpmfwupgCalculateChecksum((unsigned char*)pActionRecord,
                                      sizeof(struct HpmfwupgActionRecord)) != 0 )
       {
          lprintf(LOG_NOTICE,"    Invalid Action record.");
          rc = HPMFWUPG_ERROR;
       }
-      
+
       if ( rc == HPMFWUPG_SUCCESS )
       {
          switch( pActionRecord->actionType )
@@ -1844,17 +1929,19 @@ int HpmfwupgPreUpgradeCheck(struct ipmi_intf *intf, struct HpmfwupgUpgradeCtx* p
                unsigned char  componentId = 0x00;
                unsigned char  componentIdByte = 0x00;
                VERSIONINFO    *pVersionInfo;
-              
+
                struct HpmfwupgGetComponentPropertiesCtx getCompProp;
 
                /* Save component ID on which the upload is done */
                componentIdByte = pActionRecord->components.ComponentBits.byte;
+
                while ((componentIdByte>>=1)!=0)
                {
                     componentId++;
                }
                pFwupgCtx->componentId = componentId;
-               pFwImage = (struct HpmfwupgFirmwareImage*)(pImagePtr + 
+
+               pFwImage = (struct HpmfwupgFirmwareImage*)(pImagePtr +
                               sizeof(struct HpmfwupgActionRecord));
 
                pData = ((unsigned char*)pFwImage + sizeof(struct HpmfwupgFirmwareImage));
@@ -1866,10 +1953,14 @@ int HpmfwupgPreUpgradeCheck(struct ipmi_intf *intf, struct HpmfwupgUpgradeCtx* p
               firmwareLength |= (pFwImage->length[3] << 24) & 0xff000000;
 
               pVersionInfo = &gVersionInfo[componentId];
-              
-              pVersionInfo->imageMajor  = pFwImage->version[0];
-              pVersionInfo->imageMinor  = pFwImage->version[1];
-              
+
+              pVersionInfo->imageMajor   = pFwImage->version[0];
+              pVersionInfo->imageMinor   = pFwImage->version[1];
+              pVersionInfo->imageAux[0]  = pFwImage->version[2];
+              pVersionInfo->imageAux[1]  = pFwImage->version[3];
+              pVersionInfo->imageAux[2]  = pFwImage->version[4];
+              pVersionInfo->imageAux[3]  = pFwImage->version[5];
+
               mode = TARGET_VER | IMAGE_VER;
 
               if (pVersionInfo->coldResetRequired)
@@ -1878,33 +1969,73 @@ int HpmfwupgPreUpgradeCheck(struct ipmi_intf *intf, struct HpmfwupgUpgradeCtx* p
               }
               pVersionInfo->skipUpgrade = FALSE;
 
-              if (   (pVersionInfo->imageMajor == pVersionInfo->targetMajor)
-                  && (pVersionInfo->imageMinor == pVersionInfo->targetMinor))
+				  if (option & FORCE_MODE_ALL)
+				  {
+					  /* user has given all to upload all the components on the command line */
+					  if(verbose) {
+						  lprintf(LOG_NOTICE,"Forcing ALL components");
+					  }
+				  }		
+				  else if( option & FORCE_MODE_COMPONENT )
+				  {
+					  if( componentToUpload != componentId )
+					  {
+                    if(verbose) {
+                       lprintf(LOG_NOTICE,"Forcing component %d skip", componentId);
+                    }
+						  /* user has given the component Id to upload on the command line */
+						  pVersionInfo->skipUpgrade = TRUE;
+					  }
+					  else if(verbose)
+					  {
+						  lprintf(LOG_NOTICE,"Forcing component %d update", componentId);
+						  /* user has given the component Id to upload on the command line */
+					  }
+				  }
+				  else 
+				  {	
+					  if 
+					  ( 
+						  (pVersionInfo->imageMajor == pVersionInfo->targetMajor)
+						  && 
+						  (pVersionInfo->imageMinor == pVersionInfo->targetMinor))
+					  {
+						  if (pVersionInfo->rollbackSupported)
+						  {
+							  /*If the Image Versions are same as Target Versions then check for the
+								* rollback version*/
+							  if 
+							  (
+								  (pVersionInfo->imageMajor == pVersionInfo->rollbackMajor)
+								  && 
+								  (pVersionInfo->imageMinor == pVersionInfo->rollbackMinor)
+							  )
+							  {
+								  /* This indicates that the Rollback version is also same as
+									* Image version -- So now we must skip it */
+								  pVersionInfo->skipUpgrade = TRUE;
+							  }
+							  mode |= ROLLBACK_VER;
+						  }
+						  else
+						  {
+							  pVersionInfo->skipUpgrade = TRUE;
+						  }
+					  }
+		if ( verbose ) {
+			lprintf(LOG_NOTICE,"Component %d: %s", componentId , (pVersionInfo->skipUpgrade?"skipped":"to update"));
+		}
+				  }	
+              if( pVersionInfo->skipUpgrade == FALSE )
               {
-                  if (pVersionInfo->rollbackSupported)
-                  {
-                      /*If the Image Versions are same as Target Versions then check for the 
-                       * rollback version*/
-                      if (   (pVersionInfo->imageMajor == pVersionInfo->rollbackMajor)
-                          && (pVersionInfo->imageMinor == pVersionInfo->rollbackMinor))
-                      {
-                          /* This indicates that the Rollback version is also same as 
-                           * Image version -- So now we must skip it */
-                           pVersionInfo->skipUpgrade = TRUE;
-                      }
-                      mode |= ROLLBACK_VER;
-                  }
-                  else
-                  {
-                      pVersionInfo->skipUpgrade = TRUE;
-                  }
+                 pFwupgCtx->compUpdateMask.ComponentBits.byte |= 1<<componentId;
               }
-               if (option & VIEW_MODE)
-               {
-                    HpmDisplayVersion(mode,pVersionInfo);
-                    printf("\n");
-                }
-               pImagePtr = pData + firmwareLength;
+              if (option & VIEW_MODE)
+              {
+                 HpmDisplayVersion(mode,pVersionInfo);
+                 printf("\n");
+              } 
+              pImagePtr = pData + firmwareLength;
             }
             break;
             default:
@@ -1916,7 +2047,7 @@ int HpmfwupgPreUpgradeCheck(struct ipmi_intf *intf, struct HpmfwupgUpgradeCtx* p
    }
    if (option & VIEW_MODE)
    {
-        HpmDisplayLine("-",41);
+        HpmDisplayLine("-",71);
        if (flagColdReset)
        {
            fflush(stdout);
@@ -1931,8 +2062,8 @@ int HpmfwupgPreUpgradeCheck(struct ipmi_intf *intf, struct HpmfwupgUpgradeCtx* p
 *
 * Function Name:  HpmfwupgUpgradeStage
 *
-* Description: This function the upgrade stage of a firmware upgrade 
-*              procedure as defined in section 3.3 of the IPM Controller 
+* Description: This function the upgrade stage of a firmware upgrade
+*              procedure as defined in section 3.3 of the IPM Controller
 *              Firmware Upgrade Specification version 1.0
 *
 *****************************************************************************/
@@ -1941,7 +2072,6 @@ int HpmfwupgUpgradeStage(struct ipmi_intf *intf, struct HpmfwupgUpgradeCtx* pFwu
 {
    struct HpmfwupgImageHeader* pImageHeader = (struct HpmfwupgImageHeader*)
                                                          pFwupgCtx->pImageData;
-   struct HpmfwupgComponentBitMask componentToUploadMsk;   
    struct HpmfwupgActionRecord* pActionRecord;
 
    int              rc = HPMFWUPG_SUCCESS;
@@ -1951,13 +2081,12 @@ int HpmfwupgUpgradeStage(struct ipmi_intf *intf, struct HpmfwupgUpgradeCtx* pFwu
    time_t           start,end;
 
    /* Put pointer after image header */
-   pImagePtr = (unsigned char*) 
+   pImagePtr = (unsigned char*)
                (pFwupgCtx->pImageData + sizeof(struct HpmfwupgImageHeader) +
                 pImageHeader->oemDataLength + sizeof(unsigned char)/*checksum*/);
-            
-   /* Deternime actions size */            
-   actionsSize = pFwupgCtx->imageSize - sizeof(struct HpmfwupgImageHeader);   
-   
+
+   /* Deternime actions size */
+   actionsSize = pFwupgCtx->imageSize - sizeof(struct HpmfwupgImageHeader);
 
    if (option & VERSIONCHECK_MODE || option & FORCE_MODE)
    {
@@ -1965,21 +2094,21 @@ int HpmfwupgUpgradeStage(struct ipmi_intf *intf, struct HpmfwupgUpgradeCtx* pFwu
    }
 
    /* Perform actions defined in the image */
-   while( ( pImagePtr < (pFwupgCtx->pImageData + pFwupgCtx->imageSize - 
+   while( ( pImagePtr < (pFwupgCtx->pImageData + pFwupgCtx->imageSize -
             HPMFWUPG_MD5_SIGNATURE_LENGTH)) &&
           ( rc == HPMFWUPG_SUCCESS) )
    {
       /* Get action record */
       pActionRecord = (struct HpmfwupgActionRecord*)pImagePtr;
-      
+
       /* Validate action record checksum */
-      if ( HpmfwupgCalculateChecksum((unsigned char*)pActionRecord, 
+      if ( HpmfwupgCalculateChecksum((unsigned char*)pActionRecord,
                                      sizeof(struct HpmfwupgActionRecord)) != 0 )
       {
          lprintf(LOG_NOTICE,"    Invalid Action record.");
          rc = HPMFWUPG_ERROR;
       }
-      
+
       if ( rc == HPMFWUPG_SUCCESS )
       {
          switch( pActionRecord->actionType )
@@ -1988,26 +2117,28 @@ int HpmfwupgUpgradeStage(struct ipmi_intf *intf, struct HpmfwupgUpgradeCtx* pFwu
             {
                /* Send prepare components command */
                struct HpmfwupgInitiateUpgradeActionCtx initUpgActionCmd;
-               
-               initUpgActionCmd.req.componentsMask = pActionRecord->components;
+
+               initUpgActionCmd.req.componentsMask = pFwupgCtx->compUpdateMask;
                /* Action is prepare components */
                initUpgActionCmd.req.upgradeAction  = HPMFWUPG_UPGRADE_ACTION_BACKUP;
                rc = HpmfwupgInitiateUpgradeAction(intf, &initUpgActionCmd, pFwupgCtx);
                pImagePtr += sizeof(struct HpmfwupgActionRecord);
-               
+
             }
             break;
             case HPMFWUPG_ACTION_PREPARE_COMPONENTS:
             {
                int componentId;
-               /* Make sure every components specified by this action 
+               /* Make sure every components specified by this action
                   supports the prepare components */
-               componentToUploadMsk.ComponentBits.byte = 0x00;
-               for ( componentId = HPMFWUPG_COMPONENT_ID_0; 
+
+               /* Component 'filtering' is done in PreUpdateCheck() and pFwupgCtx is set accordiongly */
+       
+               for ( componentId = HPMFWUPG_COMPONENT_ID_0;
                      componentId < HPMFWUPG_COMPONENT_ID_MAX;
                      componentId++ )
                {
-                  if ( (1 << componentId & pActionRecord->components.ComponentBits.byte) )
+                  if ( (1 << componentId & pFwupgCtx->compUpdateMask.ComponentBits.byte) )
                   {
                      if ( pFwupgCtx->genCompProp[componentId].GeneralCompProperties.bitfield.preparationSupport == 0 )
                      {
@@ -2015,38 +2146,21 @@ int HpmfwupgUpgradeStage(struct ipmi_intf *intf, struct HpmfwupgUpgradeCtx* pFwu
                         rc = HPMFWUPG_ERROR;
                         break;
                      }
-                    if (!gVersionInfo[componentId].skipUpgrade)
-                    {
-                        /* If the component needs not to be skipped then you need to 
-                         * add it in componentToUploadMsk */
-                        componentToUploadMsk.ComponentBits.byte |= 1<<componentId;
-                    }
                   }
                }
-               if (option & FORCE_MODE_COMPONENT)
-               {
-                   /* user has given the component Id to upload on the command line */
-                   componentToUploadMsk.ComponentBits.byte = 
-                            1<<componentToUpload;
-               }
-               if (option & FORCE_MODE_ALL)
-               {
-                   /* user has given all to upload all the components on the command line */
-                   componentToUploadMsk.ComponentBits.byte = 
-                            pActionRecord->components.ComponentBits.byte;
-               }
 
                if ( rc == HPMFWUPG_SUCCESS )
                {
-                  if ( componentToUploadMsk.ComponentBits.byte != 0x00 )
+                  if ( pFwupgCtx->compUpdateMask.ComponentBits.byte != 0x00 )
                   {
                      /* Send prepare components command */
                      struct HpmfwupgInitiateUpgradeActionCtx initUpgActionCmd;
-                     initUpgActionCmd.req.componentsMask = componentToUploadMsk;
+                     initUpgActionCmd.req.componentsMask = pFwupgCtx->compUpdateMask;
                      /* Action is prepare components */
                      initUpgActionCmd.req.upgradeAction  = HPMFWUPG_UPGRADE_ACTION_PREPARE;
                      rc = HpmfwupgInitiateUpgradeAction(intf, &initUpgActionCmd, pFwupgCtx);
-                  }                       
+                                         
+                  }
                   pImagePtr += sizeof(struct HpmfwupgActionRecord);
                }
             }
@@ -2054,275 +2168,17 @@ int HpmfwupgUpgradeStage(struct ipmi_intf *intf, struct HpmfwupgUpgradeCtx* pFwu
 
             case HPMFWUPG_ACTION_UPLOAD_FIRMWARE:
             /* Upload all firmware blocks */
-            {
-               struct HpmfwupgFirmwareImage* pFwImage;
-               struct HpmfwupgInitiateUpgradeActionCtx initUpgActionCmd;
-               struct HpmfwupgUploadFirmwareBlockCtx   uploadCmd;
-               struct HpmfwupgFinishFirmwareUploadCtx  finishCmd;
-               struct HpmfwupgGetComponentPropertiesCtx getCompProp;
-               VERSIONINFO    *pVersionInfo;
-               
-               unsigned char* pData, *pDataInitial;
-               unsigned char  count;
-               unsigned int   totalSent = 0;
-               unsigned char  bufLength = 0;
-               unsigned int   firmwareLength = 0;
-               
-               unsigned int   displayFWLength = 0; 
-               unsigned char  *pDataTemp;
-               unsigned int   imageOffset = 0x00;
-               unsigned int   blockLength = 0x00;
-               unsigned int   lengthOfBlock = 0x00;
-               unsigned int   numTxPkts = 0;
-               unsigned int   numRxPkts = 0;
-               unsigned char  mode = 0;
-               unsigned char  componentId = 0x00;
-               unsigned char  componentIdByte = 0x00;
-   
-
-               /* Save component ID on which the upload is done */
-               componentIdByte = pActionRecord->components.ComponentBits.byte;
-               while ((componentIdByte>>=1)!=0)
-               {
-                    componentId++;
-               }
-               pFwupgCtx->componentId = componentId;
-
-               /* Initialize parameters */
-               uploadCmd.req.blockNumber = 0;
-               pFwImage = (struct HpmfwupgFirmwareImage*)(pImagePtr + 
-                              sizeof(struct HpmfwupgActionRecord));
-
-/* 
- *                lprintf(LOG_NOTICE,"    Upgrading %s", pFwImage->desc);
- *                lprintf(LOG_NOTICE,"    with Version: Major: %d", pFwImage->version[0]);
- *                lprintf(LOG_NOTICE,"                  Minor: %x", pFwImage->version[1]);
- *                lprintf(LOG_NOTICE,"                  Aux  : %03d %03d %03d %03d", pFwImage->version[2],
- *                                                               pFwImage->version[3],
- *                                                               pFwImage->version[4],
- *                                                               pFwImage->version[5]); 
- */
-                  pDataInitial = ((unsigned char*)pFwImage + sizeof(struct HpmfwupgFirmwareImage));
-                  pData = pDataInitial;
-                                    
-                  /* Find max buffer length according the connection parameters */
-                  if ( strstr(intf->name,"lan") != NULL )
-                  {
-                     bufLength = HPMFWUPG_SEND_DATA_COUNT_LAN - 2;
-                     if ( intf->transit_addr != intf->my_addr && intf->transit_addr != 0 )
-                         bufLength -= 8;
-                  }
-                  else
-                  {
-                     if
-                     ( 
-                        strstr(intf->name,"open") != NULL
-                        &&
-                        (
-                           intf->target_addr ==  intf->my_addr
-                        )
-                     )
-                     {
-                        bufLength = HPMFWUPG_SEND_DATA_COUNT_KCS - 2;
-                     }
-                     else
-                     {
-                        if ( intf->target_channel == 7 )    
-                        {
-                           bufLength = HPMFWUPG_SEND_DATA_COUNT_IPMBL;
-                        }
-                        else
-                        {
-                           bufLength = HPMFWUPG_SEND_DATA_COUNT_IPMB;
-                        }
-                     }
-                  }
-                                 
-                  /* Get firmware length */
-                  firmwareLength  =  pFwImage->length[0];
-                  firmwareLength |= (pFwImage->length[1] << 8)  & 0xff00;
-                  firmwareLength |= (pFwImage->length[2] << 16) & 0xff0000;
-                  firmwareLength |= (pFwImage->length[3] << 24) & 0xff000000;
-
-                  if ( (!(1<<componentToUpload & pActionRecord->components.ComponentBits.byte)) 
-                       && (componentToUpload != DEFAULT_COMPONENT_UPLOAD))
-                  {
-                     /* We will skip if the user has given some components in command line "component 2" */
-                     pImagePtr = pDataInitial + firmwareLength;
-                     break;
-                  }
-                
-                  /* Send initiate command */
-                  initUpgActionCmd.req.componentsMask = pActionRecord->components;
-                  /* Action is upgrade */
-                  initUpgActionCmd.req.upgradeAction  = HPMFWUPG_UPGRADE_ACTION_UPGRADE;
-                  rc = HpmfwupgInitiateUpgradeAction(intf, &initUpgActionCmd, pFwupgCtx);
-               
-                  if (rc != HPMFWUPG_SUCCESS)
-                  {
-                     break;
-                  }
-                  
-                  pVersionInfo = (VERSIONINFO*) &gVersionInfo[componentId];
-                  
-                  mode = TARGET_VER | IMAGE_VER;
-                  if (pVersionInfo->rollbackSupported)
-                  {
-                      mode |= ROLLBACK_VER;
-                  }
-                  if ( pVersionInfo->coldResetRequired)
-                  {
-                      flagColdReset = TRUE;
-                  }
-                  if( (option & VERSIONCHECK_MODE) && pVersionInfo->skipUpgrade)  
-                  {
+               rc = HpmFwupgActionUploadFirmware
+               (
+                     pActionRecord->components,
+                     pFwupgCtx,
+                     &pImagePtr,
+                     componentToUpload,
+                     intf,
+                     option,
+                     &flagColdReset
+               );
 
-                        HpmDisplayVersion(mode,pVersionInfo);
-                        HpmDisplayUpgrade(1,0,0,0);
-                        pImagePtr = pDataInitial + firmwareLength;
-                        break;
-                  }
-
-                  if ((option & DEBUG_MODE))
-                  {
-                      printf("\n\n Comp ID : %d  [%-20s]\n",pVersionInfo->componentId,pFwImage->desc);
-                  }
-                  else 
-                  {
-                      HpmDisplayVersion(mode,pVersionInfo);
-                  }
-
-                  /* pDataInitial is the starting pointer of the image data  */
-                  /* pDataTemp is one which we will move across */
-                  pData = pDataInitial;
-                  pDataTemp = pDataInitial;
-                  lengthOfBlock = firmwareLength;
-                  totalSent = 0x00;
-                  displayFWLength= firmwareLength;
-                  time(&start);
-                  while ( (pData < (pDataTemp+lengthOfBlock)) && (rc == HPMFWUPG_SUCCESS) )
-                  {
-                     if ( (pData+bufLength) <= (pDataTemp+lengthOfBlock) )
-                     {        
-                        count = bufLength;                
-                     }
-                     else
-                     {
-                        count = (unsigned char)((pDataTemp+lengthOfBlock) - pData);
-                     }
-                     memcpy(&uploadCmd.req.data, pData, bufLength);
-
-                     imageOffset = 0x00;
-                     blockLength = 0x00;
-                     numTxPkts++;
-                     rc = HpmfwupgUploadFirmwareBlock(intf, &uploadCmd, pFwupgCtx, count, 
-                                                        &imageOffset,&blockLength);
-                     numRxPkts++;
-
-                     if ( rc != HPMFWUPG_SUCCESS)
-                     {
-                        if ( rc == HPMFWUPG_UPLOAD_BLOCK_LENGTH )
-                        {
-                           /* Retry with a smaller buffer length */
-                           if ( strstr(intf->name,"lan") != NULL ) 
-                           {
-                              bufLength -= (unsigned char)8;
-                           }
-                           else
-                           {
-                              bufLength -= (unsigned char)1;
-                           }
-                           rc = HPMFWUPG_SUCCESS; 
-                        }
-                        else if ( rc == HPMFWUPG_UPLOAD_RETRY )
-                        {
-                           rc = HPMFWUPG_SUCCESS;
-                        }
-                        else
-                        {
-                           fflush(stdout);
-                           lprintf(LOG_NOTICE,"\n Error in Upload FIRMWARE command [rc=%d]\n",rc);
-                           lprintf(LOG_NOTICE,"\n TotalSent:0x%x ",totalSent);
-                           /* Exiting from the function */
-                           rc = HPMFWUPG_ERROR;
-                           break;
-                        }
-                     }
-                     else
-                     {
-                        if (blockLength > firmwareLength)
-                        {
-                            /* 
-                             * blockLength is the remaining length of the firnware to upload so
-                             * if its greater than the firmware length then its kind of error
-                             */
-                            lprintf(LOG_NOTICE,"\n Error in Upload FIRMWARE command [rc=%d]\n",rc);
-                            lprintf(LOG_NOTICE,"\n TotalSent:0x%x Img offset:0x%x  Blk length:0x%x  Fwlen:0x%x\n",
-                                        totalSent,imageOffset,blockLength,firmwareLength);
-                            rc = HPMFWUPG_ERROR;                         
-                            break;
-                        }
-                        totalSent += count;
-                        if (imageOffset != 0x00)
-                        {
-                            /* block Length is valid  */
-                            lengthOfBlock = blockLength;
-                            pDataTemp = pDataInitial + imageOffset;
-                            pData = pDataTemp;
-                            if ( displayFWLength == firmwareLength)
-                            {
-                               /* This is basically used only to make sure that we display uptil 100% */
-                               displayFWLength = blockLength + totalSent;
-                            }
-                        }
-                        else
-                        {
-                            pData += count;
-                        }
-                        time(&end);
-                        /* 
-                         * Just added debug mode in case we need to see exactly how many bytes have 
-                         * gone through - Its a hidden option used mainly should be used for debugging 
-                         */
-                        if ( option & DEBUG_MODE)
-                        {
-                            fflush(stdout);
-                            printf(" Blk Num : %02x        Bytes : %05x \r",
-                                            uploadCmd.req.blockNumber,totalSent);
-                            if (imageOffset || blockLength)
-                            {
-                               printf("\n\r--> ImgOff : %x BlkLen : %x\n",imageOffset,blockLength);
-                            }
-                            if (displayFWLength == totalSent)
-                            {
-                               printf("\n Time Taken %02d:%02d",(end-start)/60, (end-start)%60);
-                               printf("\n\n");
-                            }
-                        }
-                        else
-                        {
-                           HpmDisplayUpgrade(0,totalSent,displayFWLength,(end-start));
-                        }
-                        uploadCmd.req.blockNumber++;                     
-                     }
-                   } 
-
-                   if (rc == HPMFWUPG_SUCCESS)
-                   {
-                     /* Send finish component */
-                     /* Set image length */
-                     finishCmd.req.componentId = componentId;
-                     /* We need to send the actual data that is sent 
-                      * not the comlete firmware image length   
-                      */
-                     finishCmd.req.imageLength[0] = totalSent & 0xFF;
-                     finishCmd.req.imageLength[1] = (totalSent >> 8) & 0xFF;
-                     finishCmd.req.imageLength[2] = (totalSent >> 16) & 0xFF;
-                     finishCmd.req.imageLength[3] = (totalSent >> 24) & 0xFF;
-                     rc = HpmfwupgFinishFirmwareUpload(intf, &finishCmd, pFwupgCtx);
-                     pImagePtr = pDataInitial + firmwareLength;
-                   }
-                  }
             break;
             default:
                lprintf(LOG_NOTICE,"    Invalid Action type. Cannot continue");
@@ -2332,22 +2188,323 @@ int HpmfwupgUpgradeStage(struct ipmi_intf *intf, struct HpmfwupgUpgradeCtx* pFwu
       }
    }
 
-   HpmDisplayLine("-",79);
+   HpmDisplayLine("-",78);
 
    if (flagColdReset)
    {
        fflush(stdout);
        lprintf(LOG_NOTICE,"(*) Component requires Payload Cold Reset");
    }
-   return rc;   
+   return rc;
+}
+
+static int HpmFwupgActionUploadFirmware
+(
+   struct HpmfwupgComponentBitMask components,
+   struct HpmfwupgUpgradeCtx* pFwupgCtx,
+   unsigned char** pImagePtr,
+   int componentToUpload,
+   struct ipmi_intf *intf,
+   int option,
+   int *pFlagColdReset
+)
+{
+   struct HpmfwupgFirmwareImage* pFwImage;
+   struct HpmfwupgInitiateUpgradeActionCtx initUpgActionCmd;
+   struct HpmfwupgUploadFirmwareBlockCtx   uploadCmd;
+   struct HpmfwupgFinishFirmwareUploadCtx  finishCmd;
+   struct HpmfwupgGetComponentPropertiesCtx getCompProp;
+   VERSIONINFO    *pVersionInfo;
+   time_t           start,end;
+
+   int            rc = HPMFWUPG_SUCCESS;
+   int            skip = TRUE;
+   unsigned char* pData, *pDataInitial;
+   unsigned char  count;
+   unsigned int   totalSent = 0;
+   unsigned char  bufLength = 0;
+   unsigned int   firmwareLength = 0;
+
+   unsigned int   displayFWLength = 0;
+   unsigned char  *pDataTemp;
+   unsigned int   imageOffset = 0x00;
+   unsigned int   blockLength = 0x00;
+   unsigned int   lengthOfBlock = 0x00;
+   unsigned int   numTxPkts = 0;
+   unsigned int   numRxPkts = 0;
+   unsigned char  mode = 0;
+   unsigned char  componentId = 0x00;
+   unsigned char  componentIdByte = 0x00;
+
+   /* Save component ID on which the upload is done */
+   componentIdByte = components.ComponentBits.byte;
+   while ((componentIdByte>>=1)!=0)
+   {
+        componentId++;
+   }
+   pFwupgCtx->componentId = componentId;
+
+   pVersionInfo = (VERSIONINFO*) &gVersionInfo[componentId];
+
+   pFwImage = (struct HpmfwupgFirmwareImage*)((*pImagePtr) +
+                  sizeof(struct HpmfwupgActionRecord));
+
+   pDataInitial = ((unsigned char*)pFwImage + sizeof(struct HpmfwupgFirmwareImage));
+   pData = pDataInitial;
+
+   /* Get firmware length */
+   firmwareLength  =  pFwImage->length[0];
+   firmwareLength |= (pFwImage->length[1] << 8)  & 0xff00;
+   firmwareLength |= (pFwImage->length[2] << 16) & 0xff0000;
+   firmwareLength |= (pFwImage->length[3] << 24) & 0xff000000;
+
+   mode = TARGET_VER | IMAGE_VER;
+
+   if (pVersionInfo->rollbackSupported)
+   {
+		 mode |= ROLLBACK_VER;
+	}
+
+	if ((option & DEBUG_MODE))
+	{
+		 printf("\n\n Comp ID : %d	 [%-20s]\n",pVersionInfo->componentId,pFwImage->desc);
+	}
+	else
+	{
+		 HpmDisplayVersion(mode,pVersionInfo);
+	}
+
+	if( (1 << componentId) & pFwupgCtx->compUpdateMask.ComponentBits.byte)
+	{
+		if( verbose ) {
+			lprintf(LOG_NOTICE,"Do not skip %d" , componentId);
+		}
+		skip = FALSE;
+	}
+
+   if(!skip)
+   {
+      /* Initialize parameters */
+      uploadCmd.req.blockNumber = 0;
+
+      /* Check if we receive size in parameters */
+      if(intf->channel_buf_size != 0)
+      {
+         if (intf->target_addr ==  intf->my_addr)
+         {
+            bufLength = intf->channel_buf_size - 9; /* Plan for overhead */
+         }
+         else
+         {
+            bufLength = intf->channel_buf_size - 11; /* Plan for overhead */
+         }
+      }
+      else
+      {
+        /* Find max buffer length according the connection parameters */
+        if ( strstr(intf->name,"lan") != NULL )
+        {
+           bufLength = HPMFWUPG_SEND_DATA_COUNT_LAN - 2;
+           if ( intf->transit_addr != intf->my_addr && intf->transit_addr != 0 )
+               bufLength -= 8;
+        }
+        else
+        {
+           if
+           (
+              strstr(intf->name,"open") != NULL
+              &&
+              (
+                 intf->target_addr ==  intf->my_addr
+              )
+           )
+           {
+              bufLength = HPMFWUPG_SEND_DATA_COUNT_KCS - 2;
+           }
+           else
+           {
+              if ( intf->target_channel == 7 )
+              {
+                 bufLength = HPMFWUPG_SEND_DATA_COUNT_IPMBL;
+              }
+              else
+              {
+                 bufLength = HPMFWUPG_SEND_DATA_COUNT_IPMB;
+              }
+           }
+        }
+      }
+
+      /* Send Initiate Upgrade Action */
+      initUpgActionCmd.req.componentsMask = components;
+      /* Action is upgrade */
+      initUpgActionCmd.req.upgradeAction  = HPMFWUPG_UPGRADE_ACTION_UPGRADE;
+      rc = HpmfwupgInitiateUpgradeAction(intf, &initUpgActionCmd, pFwupgCtx);
+
+      if (rc != HPMFWUPG_SUCCESS)
+      {
+         skip = TRUE;
+      }
+
+      if ( (pVersionInfo->coldResetRequired) && (!skip))
+      {
+          *pFlagColdReset = TRUE;
+      }
+      /* pDataInitial is the starting pointer of the image data  */
+      /* pDataTemp is one which we will move across */
+      pData = pDataInitial;
+      pDataTemp = pDataInitial;
+      lengthOfBlock = firmwareLength;
+      totalSent = 0x00;
+      displayFWLength= firmwareLength;
+      time(&start);
+
+
+      while ( (pData < (pDataTemp+lengthOfBlock)) && (rc == HPMFWUPG_SUCCESS) )
+      {
+         if ( (pData+bufLength) <= (pDataTemp+lengthOfBlock) )
+         {
+            count = bufLength;
+         }
+         else
+         {
+            count = (unsigned char)((pDataTemp+lengthOfBlock) - pData);
+         }
+         memcpy(&uploadCmd.req.data, pData, bufLength);
+
+         imageOffset = 0x00;
+         blockLength = 0x00;
+         numTxPkts++;
+         rc = HpmfwupgUploadFirmwareBlock(intf, &uploadCmd, pFwupgCtx, count,
+                                            &imageOffset,&blockLength);
+         numRxPkts++;
+
+         if ( rc != HPMFWUPG_SUCCESS)
+         {
+            if ( rc == HPMFWUPG_UPLOAD_BLOCK_LENGTH )
+            {
+               /* Retry with a smaller buffer length */
+               if ( strstr(intf->name,"lan") != NULL )
+               {
+                  bufLength -= (unsigned char)8;
+                  lprintf(LOG_INFO,"Trying reduced buffer length: %d", bufLength);
+               }
+               else
+               {
+                  bufLength -= (unsigned char)1;
+                  lprintf(LOG_INFO,"Trying reduced buffer length: %d", bufLength);
+               }
+               rc = HPMFWUPG_SUCCESS;
+            }
+            else if ( rc == HPMFWUPG_UPLOAD_RETRY )
+            {
+               rc = HPMFWUPG_SUCCESS;
+            }
+            else
+            {
+               fflush(stdout);
+               lprintf(LOG_NOTICE,"\n Error in Upload FIRMWARE command [rc=%d]\n",rc);
+               lprintf(LOG_NOTICE,"\n TotalSent:0x%x ",totalSent);
+               /* Exiting from the function */
+               rc = HPMFWUPG_ERROR;
+            }
+         }
+         else
+         {
+            if (blockLength > firmwareLength)
+            {
+                /*
+                 * blockLength is the remaining length of the firmware to upload so
+                 * if its greater than the firmware length then its kind of error
+                 */
+                lprintf(LOG_NOTICE,"\n Error in Upload FIRMWARE command [rc=%d]\n",rc);
+                lprintf(LOG_NOTICE,"\n TotalSent:0x%x Img offset:0x%x  Blk length:0x%x  Fwlen:0x%x\n",
+                            totalSent,imageOffset,blockLength,firmwareLength);
+                rc = HPMFWUPG_ERROR;
+            }
+            totalSent += count;
+            if (imageOffset != 0x00)
+            {
+                /* block Length is valid  */
+                lengthOfBlock = blockLength;
+                pDataTemp = pDataInitial + imageOffset;
+                pData = pDataTemp;
+                if ( displayFWLength == firmwareLength)
+                {
+                   /* This is basically used only to make sure that we display uptil 100% */
+                   displayFWLength = blockLength + totalSent;
+                }
+            }
+            else
+            {
+                pData += count;
+            }
+            time(&end);
+            /*
+             * Just added debug mode in case we need to see exactly how many bytes have
+             * gone through - Its a hidden option used mainly should be used for debugging
+             */
+            if ( option & DEBUG_MODE)
+            {
+                fflush(stdout);
+                printf(" Blk Num : %02x        Bytes : %05x \r",
+                                uploadCmd.req.blockNumber,totalSent);
+                if (imageOffset || blockLength)
+                {
+                   printf("\n\r--> ImgOff : %x BlkLen : %x\n",imageOffset,blockLength);
+                }
+                if (displayFWLength == totalSent)
+                {
+                   printf("\n Time Taken %02d:%02d",(end-start)/60, (end-start)%60);
+                   printf("\n\n");
+                }
+            }
+            else
+            {
+               HpmDisplayUpgrade(0,totalSent,displayFWLength,(end-start));
+            }
+            uploadCmd.req.blockNumber++;
+         }
+      }
+   }
+
+   if (skip)
+   {
+
+      HpmDisplayUpgrade(1,0,0,0);
+      *pImagePtr = pDataInitial + firmwareLength;
+   }
+
+   if
+   (
+      (rc == HPMFWUPG_SUCCESS)
+      &&
+      (!skip)
+   )
+   {
+      /* Send finish component */
+      /* Set image length */
+      finishCmd.req.componentId = componentId;
+      /* We need to send the actual data that is sent
+       * not the comlete firmware image length
+       */
+      finishCmd.req.imageLength[0] = totalSent & 0xFF;
+      finishCmd.req.imageLength[1] = (totalSent >> 8) & 0xFF;
+      finishCmd.req.imageLength[2] = (totalSent >> 16) & 0xFF;
+      finishCmd.req.imageLength[3] = (totalSent >> 24) & 0xFF;
+      rc = HpmfwupgFinishFirmwareUpload(intf, &finishCmd, pFwupgCtx);
+      *pImagePtr = pDataInitial + firmwareLength;
+   }
+
+   return rc;
 }
- 
+
 /****************************************************************************
 *
 * Function Name:  HpmfwupgActivationStage
 *
-* Description: This function the validation stage of a firmware upgrade 
-*              procedure as defined in section 3.4 of the IPM Controller 
+* Description: This function the validation stage of a firmware upgrade
+*              procedure as defined in section 3.4 of the IPM Controller
 *              Firmware Upgrade Specification version 1.0
 *
 *****************************************************************************/
@@ -2363,16 +2520,16 @@ static int HpmfwupgActivationStage(struct ipmi_intf *intf, struct HpmfwupgUpgrad
    fflush(stdout);
    /* Activate new firmware */
    rc = HpmfwupgActivateFirmware(intf, &activateCmd, pFwupgCtx);
-   
+
    if ( rc == HPMFWUPG_SUCCESS )
    {
       /* Query self test result if supported by target and new image */
-      if ( (pFwupgCtx->targetCap.GlobalCapabilities.bitField.ipmcSelftestCap == 1) || 
+      if ( (pFwupgCtx->targetCap.GlobalCapabilities.bitField.ipmcSelftestCap == 1) ||
            (pImageHeader->imageCapabilities.bitField.imageSelfTest == 1) )
       {
          struct HpmfwupgQuerySelftestResultCtx selfTestCmd;
          rc = HpmfwupgQuerySelftestResult(intf, &selfTestCmd, pFwupgCtx);
-         
+
          if ( rc == HPMFWUPG_SUCCESS )
          {
             /* Get the self test result */
@@ -2394,7 +2551,7 @@ static int HpmfwupgActivationStage(struct ipmi_intf *intf, struct HpmfwupgUpgrad
          }
       }
    }
-   
+
    /* If activation / self test failed, query rollback status if automatic rollback supported */
    if ( rc == HPMFWUPG_ERROR )
    {
@@ -2407,27 +2564,28 @@ static int HpmfwupgActivationStage(struct ipmi_intf *intf, struct HpmfwupgUpgrad
          rc = HpmfwupgQueryRollbackStatus(intf, &rollCmd, pFwupgCtx);
       }
    }
-   
+
    return rc;
-}                                         
+}
 
 int HpmfwupgGetBufferFromFile(char* imageFilename, struct HpmfwupgUpgradeCtx* pFwupgCtx)
 {
    int rc = HPMFWUPG_SUCCESS;
    FILE* pImageFile = fopen(imageFilename, "rb");
-   
+
    if ( pImageFile == NULL )
    {
       lprintf(LOG_NOTICE,"Cannot open image file %s", imageFilename);
       rc = HPMFWUPG_ERROR;
    }
-   
+
    if ( rc == HPMFWUPG_SUCCESS )
    {
       /* Get the raw data in file */
       fseek(pImageFile, 0, SEEK_END);
-      pFwupgCtx->imageSize  = ftell(pImageFile); 
+      pFwupgCtx->imageSize  = ftell(pImageFile);
       pFwupgCtx->pImageData = malloc(sizeof(unsigned char)*pFwupgCtx->imageSize);
+      pFwupgCtx->compUpdateMask.ComponentBits.byte = 0;
       rewind(pImageFile);
       if ( pFwupgCtx->pImageData != NULL )
       {
@@ -2437,26 +2595,26 @@ int HpmfwupgGetBufferFromFile(char* imageFilename, struct HpmfwupgUpgradeCtx* pF
       {
          rc = HPMFWUPG_ERROR;
       }
-   
+
       fclose(pImageFile);
    }
-      
+
    return rc;
-}  
+}
 
 int HpmfwupgGetDeviceId(struct ipmi_intf *intf, struct ipm_devid_rsp* pGetDevId)
 {
    int rc = HPMFWUPG_SUCCESS;
    struct ipmi_rs * rsp;
    struct ipmi_rq req;
-   
+
    memset(&req, 0, sizeof(req));
    req.msg.netfn = IPMI_NETFN_APP;
    req.msg.cmd = BMC_GET_DEVICE_ID;
    req.msg.data_len = 0;
 
    rsp = HpmfwupgSendCmd(intf, req, NULL);
-   
+
    if ( rsp )
    {
       if ( rsp->ccode == 0x00 )
@@ -2475,25 +2633,25 @@ int HpmfwupgGetDeviceId(struct ipmi_intf *intf, struct ipm_devid_rsp* pGetDevId)
       rc = HPMFWUPG_ERROR;
    }
    return rc;
-} 
+}
 
-int HpmfwupgGetTargetUpgCapabilities(struct ipmi_intf *intf, 
+int HpmfwupgGetTargetUpgCapabilities(struct ipmi_intf *intf,
                                      struct HpmfwupgGetTargetUpgCapabilitiesCtx* pCtx)
 {
    int    rc = HPMFWUPG_SUCCESS;
    struct ipmi_rs * rsp;
    struct ipmi_rq   req;
-   
+
    pCtx->req.picmgId  = HPMFWUPG_PICMG_IDENTIFIER;
-   
+
    memset(&req, 0, sizeof(req));
    req.msg.netfn    = IPMI_NETFN_PICMG;
 	req.msg.cmd      = HPMFWUPG_GET_TARGET_UPG_CAPABILITIES;
 	req.msg.data     = (unsigned char*)&pCtx->req;
 	req.msg.data_len = sizeof(struct HpmfwupgGetTargetUpgCapabilitiesReq);
-      
+
    rsp = HpmfwupgSendCmd(intf, req, NULL);
-   
+
    if ( rsp )
    {
       if ( rsp->ccode == 0x00 )
@@ -2507,39 +2665,39 @@ int HpmfwupgGetTargetUpgCapabilities(struct ipmi_intf *intf,
             lprintf(LOG_NOTICE,"Component 0 presence....[%c]   ", pCtx->resp.componentsPresent.ComponentBits.
                                                         bitField.component0 ? 'y' : 'n');
             lprintf(LOG_NOTICE,"Component 1 presence....[%c]   ", pCtx->resp.componentsPresent.ComponentBits.
-                                                        bitField.component1 ? 'y' : 'n');                                                  
+                                                        bitField.component1 ? 'y' : 'n');
             lprintf(LOG_NOTICE,"Component 2 presence....[%c]   ", pCtx->resp.componentsPresent.ComponentBits.
-                                                        bitField.component2 ? 'y' : 'n');                                                  
+                                                        bitField.component2 ? 'y' : 'n');
             lprintf(LOG_NOTICE,"Component 3 presence....[%c]   ", pCtx->resp.componentsPresent.ComponentBits.
                                                         bitField.component3 ? 'y' : 'n');
             lprintf(LOG_NOTICE,"Component 4 presence....[%c]   ", pCtx->resp.componentsPresent.ComponentBits.
                                                         bitField.component4 ? 'y' : 'n');
             lprintf(LOG_NOTICE,"Component 5 presence....[%c]   ", pCtx->resp.componentsPresent.ComponentBits.
-                                                        bitField.component5 ? 'y' : 'n');  
+                                                        bitField.component5 ? 'y' : 'n');
             lprintf(LOG_NOTICE,"Component 6 presence....[%c]   ", pCtx->resp.componentsPresent.ComponentBits.
-                                                        bitField.component6 ? 'y' : 'n'); 
+                                                        bitField.component6 ? 'y' : 'n');
             lprintf(LOG_NOTICE,"Component 7 presence....[%c]   ", pCtx->resp.componentsPresent.ComponentBits.
                                                         bitField.component7 ? 'y' : 'n');
             lprintf(LOG_NOTICE,"Upgrade undesirable.....[%c]   ", pCtx->resp.GlobalCapabilities.
-                                                        bitField.fwUpgUndesirable ? 'y' : 'n');                                                                                                                                                                             
+                                                        bitField.fwUpgUndesirable ? 'y' : 'n');
             lprintf(LOG_NOTICE,"Aut rollback override...[%c]   ", pCtx->resp.GlobalCapabilities.
-                                                        bitField.autRollbackOverride ? 'y' : 'n');                                                        
+                                                        bitField.autRollbackOverride ? 'y' : 'n');
             lprintf(LOG_NOTICE,"IPMC degraded...........[%c]   ", pCtx->resp.GlobalCapabilities.
                                                         bitField.ipmcDegradedDurinUpg ? 'y' : 'n');
             lprintf(LOG_NOTICE,"Defered activation......[%c]   ", pCtx->resp.GlobalCapabilities.
                                                         bitField.deferActivation ? 'y' : 'n');
             lprintf(LOG_NOTICE,"Service affected........[%c]   ", pCtx->resp.GlobalCapabilities.
-                                                        bitField.servAffectDuringUpg ? 'y' : 'n');                                                                                                      
+                                                        bitField.servAffectDuringUpg ? 'y' : 'n');
             lprintf(LOG_NOTICE,"Manual rollback.........[%c]   ", pCtx->resp.GlobalCapabilities.
-                                                        bitField.manualRollback ? 'y' : 'n');                                              
+                                                        bitField.manualRollback ? 'y' : 'n');
             lprintf(LOG_NOTICE,"Automatic rollback......[%c]   ", pCtx->resp.GlobalCapabilities.
-                                                        bitField.autRollback ? 'y' : 'n');                                                        
+                                                        bitField.autRollback ? 'y' : 'n');
             lprintf(LOG_NOTICE,"Self test...............[%c]   ", pCtx->resp.GlobalCapabilities.
                                                         bitField.ipmcSelftestCap ? 'y' : 'n');
-            lprintf(LOG_NOTICE,"Upgrade timeout.........[%d sec] ", pCtx->resp.upgradeTimeout*5);                                                                                            
+            lprintf(LOG_NOTICE,"Upgrade timeout.........[%d sec] ", pCtx->resp.upgradeTimeout*5);
             lprintf(LOG_NOTICE,"Self test timeout.......[%d sec] ", pCtx->resp.selftestTimeout*5);
             lprintf(LOG_NOTICE,"Rollback timeout........[%d sec] ", pCtx->resp.rollbackTimeout*5);
-            lprintf(LOG_NOTICE,"Inaccessibility timeout.[%d sec] \n", pCtx->resp.rollbackTimeout*5);
+            lprintf(LOG_NOTICE,"Inaccessibility timeout.[%d sec] \n", pCtx->resp.inaccessTimeout*5);
          }
       }
       else
@@ -2553,11 +2711,11 @@ int HpmfwupgGetTargetUpgCapabilities(struct ipmi_intf *intf,
       lprintf(LOG_NOTICE,"Error getting target upgrade capabilities\n");
       rc = HPMFWUPG_ERROR;
    }
-   
-   
-   
+
+
+
    return rc;
-}   
+}
 
 
 int HpmfwupgGetComponentProperties(struct ipmi_intf *intf, struct HpmfwupgGetComponentPropertiesCtx* pCtx)
@@ -2565,9 +2723,9 @@ int HpmfwupgGetComponentProperties(struct ipmi_intf *intf, struct HpmfwupgGetCom
    int    rc = HPMFWUPG_SUCCESS;
    struct ipmi_rs * rsp;
    struct ipmi_rq   req;
-   
+
    pCtx->req.picmgId = HPMFWUPG_PICMG_IDENTIFIER;
-   
+
    memset(&req, 0, sizeof(req));
    req.msg.netfn    = IPMI_NETFN_PICMG;
 	req.msg.cmd      = HPMFWUPG_GET_COMPONENT_PROPERTIES;
@@ -2575,11 +2733,11 @@ int HpmfwupgGetComponentProperties(struct ipmi_intf *intf, struct HpmfwupgGetCom
 	req.msg.data_len = sizeof(struct HpmfwupgGetComponentPropertiesReq);
 
    rsp = HpmfwupgSendCmd(intf, req, NULL);
-   
+
    if ( rsp )
    {
       if ( rsp->ccode == 0x00 )
-      { 
+      {
          switch ( pCtx->req.selector )
          {
             case HPMFWUPG_COMP_GEN_PROPERTIES:
@@ -2591,11 +2749,11 @@ int HpmfwupgGetComponentProperties(struct ipmi_intf *intf, struct HpmfwupgGetCom
                   lprintf(LOG_NOTICE,"Payload cold reset req....[%c]   ", pCtx->resp.Response.generalPropResp.
                                                               GeneralCompProperties.bitfield.payloadColdReset ? 'y' : 'n');
                   lprintf(LOG_NOTICE,"Def. activation supported.[%c]   ", pCtx->resp.Response.generalPropResp.
-                                                              GeneralCompProperties.bitfield.deferredActivation ? 'y' : 'n');                                                     
+                                                              GeneralCompProperties.bitfield.deferredActivation ? 'y' : 'n');
                   lprintf(LOG_NOTICE,"Comparison supported......[%c]   ", pCtx->resp.Response.generalPropResp.
                                                               GeneralCompProperties.bitfield.comparisonSupport ? 'y' : 'n');
                   lprintf(LOG_NOTICE,"Preparation supported.....[%c]   ", pCtx->resp.Response.generalPropResp.
-                                                              GeneralCompProperties.bitfield.preparationSupport ? 'y' : 'n');                                                                                          
+                                                              GeneralCompProperties.bitfield.preparationSupport ? 'y' : 'n');
                   lprintf(LOG_NOTICE,"Rollback supported........[%c]   \n", pCtx->resp.Response.generalPropResp.
                                                               GeneralCompProperties.bitfield.rollbackBackup ? 'y' : 'n');
                }
@@ -2611,8 +2769,8 @@ int HpmfwupgGetComponentProperties(struct ipmi_intf *intf, struct HpmfwupgGetCom
                                                     pCtx->resp.Response.currentVersionResp.currentVersion[3],
                                                     pCtx->resp.Response.currentVersionResp.currentVersion[4],
                                                     pCtx->resp.Response.currentVersionResp.currentVersion[5]);
-               }                                                 
-            break; 
+               }
+            break;
             case HPMFWUPG_COMP_DESCRIPTION_STRING:
                memcpy(&pCtx->resp, rsp->data, sizeof(struct HpmfwupgGetDescStringResp));
                if ( verbose )
@@ -2631,7 +2789,7 @@ int HpmfwupgGetComponentProperties(struct ipmi_intf *intf, struct HpmfwupgGetCom
                                                     pCtx->resp.Response.rollbackFwVersionResp.rollbackFwVersion[3],
                                                     pCtx->resp.Response.rollbackFwVersionResp.rollbackFwVersion[4],
                                                     pCtx->resp.Response.rollbackFwVersionResp.rollbackFwVersion[5]);
-               }    
+               }
             break;
             case HPMFWUPG_COMP_DEFERRED_FIRMWARE_VERSION:
                memcpy(&pCtx->resp, rsp->data, sizeof(struct HpmfwupgGetDeferredFwVersionResp));
@@ -2644,9 +2802,9 @@ int HpmfwupgGetComponentProperties(struct ipmi_intf *intf, struct HpmfwupgGetCom
                                                     pCtx->resp.Response.deferredFwVersionResp.deferredFwVersion[3],
                                                     pCtx->resp.Response.deferredFwVersionResp.deferredFwVersion[4],
                                                     pCtx->resp.Response.deferredFwVersionResp.deferredFwVersion[5]);
-               }                                                 
+               }
             break;
-           // OEM Properties command            
+           // OEM Properties command
            case HPMFWUPG_COMP_OEM_PROPERTIES:
                memcpy(&pCtx->resp, rsp->data, sizeof(struct HpmfwupgGetOemProperties));
                if ( verbose )
@@ -2657,14 +2815,14 @@ int HpmfwupgGetComponentProperties(struct ipmi_intf *intf, struct HpmfwupgGetCom
                   {
                     lprintf(LOG_NOTICE," 0x%x ", pCtx->resp.Response.oemProperties.oemRspData[i]);
                   }
-                }                                                 
+                }
             break;
             default:
                lprintf(LOG_NOTICE,"Unsupported component selector");
                rc = HPMFWUPG_ERROR;
             break;
          }
-      }    
+      }
       else
       {
          lprintf(LOG_NOTICE,"Error getting component properties, compcode = %x\n",  rsp->ccode);
@@ -2676,27 +2834,27 @@ int HpmfwupgGetComponentProperties(struct ipmi_intf *intf, struct HpmfwupgGetCom
       lprintf(LOG_NOTICE,"Error getting component properties\n");
       rc = HPMFWUPG_ERROR;
    }
-   
-   
+
+
    return rc;
-} 
+}
 
-int HpmfwupgAbortUpgrade(struct ipmi_intf *intf, struct HpmfwupgAbortUpgradeCtx* pCtx) 
+int HpmfwupgAbortUpgrade(struct ipmi_intf *intf, struct HpmfwupgAbortUpgradeCtx* pCtx)
 {
    int    rc = HPMFWUPG_SUCCESS;
    struct ipmi_rs * rsp;
    struct ipmi_rq   req;
-   
+
    pCtx->req.picmgId = HPMFWUPG_PICMG_IDENTIFIER;
-   
+
    memset(&req, 0, sizeof(req));
    req.msg.netfn    = IPMI_NETFN_PICMG;
 	req.msg.cmd      = HPMFWUPG_ABORT_UPGRADE;
 	req.msg.data     = (unsigned char*)&pCtx->req;
 	req.msg.data_len = sizeof(struct HpmfwupgAbortUpgradeReq);
-      
-   rsp = HpmfwupgSendCmd(intf, req, NULL); 
-   
+
+   rsp = HpmfwupgSendCmd(intf, req, NULL);
+
    if ( rsp )
    {
       if ( rsp->ccode != 0x00 )
@@ -2711,7 +2869,7 @@ int HpmfwupgAbortUpgrade(struct ipmi_intf *intf, struct HpmfwupgAbortUpgradeCtx*
       rc = HPMFWUPG_ERROR;
    }
    return rc;
-}                               
+}
 
 int HpmfwupgInitiateUpgradeAction(struct ipmi_intf *intf, struct HpmfwupgInitiateUpgradeActionCtx* pCtx,
                                   struct HpmfwupgUpgradeCtx* pFwupgCtx)
@@ -2719,17 +2877,17 @@ int HpmfwupgInitiateUpgradeAction(struct ipmi_intf *intf, struct HpmfwupgInitiat
    int    rc = HPMFWUPG_SUCCESS;
    struct ipmi_rs * rsp;
    struct ipmi_rq   req;
-   
+
    pCtx->req.picmgId = HPMFWUPG_PICMG_IDENTIFIER;
-   
+
    memset(&req, 0, sizeof(req));
    req.msg.netfn    = IPMI_NETFN_PICMG;
 	req.msg.cmd      = HPMFWUPG_INITIATE_UPGRADE_ACTION;
 	req.msg.data     = (unsigned char*)&pCtx->req;
 	req.msg.data_len = sizeof(struct HpmfwupgInitiateUpgradeActionReq);
-   
-   rsp = HpmfwupgSendCmd(intf, req, pFwupgCtx); 
-   
+
+   rsp = HpmfwupgSendCmd(intf, req, pFwupgCtx);
+
    if ( rsp )
    {
       /* Long duration command handling */
@@ -2750,9 +2908,9 @@ int HpmfwupgInitiateUpgradeAction(struct ipmi_intf *intf, struct HpmfwupgInitiat
    }
 
    return rc;
-} 
+}
 
-int HpmfwupgUploadFirmwareBlock(struct ipmi_intf *intf, struct HpmfwupgUploadFirmwareBlockCtx* pCtx, 
+int HpmfwupgUploadFirmwareBlock(struct ipmi_intf *intf, struct HpmfwupgUploadFirmwareBlockCtx* pCtx,
                                 struct HpmfwupgUpgradeCtx* pFwupgCtx, int count
                                ,unsigned int *imageOffset, unsigned int *blockLength )
 {
@@ -2768,26 +2926,26 @@ int HpmfwupgUploadFirmwareBlock(struct ipmi_intf *intf, struct HpmfwupgUploadFir
    req.msg.data     = (unsigned char*)&pCtx->req;
   /* 2 is the size of the upload struct - data */
    req.msg.data_len = 2 + count;
-   
-   rsp = HpmfwupgSendCmd(intf, req, pFwupgCtx); 
-   
+
+   rsp = HpmfwupgSendCmd(intf, req, pFwupgCtx);
+
    if ( rsp )
    {
-      if ( rsp->ccode == HPMFWUPG_COMMAND_IN_PROGRESS || 
+      if ( rsp->ccode == HPMFWUPG_COMMAND_IN_PROGRESS ||
            rsp->ccode == 0x00 )
       {
-         /* 
-          * We need to check if the response also contains the next upload firmware offset 
+         /*
+          * We need to check if the response also contains the next upload firmware offset
           * and the firmware length in its response - These are optional but very vital
           */
         if ( rsp->data_len > 1 )
         {
-         /* 
-          * If the response data length is greater than 1 it should contain both the 
-          * the Section offset and section length. Because we cannot just have 
+         /*
+          * If the response data length is greater than 1 it should contain both the
+          * the Section offset and section length. Because we cannot just have
           * Section offset without section length so the length should be 9
           */
-          if ( rsp->data_len == 9 ) 
+          if ( rsp->data_len == 9 )
           {
              /* rsp->data[1] - LSB  rsp->data[2]  - rsp->data[3] = MSB */
              *imageOffset = (rsp->data[4] << 24) + (rsp->data[3] << 16) + (rsp->data[2] << 8) + rsp->data[1];
@@ -2796,8 +2954,8 @@ int HpmfwupgUploadFirmwareBlock(struct ipmi_intf *intf, struct HpmfwupgUploadFir
           else
           {
               /*
-               * The Spec does not say much for this kind of errors where the 
-               * firmware returned only offset and length so currently returning it 
+               * The Spec does not say much for this kind of errors where the
+               * firmware returned only offset and length so currently returning it
                * as 0x82 - Internal CheckSum Error
                */
               lprintf(LOG_NOTICE,"Error wrong rsp->datalen %d for Upload Firmware block command\n",rsp->data_len);
@@ -2810,15 +2968,11 @@ int HpmfwupgUploadFirmwareBlock(struct ipmi_intf *intf, struct HpmfwupgUploadFir
       {
          rc = HpmfwupgWaitLongDurationCmd(intf, pFwupgCtx);
       }
-      /* 
-       * If we get 0xcc here this is probably because we send an invalid sequence
-       * number (Packet sent twice). Continue as if we had no error.
-       */
-      else if ( (rsp->ccode != 0x00) && (rsp->ccode != 0xcc) )
+      else if (rsp->ccode != 0x00) 
       {
          /*
           * PATCH --> This validation is to handle retryables errors codes on IPMB bus.
-          *           This will be fixed in the next release of open ipmi and this 
+          *           This will be fixed in the next release of open ipmi and this
           *           check will have to be removed. (Buggy version = 39)
           */
          if ( HPMFWUPG_IS_RETRYABLE(rsp->ccode) )
@@ -2826,8 +2980,8 @@ int HpmfwupgUploadFirmwareBlock(struct ipmi_intf *intf, struct HpmfwupgUploadFir
             lprintf(LOG_DEBUG,"HPM: [PATCH]Retryable error detected");
             rc = HPMFWUPG_UPLOAD_RETRY;
          }
-         /* 
-          * If completion code = 0xc7, we will retry with a reduced buffer length. 
+         /*
+          * If completion code = 0xc7, we will retry with a reduced buffer length.
           * Do not print error.
           */
          else if ( rsp->ccode == IPMI_CC_REQ_DATA_INV_LENGTH )
@@ -2846,27 +3000,27 @@ int HpmfwupgUploadFirmwareBlock(struct ipmi_intf *intf, struct HpmfwupgUploadFir
       lprintf(LOG_NOTICE,"Error uploading firmware block\n");
       rc = HPMFWUPG_ERROR;
    }
-   
+
    return rc;
-}  
+}
 
 int HpmfwupgFinishFirmwareUpload(struct ipmi_intf *intf, struct HpmfwupgFinishFirmwareUploadCtx* pCtx,
-                                 struct HpmfwupgUpgradeCtx* pFwupgCtx)                         
+                                 struct HpmfwupgUpgradeCtx* pFwupgCtx)
 {
    int    rc = HPMFWUPG_SUCCESS;
    struct ipmi_rs * rsp;
    struct ipmi_rq   req;
-   
+
    pCtx->req.picmgId = HPMFWUPG_PICMG_IDENTIFIER;
-   
+
    memset(&req, 0, sizeof(req));
    req.msg.netfn    = IPMI_NETFN_PICMG;
 	req.msg.cmd      = HPMFWUPG_FINISH_FIRMWARE_UPLOAD;
 	req.msg.data     = (unsigned char*)&pCtx->req;
 	req.msg.data_len = sizeof(struct HpmfwupgFinishFirmwareUploadReq);
-   
-   rsp = HpmfwupgSendCmd(intf, req, pFwupgCtx); 
-   
+
+   rsp = HpmfwupgSendCmd(intf, req, pFwupgCtx);
+
    if ( rsp )
    {
       /* Long duration command handling */
@@ -2885,28 +3039,28 @@ int HpmfwupgFinishFirmwareUpload(struct ipmi_intf *intf, struct HpmfwupgFinishFi
       lprintf(LOG_NOTICE,"Error fininshing firmware upload\n");
       rc = HPMFWUPG_ERROR;
    }
-   
+
    return rc;
-} 
+}
 
 int HpmfwupgActivateFirmware(struct ipmi_intf *intf, struct HpmfwupgActivateFirmwareCtx* pCtx,
-                             struct HpmfwupgUpgradeCtx* pFwupgCtx)               
+                             struct HpmfwupgUpgradeCtx* pFwupgCtx)
 {
    int    rc = HPMFWUPG_SUCCESS;
    struct ipmi_rs * rsp;
    struct ipmi_rq   req;
-   
+
    pCtx->req.picmgId = HPMFWUPG_PICMG_IDENTIFIER;
-   
+
    memset(&req, 0, sizeof(req));
    req.msg.netfn    = IPMI_NETFN_PICMG;
 	req.msg.cmd      = HPMFWUPG_ACTIVATE_FIRMWARE;
 	req.msg.data     = (unsigned char*)&pCtx->req;
         req.msg.data_len = sizeof(struct HpmfwupgActivateFirmwareReq) -
           (!pCtx->req.rollback_override ? 1 : 0);
-      
-   rsp = HpmfwupgSendCmd(intf, req, pFwupgCtx); 
-   
+
+   rsp = HpmfwupgSendCmd(intf, req, pFwupgCtx);
+
    if ( rsp )
    {
       /* Long duration command handling */
@@ -2914,7 +3068,7 @@ int HpmfwupgActivateFirmware(struct ipmi_intf *intf, struct HpmfwupgActivateFirm
       {
          printf("Waiting firmware activation...");
          fflush(stdout);
-         
+
          rc = HpmfwupgWaitLongDurationCmd(intf, pFwupgCtx);
 
          if ( rc == HPMFWUPG_SUCCESS )
@@ -2928,7 +3082,7 @@ int HpmfwupgActivateFirmware(struct ipmi_intf *intf, struct HpmfwupgActivateFirm
       }
       else if ( rsp->ccode != IPMI_CC_OK )
       {
-         lprintf(LOG_NOTICE,"Error activating firmware, compcode = %x\n",  
+         lprintf(LOG_NOTICE,"Error activating firmware, compcode = %x\n",
                             rsp->ccode);
          rc = HPMFWUPG_ERROR;
       }
@@ -2940,7 +3094,7 @@ int HpmfwupgActivateFirmware(struct ipmi_intf *intf, struct HpmfwupgActivateFirm
    }
 
    return rc;
-}                                
+}
 
 int HpmfwupgGetUpgradeStatus(struct ipmi_intf *intf, struct HpmfwupgGetUpgradeStatusCtx* pCtx,
                              struct HpmfwupgUpgradeCtx* pFwupgCtx)
@@ -2948,23 +3102,23 @@ int HpmfwupgGetUpgradeStatus(struct ipmi_intf *intf, struct HpmfwupgGetUpgradeSt
    int    rc = HPMFWUPG_SUCCESS;
    struct ipmi_rs * rsp;
    struct ipmi_rq   req;
-   
+
    pCtx->req.picmgId = HPMFWUPG_PICMG_IDENTIFIER;
-   
+
    memset(&req, 0, sizeof(req));
    req.msg.netfn    = IPMI_NETFN_PICMG;
 	req.msg.cmd      = HPMFWUPG_GET_UPGRADE_STATUS;
 	req.msg.data     = (unsigned char*)&pCtx->req;
 	req.msg.data_len = sizeof(struct HpmfwupgGetUpgradeStatusReq);
-   
+
    rsp = HpmfwupgSendCmd(intf, req, pFwupgCtx);
-   
+
    if ( rsp )
-   {                                                                              
+   {
       if ( rsp->ccode == 0x00 )
       {
          memcpy(&pCtx->resp, rsp->data, sizeof(struct HpmfwupgGetUpgradeStatusResp));
-         if ( verbose )
+         if ( verbose > 1 )
          {
             lprintf(LOG_NOTICE,"Upgrade status:");
             lprintf(LOG_NOTICE," Command in progress:          %x", pCtx->resp.cmdInProcess);
@@ -2973,7 +3127,7 @@ int HpmfwupgGetUpgradeStatus(struct ipmi_intf *intf, struct HpmfwupgGetUpgradeSt
       }
       /*
        * PATCH --> This validation is to handle retryables errors codes on IPMB bus.
-       *           This will be fixed in the next release of open ipmi and this 
+       *           This will be fixed in the next release of open ipmi and this
        *           check will have to be removed. (Buggy version = 39)
        */
       else if ( HPMFWUPG_IS_RETRYABLE(rsp->ccode) )
@@ -2999,9 +3153,9 @@ int HpmfwupgGetUpgradeStatus(struct ipmi_intf *intf, struct HpmfwupgGetUpgradeSt
          rc = HPMFWUPG_ERROR;
       }
    }
-   
+
    return rc;
-}  
+}
 
 int HpmfwupgManualFirmwareRollback(struct ipmi_intf *intf, struct HpmfwupgManualFirmwareRollbackCtx* pCtx,
                                    struct HpmfwupgUpgradeCtx* pFwupgCtx)
@@ -3009,17 +3163,17 @@ int HpmfwupgManualFirmwareRollback(struct ipmi_intf *intf, struct HpmfwupgManual
    int    rc = HPMFWUPG_SUCCESS;
    struct ipmi_rs * rsp;
    struct ipmi_rq   req;
-     
+
    pCtx->req.picmgId = HPMFWUPG_PICMG_IDENTIFIER;
-   
+
    memset(&req, 0, sizeof(req));
    req.msg.netfn    = IPMI_NETFN_PICMG;
 	req.msg.cmd      = HPMFWUPG_MANUAL_FIRMWARE_ROLLBACK;
 	req.msg.data     = (unsigned char*)&pCtx->req;
 	req.msg.data_len = sizeof(struct HpmfwupgManualFirmwareRollbackReq);
-      
-   rsp = HpmfwupgSendCmd(intf, req, pFwupgCtx); 
-   
+
+   rsp = HpmfwupgSendCmd(intf, req, pFwupgCtx);
+
    if ( rsp )
    {
       /* Long duration command handling */
@@ -3042,7 +3196,7 @@ int HpmfwupgManualFirmwareRollback(struct ipmi_intf *intf, struct HpmfwupgManual
       rc = HPMFWUPG_ERROR;
    }
    return rc;
-}                                      
+}
 
 int HpmfwupgQueryRollbackStatus(struct ipmi_intf *intf, struct HpmfwupgQueryRollbackStatusCtx* pCtx,
                                 struct HpmfwupgUpgradeCtx* pFwupgCtx)
@@ -3050,18 +3204,18 @@ int HpmfwupgQueryRollbackStatus(struct ipmi_intf *intf, struct HpmfwupgQueryRoll
    int    rc = HPMFWUPG_SUCCESS;
    struct ipmi_rs * rsp;
    struct ipmi_rq   req;
-   unsigned char rollbackTimeout = 0;
+   unsigned int rollbackTimeout = 0;
    unsigned int  timeoutSec1, timeoutSec2;
-     
+
    pCtx->req.picmgId = HPMFWUPG_PICMG_IDENTIFIER;
-   
+
    memset(&req, 0, sizeof(req));
    req.msg.netfn    = IPMI_NETFN_PICMG;
 	req.msg.cmd      = HPMFWUPG_QUERY_ROLLBACK_STATUS;
 	req.msg.data     = (unsigned char*)&pCtx->req;
 	req.msg.data_len = sizeof(struct HpmfwupgQueryRollbackStatusReq);
-   
-   /* 
+
+   /*
     * If we are not in upgrade context, we use default timeout values
     */
    if ( pFwupgCtx != NULL )
@@ -3070,9 +3224,20 @@ int HpmfwupgQueryRollbackStatus(struct ipmi_intf *intf, struct HpmfwupgQueryRoll
    }
    else
    {
-      rollbackTimeout = HPMFWUPG_DEFAULT_UPGRADE_TIMEOUT;
+      struct HpmfwupgGetTargetUpgCapabilitiesCtx targetCapCmd;
+      verbose--;
+      rc = HpmfwupgGetTargetUpgCapabilities(intf, &targetCapCmd);
+      verbose++;
+      if ( rc == HPMFWUPG_SUCCESS )
+      {
+         rollbackTimeout = targetCapCmd.resp.rollbackTimeout *5;
+      }
+      else
+      {
+         rollbackTimeout = HPMFWUPG_DEFAULT_UPGRADE_TIMEOUT;
+      }
    }
-   
+
    /* Poll rollback status until completion or timeout */
    timeoutSec1 = time(NULL);
    timeoutSec2 = time(NULL);
@@ -3083,7 +3248,7 @@ int HpmfwupgQueryRollbackStatus(struct ipmi_intf *intf, struct HpmfwupgQueryRoll
       rsp = HpmfwupgSendCmd(intf, req, pFwupgCtx);
       /*
        * PATCH --> This validation is to handle retryables errors codes on IPMB bus.
-       *           This will be fixed in the next release of open ipmi and this 
+       *           This will be fixed in the next release of open ipmi and this
        *           check will have to be removed. (Buggy version = 39)
        */
       if ( rsp )
@@ -3095,11 +3260,12 @@ int HpmfwupgQueryRollbackStatus(struct ipmi_intf *intf, struct HpmfwupgQueryRoll
          }
       }
       timeoutSec2 = time(NULL);
-      
+
    }while( rsp &&
-          (rsp->ccode == HPMFWUPG_COMMAND_IN_PROGRESS) &&
+          ((rsp->ccode == HPMFWUPG_COMMAND_IN_PROGRESS) ||
+           (rsp->ccode == IPMI_CC_TIMEOUT)) &&
           (timeoutSec2 - timeoutSec1 < rollbackTimeout ) );
-   
+
    if ( rsp )
    {
       if ( rsp->ccode == 0x00 )
@@ -3118,7 +3284,7 @@ int HpmfwupgQueryRollbackStatus(struct ipmi_intf *intf, struct HpmfwupgQueryRoll
       }
       else if ( rsp->ccode == 0x81 )
       {
-         lprintf(LOG_NOTICE,"Rollback failed on component mask: 0x%02x",  
+         lprintf(LOG_NOTICE,"Rollback failed on component mask: 0x%02x",
                                                 pCtx->resp.rollbackComp.ComponentBits.byte);
          rc = HPMFWUPG_ERROR;
       }
@@ -3133,22 +3299,22 @@ int HpmfwupgQueryRollbackStatus(struct ipmi_intf *intf, struct HpmfwupgQueryRoll
       lprintf(LOG_NOTICE,"Error getting upgrade status\n");
       rc = HPMFWUPG_ERROR;
    }
-   
+
    return rc;
-} 
+}
 
 int HpmfwupgQuerySelftestResult(struct ipmi_intf *intf, struct HpmfwupgQuerySelftestResultCtx* pCtx,
-                                struct HpmfwupgUpgradeCtx* pFwupgCtx)                                  
+                                struct HpmfwupgUpgradeCtx* pFwupgCtx)
 {
    int    rc = HPMFWUPG_SUCCESS;
    struct ipmi_rs * rsp;
    struct ipmi_rq   req;
    unsigned char selfTestTimeout = 0;
    unsigned int  timeoutSec1, timeoutSec2;
-      
+
    pCtx->req.picmgId = HPMFWUPG_PICMG_IDENTIFIER;
-   
-   /* 
+
+   /*
     * If we are not in upgrade context, we use default timeout values
     */
    if ( pFwupgCtx != NULL )
@@ -3162,14 +3328,14 @@ int HpmfwupgQuerySelftestResult(struct ipmi_intf *intf, struct HpmfwupgQuerySelf
    {
       selfTestTimeout = HPMFWUPG_DEFAULT_UPGRADE_TIMEOUT;
    }
-   
+
    memset(&req, 0, sizeof(req));
    req.msg.netfn    = IPMI_NETFN_PICMG;
 	req.msg.cmd      = HPMFWUPG_QUERY_SELFTEST_RESULT;
 	req.msg.data     = (unsigned char*)&pCtx->req;
 	req.msg.data_len = sizeof(struct HpmfwupgQuerySelftestResultReq);
-   
-   
+
+
    /* Poll rollback status until completion or timeout */
    timeoutSec1 = time(NULL);
    timeoutSec2 = time(NULL);
@@ -3180,7 +3346,7 @@ int HpmfwupgQuerySelftestResult(struct ipmi_intf *intf, struct HpmfwupgQuerySelf
       rsp = HpmfwupgSendCmd(intf, req, pFwupgCtx);
       /*
        * PATCH --> This validation is to handle retryables errors codes on IPMB bus.
-       *           This will be fixed in the next release of open ipmi and this 
+       *           This will be fixed in the next release of open ipmi and this
        *           check will have to be removed. (Buggy version = 39)
        */
       if ( rsp )
@@ -3192,11 +3358,11 @@ int HpmfwupgQuerySelftestResult(struct ipmi_intf *intf, struct HpmfwupgQuerySelf
          }
       }
       timeoutSec2 = time(NULL);
-      
+
    }while( rsp &&
           (rsp->ccode == HPMFWUPG_COMMAND_IN_PROGRESS) &&
           (timeoutSec2 - timeoutSec1 < selfTestTimeout ) );
-   
+
    if ( rsp )
    {
       if ( rsp->ccode == 0x00 )
@@ -3220,20 +3386,20 @@ int HpmfwupgQuerySelftestResult(struct ipmi_intf *intf, struct HpmfwupgQuerySelf
        lprintf(LOG_NOTICE,"Error getting upgrade status\n");
        rc = HPMFWUPG_ERROR;
    }
-      
+
    return rc;
 }
 
-struct ipmi_rs * HpmfwupgSendCmd(struct ipmi_intf *intf, struct ipmi_rq req, 
+struct ipmi_rs * HpmfwupgSendCmd(struct ipmi_intf *intf, struct ipmi_rq req,
                                  struct HpmfwupgUpgradeCtx* pFwupgCtx )
 {
    struct ipmi_rs * rsp;
-   unsigned char inaccessTimeout = 0, inaccessTimeoutCounter = 0;
-   unsigned char upgradeTimeout  = 0, upgradeTimeoutCounter  = 0;
+   unsigned int inaccessTimeout = 0, inaccessTimeoutCounter = 0;
+   unsigned int upgradeTimeout  = 0, upgradeTimeoutCounter  = 0;
    unsigned int  timeoutSec1, timeoutSec2;
-   unsigned char retry = 0; 
-      
-   /* 
+   unsigned char retry = 0;
+
+   /*
     * If we are not in upgrade context, we use default timeout values
     */
    if ( pFwupgCtx != NULL )
@@ -3243,7 +3409,7 @@ struct ipmi_rs * HpmfwupgSendCmd(struct ipmi_intf *intf, struct ipmi_rq req,
    }
    else
    {
-      /* keeping the inaccessTimeout to 60 seconds results in almost 2900 retries 
+      /* keeping the inaccessTimeout to 60 seconds results in almost 2900 retries
        * So if the target is not available it will be retrying the command for 2900
        * times which is not effecient -So reducing the Timout to 5 seconds which is
        * almost 200 retries if it continuously recieves 0xC3 as completion code.
@@ -3251,16 +3417,18 @@ struct ipmi_rs * HpmfwupgSendCmd(struct ipmi_intf *intf, struct ipmi_rq req,
       inaccessTimeout = HPMFWUPG_DEFAULT_UPGRADE_TIMEOUT;
       upgradeTimeout  = HPMFWUPG_DEFAULT_UPGRADE_TIMEOUT;
    }
-   
+
    timeoutSec1 = time(NULL);
-      
+
    do
    {
+      static unsigned char isValidSize = FALSE;
       rsp = intf->sendrecv(intf, &req);
-      
-      if( rsp == NULL ) 
+
+      if( ( rsp == NULL ) )
       {
          #define HPM_LAN_PACKET_RESIZE_LIMIT 6
+
          if(strstr(intf->name,"lan")!= NULL) /* also covers lanplus */
          {
             static int errorCount=0;
@@ -3269,14 +3437,16 @@ struct ipmi_rs * HpmfwupgSendCmd(struct ipmi_intf *intf, struct ipmi_rq req,
             lprintf(LOG_DEBUG,"HPM: no response available");
             lprintf(LOG_DEBUG,"HPM: the command may be rejected for " \
                               "security reasons");
-                              
+
             if
-            ( 
+            (
                req.msg.netfn == IPMI_NETFN_PICMG
                &&
                req.msg.cmd == HPMFWUPG_UPLOAD_FIRMWARE_BLOCK
                &&
-               errorCount < HPM_LAN_PACKET_RESIZE_LIMIT 
+               errorCount < HPM_LAN_PACKET_RESIZE_LIMIT
+               && 
+               (!isValidSize) 
             )
             {
                lprintf(LOG_DEBUG,"HPM: upload firmware block API called");
@@ -3286,44 +3456,43 @@ struct ipmi_rs * HpmfwupgSendCmd(struct ipmi_intf *intf, struct ipmi_rq req,
                rsp = &fakeRsp;
                errorCount++;
             }
-            else if 
-            ( 
+            else if
+            (
                req.msg.netfn == IPMI_NETFN_PICMG
                &&
                ( req.msg.cmd == HPMFWUPG_ACTIVATE_FIRMWARE ||
                  req.msg.cmd == HPMFWUPG_MANUAL_FIRMWARE_ROLLBACK )
             )
             {
-               /* 
-                * rsp == NULL and command activate firmware or manual firmware 
-                * rollback most likely occurs when we have sent a firmware activation 
+               /*
+                * rsp == NULL and command activate firmware or manual firmware
+                * rollback most likely occurs when we have sent a firmware activation
                 * request. Fake a command in progress response.
                 */
                lprintf(LOG_DEBUG,"HPM: activate/rollback firmware API called");
                lprintf(LOG_DEBUG,"HPM: returning in progress to handle IOL session lost");
-                            
+
                fakeRsp.ccode = HPMFWUPG_COMMAND_IN_PROGRESS;
                rsp = &fakeRsp;
             }
-            else if 
-            ( 
+            else if
+            (
                req.msg.netfn == IPMI_NETFN_PICMG
                &&
                ( req.msg.cmd == HPMFWUPG_QUERY_ROLLBACK_STATUS ||
                  req.msg.cmd == HPMFWUPG_GET_UPGRADE_STATUS )
             )
             {
-               /* 
+               /*
                 * rsp == NULL and command get upgrade status or query rollback
-                * status most likely occurs when we are waiting for firmware 
+                * status most likely occurs when we are waiting for firmware
                 * activation. Try to re-open the IOL session (re-open will work
                 * once the IPMC recovers from firmware activation.
                 */
-                
+
                lprintf(LOG_DEBUG,"HPM: upg/rollback status firmware API called");
                lprintf(LOG_DEBUG,"HPM: try to re-open IOL session");
-               
-               if ( intf->target_addr ==  intf->my_addr )
+
                {
                   /* force session re-open */
                   intf->opened              = 0;
@@ -3333,13 +3502,13 @@ struct ipmi_rs * HpmfwupgSendCmd(struct ipmi_intf *intf, struct ipmi_rq req,
                   intf->session->out_seq    = 0;
                   intf->session->active     = 0;
                   intf->session->retry      = 10;
-               
-                  while 
-                  ( 
-                     intf->open(intf) == HPMFWUPG_ERROR 
+
+                  while
+                  (
+                     intf->open(intf) == HPMFWUPG_ERROR
                      &&
                      inaccessTimeoutCounter < inaccessTimeout
-                  ) 
+                  )
                   {
                      inaccessTimeoutCounter += (time(NULL) - timeoutSec1);
                      timeoutSec1 = time(NULL);
@@ -3351,11 +3520,11 @@ struct ipmi_rs * HpmfwupgSendCmd(struct ipmi_intf *intf, struct ipmi_rq req,
             }
          }
       }
-      
+
      /* Handle inaccessibility timeout (rsp = NULL if IOL) */
      if ( rsp == NULL || rsp->ccode == 0xff || rsp->ccode == 0xc3 || rsp->ccode == 0xd3 )
      {
-        if ( inaccessTimeoutCounter < inaccessTimeout ) 
+        if ( inaccessTimeoutCounter < inaccessTimeout )
         {
            timeoutSec2 = time(NULL);
            if ( timeoutSec2 > timeoutSec1 )
@@ -3374,7 +3543,7 @@ struct ipmi_rs * HpmfwupgSendCmd(struct ipmi_intf *intf, struct ipmi_rq req,
      /* Handle node busy timeout */
      else if ( rsp->ccode == 0xc0 )
      {
-        if ( upgradeTimeoutCounter < upgradeTimeout ) 
+        if ( upgradeTimeoutCounter < upgradeTimeout )
         {
            timeoutSec2 = time(NULL);
            if ( timeoutSec2 > timeoutSec1 )
@@ -3399,58 +3568,94 @@ struct ipmi_rs * HpmfwupgSendCmd(struct ipmi_intf *intf, struct ipmi_rq req,
         }
         #endif
         retry = 0;
+	
+	if
+	(
+	 req.msg.netfn == IPMI_NETFN_PICMG
+	 &&
+	 req.msg.cmd == HPMFWUPG_UPLOAD_FIRMWARE_BLOCK
+	 &&
+	 (!isValidSize) 
+	)
+	{
+	   lprintf(LOG_INFO,"Buffer length is now considered valid" );
+
+	   isValidSize = TRUE;
+	}
      }
    }while( retry );
    return rsp;
-} 
+}
 
 int HpmfwupgWaitLongDurationCmd(struct ipmi_intf *intf, struct HpmfwupgUpgradeCtx* pFwupgCtx)
 {
    int rc = HPMFWUPG_SUCCESS;
-   unsigned char upgradeTimeout = 0;
+   unsigned int upgradeTimeout = 0;
    unsigned int  timeoutSec1, timeoutSec2;
    struct HpmfwupgGetUpgradeStatusCtx upgStatusCmd;
 
-   /* 
+   /*
     * If we are not in upgrade context, we use default timeout values
     */
    if ( pFwupgCtx != NULL )
    {
       upgradeTimeout = pFwupgCtx->targetCap.upgradeTimeout*5;
+      if ( verbose )
+          printf("Use File Upgrade Capabilities: %i seconds\n", upgradeTimeout);
    }
    else
    {
-      upgradeTimeout = HPMFWUPG_DEFAULT_UPGRADE_TIMEOUT;
+      /* Try to retreive from Caps */
+      struct HpmfwupgGetTargetUpgCapabilitiesCtx targetCapCmd;
+      
+      if(HpmfwupgGetTargetUpgCapabilities(intf, &targetCapCmd) != HPMFWUPG_SUCCESS)
+      {
+          upgradeTimeout = HPMFWUPG_DEFAULT_UPGRADE_TIMEOUT;
+
+          if ( verbose )
+              printf("Use default timeout: %i seconds\n", upgradeTimeout);
+      }
+      else
+      {
+          upgradeTimeout = (targetCapCmd.resp.upgradeTimeout * 5);
+          if ( verbose )
+              printf("Use Command Upgrade Capabilities Timeout: %i seconds\n", upgradeTimeout);
+      }
    }
 
-   /* Poll upgrade status until completion or timeout*/
-   timeoutSec1 = time(NULL);
-   timeoutSec2 = time(NULL);
-   rc = HpmfwupgGetUpgradeStatus(intf, &upgStatusCmd, pFwupgCtx);
-   
-   while((upgStatusCmd.resp.lastCmdCompCode == HPMFWUPG_COMMAND_IN_PROGRESS ) &&
-         (timeoutSec2 - timeoutSec1 < upgradeTimeout ) && 
-         (rc == HPMFWUPG_SUCCESS) )
+   if(rc == HPMFWUPG_SUCCESS)
    {
-      /* Must wait at least 100 ms between status requests */
-      usleep(100000);
+      /* Poll upgrade status until completion or timeout*/
+      timeoutSec1 = time(NULL);
       timeoutSec2 = time(NULL);
       rc = HpmfwupgGetUpgradeStatus(intf, &upgStatusCmd, pFwupgCtx);
    }
-  
+
+   while(
+         (upgStatusCmd.resp.lastCmdCompCode == HPMFWUPG_COMMAND_IN_PROGRESS ) &&
+         (timeoutSec2 - timeoutSec1 < upgradeTimeout ) &&
+         (rc == HPMFWUPG_SUCCESS) 
+        )
+   {
+      /* Must wait at least 1000 ms between status requests */
+      usleep(1000000);
+      rc = HpmfwupgGetUpgradeStatus(intf, &upgStatusCmd, pFwupgCtx);
+      //printf("Get Status: %x - %x = %x _ %x [%x]\n", timeoutSec2, timeoutSec1,(timeoutSec2 - timeoutSec1),upgradeTimeout, rc); 
+   }
+
    if ( upgStatusCmd.resp.lastCmdCompCode != 0x00 )
    {
       if ( verbose )
       {
-         lprintf(LOG_NOTICE,"Error waiting for command %x, compcode = %x",  
-                            upgStatusCmd.resp.cmdInProcess, 
+         lprintf(LOG_NOTICE,"Error waiting for command %x, compcode = %x",
+                            upgStatusCmd.resp.cmdInProcess,
                             upgStatusCmd.resp.lastCmdCompCode);
       }
       rc = HPMFWUPG_ERROR;
    }
-   
+
    return rc;
-}     
+}
 
 unsigned char HpmfwupgCalculateChecksum(unsigned char* pData, unsigned int length)
 {
@@ -3462,12 +3667,12 @@ unsigned char HpmfwupgCalculateChecksum(unsigned char* pData, unsigned int lengt
       checksum += pData[dataIdx];
    }
    return checksum;
-}   
+}
 
 static void HpmfwupgPrintUsage(void)
 {
-   lprintf(LOG_NOTICE,"help                    - This help menu");   
-   lprintf(LOG_NOTICE,"check                   - Check the target information");   
+   lprintf(LOG_NOTICE,"help                    - This help menu");
+   lprintf(LOG_NOTICE,"check                   - Check the target information");
    lprintf(LOG_NOTICE,"check <file>            - If the user is unsure of what update is going to be ");
    lprintf(LOG_NOTICE,"                          This will display the existing target version and image ");
    lprintf(LOG_NOTICE,"                          version on the screen");
@@ -3506,14 +3711,14 @@ int ipmi_hpmfwupg_main(struct ipmi_intf * intf, int argc, char ** argv)
    int activateFlag = 0x00;
    int componentId = DEFAULT_COMPONENT_UPLOAD;
    int option = VERSIONCHECK_MODE;
-   
+
    lprintf(LOG_DEBUG,"ipmi_hpmfwupg_main()");
-   
 
-   lprintf(LOG_NOTICE,"\nPICMG HPM.1 Upgrade Agent %d.%d.%d: \n", 
+
+   lprintf(LOG_NOTICE,"\nPICMG HPM.1 Upgrade Agent %d.%d.%d: \n",
            HPMFWUPG_VERSION_MAJOR, HPMFWUPG_VERSION_MINOR, HPMFWUPG_VERSION_SUBMINOR);
-   
-   if ( (argc == 0) || (strcmp(argv[0], "help") == 0) ) 
+
+   if ( (argc == 0) || (strcmp(argv[0], "help") == 0) )
    {
       HpmfwupgPrintUsage();
       return;
@@ -3535,8 +3740,8 @@ int ipmi_hpmfwupg_main(struct ipmi_intf * intf, int argc, char ** argv)
           }
        }
    }
-    
-   else if ( strcmp(argv[0], "upgrade") == 0) 
+
+   else if ( strcmp(argv[0], "upgrade") == 0)
    {
      int i =0;
      for (i=1; i< argc ; i++)
@@ -3555,14 +3760,19 @@ int ipmi_hpmfwupg_main(struct ipmi_intf * intf, int argc, char ** argv)
         /* hpm upgrade <filename> component <comp Id> */
         if (strcmp(argv[i],"component") == 0)
         {
-            if (i+1 < argc) 
-            {   
+            if (i+1 < argc)
+            {
                 componentId = atoi(argv[i+1]);
                 option &= ~(VERSIONCHECK_MODE);
                 option &= ~(VIEW_MODE);
                 option |= FORCE_MODE_COMPONENT;
+
+                if( verbose ) {
+                   lprintf(LOG_NOTICE,"Component Id %d provided",componentId );
+                }
+
                 /* Error Checking */
-                if (componentId >= HPMFWUPG_COMPONENT_ID_MAX) 
+                if (componentId >= HPMFWUPG_COMPONENT_ID_MAX)
                 {
                         lprintf(LOG_NOTICE,"Given component ID %d exceeds Max Comp ID %d\n",
                              componentId, HPMFWUPG_COMPONENT_ID_MAX-1);
@@ -3589,7 +3799,7 @@ int ipmi_hpmfwupg_main(struct ipmi_intf * intf, int argc, char ** argv)
         rc = HpmfwupgUpgrade(intf, argv[1],activateFlag,componentId,option);
       }
    }
-    
+
    else if ( (argc >= 1) && (strcmp(argv[0], "activate") == 0) )
    {
       struct HpmfwupgActivateFirmwareCtx cmdCtx;
@@ -3624,11 +3834,11 @@ int ipmi_hpmfwupg_main(struct ipmi_intf * intf, int argc, char ** argv)
       struct HpmfwupgGetUpgradeStatusCtx cmdCtx;
       verbose++;
       rc = HpmfwupgGetUpgradeStatus(intf, &cmdCtx, NULL);
-   }   
+   }
    else if ( (argc == 1) && (strcmp(argv[0], "rollback") == 0) )
    {
       struct HpmfwupgManualFirmwareRollbackCtx cmdCtx;
-      verbose++;  
+      verbose++;
       rc = HpmfwupgManualFirmwareRollback(intf, &cmdCtx, NULL);
    }
    else if ( (argc == 1) && (strcmp(argv[0], "rollbackstatus") == 0) )
@@ -3645,9 +3855,9 @@ int ipmi_hpmfwupg_main(struct ipmi_intf * intf, int argc, char ** argv)
    }
    else
    {
-      HpmfwupgPrintUsage(); 
+      HpmfwupgPrintUsage();
    }
-   
+
    return rc;
 }
 
diff --git a/lib/ipmi_ime.c b/lib/ipmi_ime.c
new file mode 100755
index 0000000..f6924de
--- /dev/null
+++ b/lib/ipmi_ime.c
@@ -0,0 +1,1033 @@
+/*
+ * Copyright (c) 2007 Kontron Canada, Inc.  All Rights Reserved.
+ *
+ * Base on code from
+ * Copyright (c) 2003 Sun Microsystems, Inc.  All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * Redistribution of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *
+ * Redistribution in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * Neither the name of Sun Microsystems, Inc. or the names of
+ * contributors may be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * This software is provided "AS IS," without a warranty of any kind.
+ * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES,
+ * INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A
+ * PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY EXCLUDED.
+ * SUN MICROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL NOT BE LIABLE
+ * FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING
+ * OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.  IN NO EVENT WILL
+ * SUN OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA,
+ * OR FOR DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR
+ * PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF
+ * LIABILITY, ARISING OUT OF THE USE OF OR INABILITY TO USE THIS SOFTWARE,
+ * EVEN IF SUN HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+ */
+
+/****************************************************************************
+*
+*       Copyright (c) 2009 Kontron Canada, Inc.  All Rights Reserved.
+*
+*                              IME
+*                    Intel Manageability Engine
+*                      Firmware Update Agent
+*
+* The ME is an IPMI-enabled component included in Intel(R) Next Generation
+*  Server Chipset Nehalem-EP platforms.
+*
+* These are a few synonyms for the ME :
+*
+* - Dynamic Power Node Manager
+* - Intelligent Power Node Manager
+* 
+* Consult Intel litterature for more information on this technology.
+*
+* The ME firmware resides on the platform boot flash and contains read only
+* boot code for the ME as well as boot image redundancy support. 
+*
+* This module implements an Upgrade Agent for the ME firwmare. Because the ME 
+* implements IPMI command handling, the agent speaks directly to the ME. In other
+* words, in order the reach the ME, the BMC must implement IPMB bridging.
+*
+* The update is done through IPMI (this is IPMITOOL right !), not HECI.
+*
+* Example: ME available at address 0x88 on IPMI channel 8:
+*   ipmitool  -m 0x20 -t 0x88 -b 8 ime info
+*
+* !! WARNING - You MUST use an image provided by your board vendor. - WARNING !!
+*
+* author:
+*  Jean-Michel.Audet@ca.kontron.com
+*  Francois.Isabelle@ca.kontron.com
+*
+*****************************************************************************/
+/*
+ * HISTORY
+ * ===========================================================================
+ * 2009-04-20
+ *
+ * First public release of Kontron
+ *
+*/
+#include <ipmitool/ipmi_ime.h>
+#include <ipmitool/log.h>
+#include <ipmitool/ipmi_intf.h>
+#include <ipmitool/ipmi_mc.h>
+#include <ipmitool/helper.h>
+#include <ipmitool/ipmi_strings.h>
+
+
+#undef OUTPUT_DEBUG
+
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+static const int IME_SUCCESS              = 0;
+static const int IME_ERROR                = -1;
+static const int IME_RESTART              = -2;
+
+#define IME_UPGRADE_BUFFER_SIZE           22
+#define IME_RETRY_COUNT                   5
+
+typedef struct ImeUpdateImageCtx
+{
+   uint32_t   size;
+   uint8_t *  pData;
+   uint8_t    crc8;
+}tImeUpdateImageCtx;
+
+typedef enum eImeState
+{
+   IME_STATE_IDLE                = 0,
+   IME_STATE_UPDATE_REQUESTED    = 1,
+   IME_STATE_UPDATE_IN_PROGRESS  = 2,
+   IME_STATE_SUCCESS             = 3,
+   IME_STATE_FAILED              = 4,
+   IME_STATE_ROLLED_BACK         = 5,
+   IME_STATE_ABORTED             = 6,
+   IME_STATE_INIT_FAILED         = 7
+} tImeStateEnum;
+
+
+typedef enum tImeUpdateType
+{
+   IME_UPDTYPE_NORMAL            = 1,
+   IME_UPDTYPE_MANUAL_ROLLBACK   = 3,
+   IME_UPDTYPE_ABORT             = 4
+} tImeUpdateType;
+
+
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
+typedef struct sImeStatus {
+   uint8_t image_status;
+   tImeStateEnum update_state;
+   uint8_t update_attempt_status;
+   uint8_t rollback_attempt_status;
+   uint8_t update_type;
+   uint8_t dependent_flag;
+   uint8_t free_area_size[4];
+} ATTRIBUTE_PACKING tImeStatus ;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
+
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
+typedef struct sImeCaps {
+   uint8_t area_supported;
+   uint8_t special_caps;
+} ATTRIBUTE_PACKING tImeCaps ;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
+
+
+static void ImePrintUsage(void);
+static int  ImeGetInfo(struct ipmi_intf *intf);
+static int  ImeUpgrade(struct ipmi_intf *intf, char* imageFilename);
+static int  ImeManualRollback(struct ipmi_intf *intf);
+static int  ImeUpdatePrepare(struct ipmi_intf *intf);
+static int  ImeUpdateOpenArea(struct ipmi_intf *intf);
+static int  ImeUpdateWriteArea(
+                              struct ipmi_intf *intf,
+                              uint8_t sequence, 
+                              uint8_t length, 
+                              uint8_t * pBuf
+                          );
+static int  ImeUpdateCloseArea(
+                              struct ipmi_intf *intf,
+                              uint32_t size, 
+                              uint16_t checksum
+                          );
+
+static int ImeUpdateGetStatus(struct ipmi_intf *intf, tImeStatus *pStatus);
+static int ImeUpdateGetCapabilities(struct ipmi_intf *intf, tImeCaps *pCaps );
+static int  ImeUpdateRegisterUpdate(struct ipmi_intf *intf, tImeUpdateType type);
+
+static int  ImeImageCtxFromFile(
+                                 char * imageFilename, 
+                                 tImeUpdateImageCtx * pImageCtx);
+static int ImeUpdateShowStatus(struct ipmi_intf *intf);
+
+static uint8_t ImeCrc8( uint32_t length, uint8_t * pBuf );
+
+
+static int ImeGetInfo(struct ipmi_intf *intf)
+{
+   int rc = IME_ERROR;
+   struct ipmi_rs * rsp;
+   struct ipmi_rq req;
+   struct ipm_devid_rsp *devid;
+   const char *product=NULL;
+   tImeStatus status;
+   tImeCaps caps;
+
+   memset(&req, 0, sizeof(req));
+   req.msg.netfn = IPMI_NETFN_APP;
+   req.msg.cmd = BMC_GET_DEVICE_ID;
+   req.msg.data_len = 0;
+
+   rsp = intf->sendrecv(intf, &req);
+   if (rsp == NULL) {
+      lprintf(LOG_ERR, "Get Device ID command failed");
+      return IME_ERROR;
+   }
+   if (rsp->ccode > 0) {
+      lprintf(LOG_ERR, "Get Device ID command failed: %s",
+         val2str(rsp->ccode, completion_code_vals));
+      return IME_ERROR;
+   }
+
+   devid = (struct ipm_devid_rsp *) rsp->data;
+
+   lprintf(LOG_DEBUG,"Device ID                 : %i", devid->device_id);
+   lprintf(LOG_DEBUG,"Device Revision           : %i",
+                           devid->device_revision & IPM_DEV_DEVICE_ID_REV_MASK);
+
+   if(
+      (devid->device_id == 0)
+      &&
+      ((devid->device_revision & IPM_DEV_DEVICE_ID_REV_MASK) == 0)
+      &&
+      (
+         (devid->manufacturer_id[0] == 0x57) // Intel
+         &&
+         (devid->manufacturer_id[1] == 0x01) // Intel
+         &&
+         (devid->manufacturer_id[2] == 0x00) // Intel
+      )
+      &&
+      (
+         (devid->product_id[1] == 0x0b)
+         &&
+         (devid->product_id[0] == 0x00)
+      )
+     )
+   {
+      rc = IME_SUCCESS;
+      printf("Manufacturer Name          : %s\n",
+               val2str( (long)IPM_DEV_MANUFACTURER_ID(devid->manufacturer_id), 
+               ipmi_oem_info) );
+
+      printf("Product ID                 : %u (0x%02x%02x)\n",
+         buf2short((uint8_t *)(devid->product_id)),
+         devid->product_id[1], devid->product_id[0]);
+ 
+      product=oemval2str(IPM_DEV_MANUFACTURER_ID(devid->manufacturer_id),
+                      (devid->product_id[1]<<8)+devid->product_id[0],
+                      ipmi_oem_product_info);
+
+      if (product!=NULL) 
+      {
+         printf("Product Name               : %s\n", product);
+      }
+
+      printf("Intel ME Firmware Revision : %x.%02x.%02x.%x%x%x.%x\n",
+            ((devid->fw_rev1 & IPM_DEV_FWREV1_MAJOR_MASK )         ),
+            ((devid->fw_rev2                             ) >>     4),
+            ((devid->fw_rev2                             )  &  0x0f),
+            ((devid->aux_fw_rev[1]                       ) >>     4),
+            ((devid->aux_fw_rev[1]                       )  &  0x0f),
+            ((devid->aux_fw_rev[2]                       ) >>     4),
+            ((devid->aux_fw_rev[2]                       )  &  0x0f)
+      );
+
+      printf("SPS FW IPMI cmd version    : %x.%x\n",
+         devid->aux_fw_rev[0] >>     4,
+         devid->aux_fw_rev[0] &  0x0f);
+
+      lprintf(LOG_DEBUG,"Flags: %xh", devid->aux_fw_rev[3]);
+
+      printf("Current Image Type         : ");
+      switch( (devid->aux_fw_rev[3] & 0x03) )
+      {
+         case 0:
+            printf("Recovery\n");
+         break;
+
+         case 1:
+            printf("Operational Image 1\n");
+         break;
+
+         case 2:
+            printf("Operational Image 2\n");
+         break;
+
+         case 3:
+         default:
+            printf("Unknown\n");
+         break;
+      }
+   }
+   else
+   {
+         printf("Supported ME not found\n");
+   }
+
+   if(rc == IME_SUCCESS)
+   {
+      rc = ImeUpdateGetStatus(intf, &status);
+   
+      if(rc == IME_SUCCESS)
+      {
+         rc = ImeUpdateGetCapabilities(intf, &caps);
+      }
+
+   }
+   
+   if(rc == IME_SUCCESS)
+   {
+      uint8_t newImage  = ((status.image_status >> 1) & 0x01);
+      uint8_t rollImage = ((status.image_status >> 2) & 0x01);
+      uint8_t runArea   = ((status.image_status >> 3) & 0x03);
+      uint8_t rollSup   = ((caps.special_caps   >> 0) & 0x01);
+      uint8_t recovSup  = ((caps.special_caps   >> 1) & 0x01);
+
+      uint8_t operSup   = ((caps.area_supported   >> 1) & 0x01);
+      uint8_t piaSup    = ((caps.area_supported   >> 2) & 0x01);
+      uint8_t sdrSup    = ((caps.area_supported   >> 3) & 0x01);
+
+      printf("\nSupported Area\n");
+      printf("   Operation Code          : %s\n", (operSup ? "Supported" : "Unsupported"));
+      printf("   PIA                     : %s\n", (piaSup ? "Supported" : "Unsupported"));
+      printf("   SDR                     : %s\n", (sdrSup ? "Supported" : "Unsupported"));
+
+      printf("\nSpecial Capabilities\n");
+      printf("   Rollback                : %s\n", (rollSup ? "Supported" : "Unsupported"));
+      printf("   Recovery                : %s\n", (recovSup ? "Supported" : "Unsupported"));
+
+      printf("\nImage Status\n");
+      printf("   Staging (new)           : %s\n", (newImage ? "Valid" : "Invalid"));
+      printf("   Rollback                : %s\n", (rollImage ? "Valid" : "Invalid"));
+      if(runArea == 0)
+         printf("   Running Image Area      : CODE\n");
+      else
+         printf("   Running Image Area      : CODE%d\n", runArea);
+
+  }
+
+   return rc;
+}
+
+
+static int ImeUpgrade(struct ipmi_intf *intf, char* imageFilename)
+{
+   int rc = IME_SUCCESS;
+   tImeUpdateImageCtx imgCtx;
+   tImeStatus imeStatus;
+   time_t start,end,current;
+   
+   time(&start);
+
+   memset(&imgCtx, 0, sizeof(tImeUpdateImageCtx));
+
+   rc = ImeImageCtxFromFile(imageFilename, &imgCtx);
+
+   if(
+      (rc == IME_ERROR) ||
+      (imgCtx.pData == NULL) ||
+      (imgCtx.size == 0)
+     )
+   {
+      return IME_ERROR;
+   }
+
+   ImeUpdateGetStatus(intf,&imeStatus);
+
+   if(rc == IME_SUCCESS)
+   {
+      rc = ImeUpdatePrepare(intf);
+      ImeUpdateGetStatus(intf,&imeStatus);
+   }
+
+   if(
+      (rc == IME_SUCCESS) &&
+      (imeStatus.update_state == IME_STATE_UPDATE_REQUESTED) 
+     )
+   {
+      rc = ImeUpdateOpenArea(intf);
+      ImeUpdateGetStatus(intf,&imeStatus);
+   }
+   else if(rc == IME_SUCCESS)
+   {
+      lprintf(LOG_ERROR,"ME state error (%i), aborting", imeStatus.update_state);
+      rc = IME_ERROR;
+   }
+
+
+   if(
+      (rc == IME_SUCCESS) &&
+      (imeStatus.update_state == IME_STATE_UPDATE_IN_PROGRESS) 
+     )
+   {
+      uint8_t sequence = 0;
+      uint32_t counter = 0;
+      uint8_t retry = 0;
+      uint8_t shownPercent = 0xff;
+
+      while(   
+            (counter < imgCtx.size) && 
+            (rc == IME_SUCCESS) &&
+            (retry < IME_RETRY_COUNT)
+           )
+      {
+         uint8_t length = IME_UPGRADE_BUFFER_SIZE;
+         uint8_t currentPercent;
+
+         if( (imgCtx.size - counter) < IME_UPGRADE_BUFFER_SIZE )
+         {
+            length = (imgCtx.size - counter);
+         }
+
+         rc = ImeUpdateWriteArea(intf,sequence,length,&imgCtx.pData[counter]);
+         
+         /*
+         As per the flowchart Intel Dynamic Power Node Manager 1.5 IPMI Iface
+         page 65
+         We shall send the GetStatus command each time following a write area
+         but this add too much time to the upgrade
+         */   
+         /*  ImeUpdateGetStatus(intf,&imeStatus); */
+         counter += length;
+         sequence ++;
+
+
+         currentPercent = ((float)counter/imgCtx.size)*100;
+
+         if(currentPercent != shownPercent)
+         {
+            uint16_t timeElapsedSecond;
+            uint16_t timeRemainingSecond;
+            shownPercent = currentPercent;
+            printf("Percent: %02i,  ", shownPercent);
+            time(&current);
+            timeElapsedSecond = (current-start) + ((current-start)%60);
+            printf("Elapsed time %02d:%02d\r",((current-start)/60), ((current-start)%60));
+            fflush(stdout);
+
+         }
+      }
+      ImeUpdateGetStatus(intf,&imeStatus);
+      printf("\n");
+   }
+   else if(rc == IME_SUCCESS)
+   {
+      lprintf(LOG_ERROR,"ME state error (%i), aborting", imeStatus.update_state);
+      rc = IME_ERROR;
+   }
+
+   if(
+      (rc == IME_SUCCESS) &&
+      (imeStatus.update_state == IME_STATE_UPDATE_IN_PROGRESS) 
+     )
+   {
+      rc = ImeUpdateCloseArea(intf, imgCtx.size, imgCtx.crc8);
+      ImeUpdateGetStatus(intf,&imeStatus);
+   }
+   else if(rc == IME_SUCCESS)
+   {
+      lprintf(LOG_ERROR,"ME state error, aborting");
+      rc = IME_ERROR;
+   }
+
+   if(
+      (rc == IME_SUCCESS) &&
+      (imeStatus.update_state == IME_STATE_UPDATE_REQUESTED) 
+     )
+   {
+      printf("UpdateCompleted, Activate now\n");
+      rc = ImeUpdateRegisterUpdate(intf, IME_UPDTYPE_NORMAL);
+      ImeUpdateGetStatus(intf,&imeStatus);
+   }
+   else if(rc == IME_SUCCESS)
+   {
+      lprintf(LOG_ERROR,"ME state error, aborting");
+      rc = IME_ERROR;
+   }
+
+   if(
+      (rc == IME_SUCCESS) &&
+      (imeStatus.update_state == IME_STATE_SUCCESS) 
+     )
+   {
+      time(&end);
+      printf("Update Completed in %02d:%02d\n",(end-start)/60, (end-start)%60);
+   }
+   else
+   {
+      time(&end);
+      printf("Update Error\n");
+      printf("\nTime Taken %02d:%02d\n",(end-start)/60, (end-start)%60);
+   }
+
+   return rc;
+}
+
+
+static int ImeUpdatePrepare(struct ipmi_intf *intf)
+{
+   struct ipmi_rs * rsp;
+   struct ipmi_rq req;
+
+   #ifdef OUTPUT_DEBUG
+   printf("ImeUpdatePrepare\n");
+   #endif
+
+   memset(&req, 0, sizeof(req));
+   req.msg.netfn = 0x30;  // OEM NetFn
+   req.msg.cmd = 0xA0;
+   req.msg.data_len = 0;
+
+   rsp = intf->sendrecv(intf, &req);
+   if (rsp == NULL) {
+      lprintf(LOG_ERR, "UpdatePrepare command failed");
+      return IME_ERROR;
+   }
+   if (rsp->ccode > 0) {
+      lprintf(LOG_ERR, "UpdatePrepare command failed: %s",
+         val2str(rsp->ccode, completion_code_vals));
+      return IME_ERROR;
+   }
+
+   lprintf(LOG_DEBUG, "UpdatePrepare command succeed");
+   return IME_SUCCESS;
+}
+
+static int ImeUpdateOpenArea(struct ipmi_intf *intf)
+{
+   struct ipmi_rs * rsp;
+   struct ipmi_rq req;
+   uint8_t buffer[ 2 ];
+
+   #ifdef OUTPUT_DEBUG
+   printf("ImeUpdateOpenArea\n");
+   #endif
+
+   memset(&req, 0, sizeof(req));
+   req.msg.netfn = 0x30;  // OEM NetFn
+   req.msg.cmd = 0xA1;
+
+   buffer[0] = 0x01; // Area Type : Operational code
+   buffer[1] = 0x00; // Reserved : 0
+   req.msg.data = buffer;
+
+   req.msg.data_len = 2;
+
+   rsp = intf->sendrecv(intf, &req);
+   if (rsp == NULL) {
+      lprintf(LOG_ERR, "UpdateOpenArea command failed");
+      return IME_ERROR;
+   }
+   if (rsp->ccode > 0) {
+      lprintf(LOG_ERR, "UpdateOpenArea command failed: %s",
+         val2str(rsp->ccode, completion_code_vals));
+      return IME_ERROR;
+   }
+
+   lprintf(LOG_DEBUG, "UpdateOpenArea command succeed");
+   return IME_SUCCESS;
+}
+
+static int ImeUpdateWriteArea(
+                              struct ipmi_intf *intf,
+                              uint8_t sequence, 
+                              uint8_t length, 
+                              uint8_t * pBuf
+                          )
+{
+   struct ipmi_rs * rsp;
+   struct ipmi_rq req;
+   uint8_t buffer[ IME_UPGRADE_BUFFER_SIZE + 1 ];
+
+//   printf("ImeUpdateWriteArea %i\n", sequence);
+
+   if(length > IME_UPGRADE_BUFFER_SIZE)
+      return IME_ERROR;
+
+   buffer[0] = sequence;
+   memcpy(&buffer[1], pBuf, length);
+
+   memset(&req, 0, sizeof(req));
+   req.msg.netfn = 0x30;  // OEM NetFn
+   req.msg.cmd = 0xA2;
+   req.msg.data = buffer;
+   req.msg.data_len = length + 1;
+
+   rsp = intf->sendrecv(intf, &req);
+   if (rsp == NULL) {
+      lprintf(LOG_ERR, "UpdateWriteArea command failed");
+      return IME_ERROR;
+   }
+   if (rsp->ccode > 0) {
+      lprintf(LOG_ERR, "UpdateWriteArea command failed: %s",
+         val2str(rsp->ccode, completion_code_vals));
+      if( rsp->ccode == 0x80) // restart operation
+         return IME_RESTART;
+      else
+         return IME_ERROR;
+   }
+
+   lprintf(LOG_DEBUG, "UpdateWriteArea command succeed");
+   return IME_SUCCESS;
+}
+
+static int ImeUpdateCloseArea(
+                              struct ipmi_intf *intf,
+                              uint32_t size, 
+                              uint16_t checksum
+                          )
+{
+   struct ipmi_rs * rsp;
+   struct ipmi_rq req;
+   uint8_t length = sizeof( uint32_t ) + sizeof( uint16_t ); 
+   uint8_t buffer[ sizeof( uint32_t ) + sizeof( uint16_t ) ];
+
+   #ifdef OUTPUT_DEBUG
+   printf( "ImeUpdateCloseArea\n");
+   #endif
+
+   buffer[0] = (uint8_t)((size & 0x000000ff) >>  0);
+   buffer[1] = (uint8_t)((size & 0x0000ff00) >>  8);
+   buffer[2] = (uint8_t)((size & 0x00ff0000) >> 16);
+   buffer[3] = (uint8_t)((size & 0xff000000) >> 24);
+
+   buffer[4] = (uint8_t)((checksum & 0x00ff) >>  0);
+   buffer[5] = (uint8_t)((checksum & 0xff00) >>  8);
+
+   memset(&req, 0, sizeof(req));
+   req.msg.netfn = 0x30;  // OEM NetFn
+   req.msg.cmd = 0xA3;
+   req.msg.data = buffer;
+   req.msg.data_len = length;
+
+   rsp = intf->sendrecv(intf, &req);
+   if (rsp == NULL) {
+      lprintf(LOG_ERR, "UpdateCloseArea command failed");
+      return IME_ERROR;
+   }
+   if (rsp->ccode > 0) {
+      lprintf(LOG_ERR, "UpdateCloseArea command failed: %s",
+         val2str(rsp->ccode, completion_code_vals));
+      return IME_ERROR;
+   }
+
+   lprintf(LOG_DEBUG, "UpdateCloseArea command succeed");
+   return IME_SUCCESS;
+}
+
+static int ImeUpdateGetStatus(struct ipmi_intf *intf, tImeStatus *pStatus )
+{
+   struct      ipmi_rs * rsp;
+   struct      ipmi_rq req;
+   tImeStatus *pGetStatus;
+   
+   memset(pStatus, 0, sizeof(tImeStatus));
+   pStatus->update_state = IME_STATE_ABORTED;
+
+
+   #ifdef OUTPUT_DEBUG
+   printf("ImeUpdateGetStatus: ");
+   #endif
+
+   memset(&req, 0, sizeof(req));
+   req.msg.netfn = 0x30;  // OEM NetFn
+   req.msg.cmd = 0xA6;
+   req.msg.data_len = 0;
+
+   rsp = intf->sendrecv(intf, &req);
+   if (rsp == NULL) {
+      lprintf(LOG_ERR, "UpdatePrepare command failed");
+      return IME_ERROR;
+   }
+   if (rsp->ccode > 0) {
+      lprintf(LOG_ERR, "UpdatePrepare command failed: %s",
+         val2str(rsp->ccode, completion_code_vals));
+      return IME_ERROR;
+   }
+
+   lprintf(LOG_DEBUG, "UpdatePrepare command succeed");
+
+   pGetStatus = (tImeStatus *) rsp->data;
+   
+   memcpy( pStatus, pGetStatus, sizeof(tImeStatus));
+
+   #ifdef OUTPUT_DEBUG
+   printf("%x - ", pStatus->updateState);
+
+   switch( pStatus->update_state )
+   {
+      case IME_STATE_IDLE:
+         printf("IDLE\n");
+      break;
+      case IME_STATE_UPDATE_REQUESTED:
+         printf("Update Requested\n");
+      break;
+      case IME_STATE_UPDATE_IN_PROGRESS:
+         printf("Update in Progress\n");
+      break;
+      case IME_STATE_SUCCESS:
+         printf("Update Success\n");
+      break;
+      case IME_STATE_FAILED:
+         printf("Update Failed\n");
+      break;
+      case IME_STATE_ROLLED_BACK:
+         printf("Update Rolled Back\n");
+      break;
+      case IME_STATE_ABORTED:
+         printf("Update Aborted\n");
+      break;
+      case IME_STATE_INIT_FAILED:
+         printf("Update Init Failed\n");
+      break;
+      default:
+         printf("Unknown, reserved\n");
+      break;
+   }
+   #endif
+
+   return IME_SUCCESS;
+}
+
+static int ImeUpdateGetCapabilities(struct ipmi_intf *intf, tImeCaps *pCaps )
+{
+   struct      ipmi_rs * rsp;
+   struct      ipmi_rq req;
+   tImeCaps *  pGetCaps;
+   
+   memset(pCaps, 0, sizeof(tImeCaps));
+
+
+   #ifdef OUTPUT_DEBUG
+   printf("ImeUpdateGetStatus: ");
+   #endif
+
+   memset(&req, 0, sizeof(req));
+   req.msg.netfn = 0x30;  // OEM NetFn
+   req.msg.cmd = 0xA7;
+   req.msg.data_len = 0;
+
+   rsp = intf->sendrecv(intf, &req);
+   if (rsp == NULL) {
+      lprintf(LOG_ERR, "UpdatePrepare command failed");
+      return IME_ERROR;
+   }
+   if (rsp->ccode > 0) {
+      lprintf(LOG_ERR, "UpdatePrepare command failed: %s",
+         val2str(rsp->ccode, completion_code_vals));
+      return IME_ERROR;
+   }
+
+   lprintf(LOG_DEBUG, "UpdatePrepare command succeed");
+
+   pGetCaps = (tImeCaps *) rsp->data;
+   
+   memcpy( pCaps, pGetCaps, sizeof(tImeCaps));
+
+   return IME_SUCCESS;
+}
+
+
+static int ImeUpdateRegisterUpdate(struct ipmi_intf *intf, tImeUpdateType type)
+{
+   struct ipmi_rs * rsp;
+   struct ipmi_rq req;
+   uint8_t buffer[ 2 ];
+
+   #ifdef OUTPUT_DEBUG
+   printf( "ImeUpdateRegisterUpdate\n");
+   #endif
+
+   buffer[0] = type;  // Normal Update
+   buffer[1] = 0;  // Flags, reserved
+
+   memset(&req, 0, sizeof(req));
+   req.msg.netfn = 0x30;  // OEM NetFn
+   req.msg.cmd = 0xA4;
+   req.msg.data = buffer;
+   req.msg.data_len = 2;
+
+   rsp = intf->sendrecv(intf, &req);
+   if (rsp == NULL) {
+      lprintf(LOG_ERR, "ImeUpdateRegisterUpdate command failed");
+      return IME_ERROR;
+   }
+   if (rsp->ccode > 0) {
+      lprintf(LOG_ERR, "ImeUpdateRegisterUpdate command failed: %s",
+         val2str(rsp->ccode, completion_code_vals));
+      return IME_ERROR;
+   }
+
+   lprintf(LOG_DEBUG, "ImeUpdateRegisterUpdate command succeed");
+   return IME_SUCCESS;
+}
+
+
+
+
+static int ImeUpdateShowStatus(struct ipmi_intf *intf)
+{
+   struct ipmi_rs * rsp;
+   struct ipmi_rq req;
+   tImeStatus *pStatus;
+
+   printf("ImeUpdateGetStatus: ");
+
+   memset(&req, 0, sizeof(req));
+   req.msg.netfn = 0x30;  // OEM NetFn
+   req.msg.cmd = 0xA6;
+   req.msg.data_len = 0;
+
+   rsp = intf->sendrecv(intf, &req);
+   if (rsp == NULL) {
+      lprintf(LOG_ERR, "UpdatePrepare command failed");
+      return IME_ERROR;
+   }
+   if (rsp->ccode > 0) {
+      lprintf(LOG_ERR, "UpdatePrepare command failed: %s",
+         val2str(rsp->ccode, completion_code_vals));
+      return IME_ERROR;
+   }
+
+   lprintf(LOG_DEBUG, "UpdatePrepare command succeed");
+
+   pStatus = (tImeStatus *) rsp->data ;
+
+   
+   printf("image_status: %x - ", pStatus->image_status);
+
+   printf("update_state: %x - ", pStatus->update_state);
+
+   switch( pStatus->update_state )
+   {
+      case IME_STATE_IDLE:
+         printf("IDLE\n");
+      break;
+      case IME_STATE_UPDATE_REQUESTED:
+         printf("Update Requested\n");
+      break;
+      case IME_STATE_UPDATE_IN_PROGRESS:
+         printf("Update in Progress\n");
+      break;
+      case IME_STATE_SUCCESS:
+         printf("Update Success\n");
+      break;
+      case IME_STATE_FAILED:
+         printf("Update Failed\n");
+      break;
+      case IME_STATE_ROLLED_BACK:
+         printf("Update Rolled Back\n");
+      break;
+      case IME_STATE_ABORTED:
+         printf("Update Aborted\n");
+      break;
+      case IME_STATE_INIT_FAILED:
+         printf("Update Init Failed\n");
+      break;
+      default:
+         printf("Unknown, reserved\n");
+      break;
+   }
+   printf("update_attempt_status  : %x\n", pStatus->update_attempt_status);
+   printf("rollback_attempt_status: %x\n", pStatus->rollback_attempt_status);
+   printf("update_type            : %x\n", pStatus->update_type);
+   printf("dependent_flag         : %x\n", pStatus->dependent_flag);
+   printf("free_area_size         : %x\n", pStatus->free_area_size[0]);
+   printf("                       : %x\n", pStatus->free_area_size[1]);
+   printf("                       : %x\n", pStatus->free_area_size[2]);
+   printf("                       : %x\n", pStatus->free_area_size[3]);
+
+   return IME_SUCCESS;
+}
+
+
+static int ImeImageCtxFromFile(
+                                 char* imageFilename, 
+                                 tImeUpdateImageCtx * pImageCtx
+                               )
+{
+   int rc = IME_SUCCESS;
+   FILE* pImageFile = fopen(imageFilename, "rb");
+   
+   if ( pImageFile == NULL )
+   {
+      lprintf(LOG_NOTICE,"Cannot open image file %s", imageFilename);
+      rc = IME_ERROR;
+   }
+   
+   if ( rc == IME_SUCCESS )
+   {
+      /* Get the raw data in file */
+      fseek(pImageFile, 0, SEEK_END);
+      pImageCtx->size  = ftell(pImageFile); 
+      pImageCtx->pData = malloc(sizeof(unsigned char)*pImageCtx->size);
+      rewind(pImageFile);
+
+      if ( pImageCtx->pData != NULL )
+      {
+         fread(pImageCtx->pData, sizeof(unsigned char), 
+                                                   pImageCtx->size, pImageFile);
+      }
+      else
+      {
+         rc = IME_ERROR;
+      }
+   }
+   
+   // Calculate checksum CRC8  
+   if ( rc == IME_SUCCESS )
+   {
+      pImageCtx->crc8 = ImeCrc8(pImageCtx->size, pImageCtx->pData);
+   }
+
+    
+   if( pImageFile != NULL)
+   {
+      fclose(pImageFile);
+   }
+    
+   return rc;
+}  
+
+static uint8_t ImeCrc8( uint32_t length, uint8_t * pBuf )
+{
+   uint8_t crc = 0;
+   uint32_t bufCount;
+
+   for ( bufCount = 0; bufCount < length; bufCount++ )
+   {
+      uint8_t count;
+
+      crc = crc ^ pBuf[bufCount];
+  
+      for ( count = 0; count < 8; count++ ) 
+      {
+         if (( crc & 0x80 ) != 0 )
+         {
+            crc <<= 1;
+            crc ^= 0x07;
+         }
+         else
+         {
+            crc <<= 1;
+         }
+      }
+   }
+
+   lprintf(LOG_DEBUG,"CRC8: %02xh\n", crc);
+   return crc;
+} 
+
+
+static int ImeManualRollback(struct ipmi_intf *intf)
+{
+   int rc = IME_SUCCESS;
+   tImeStatus imeStatus;
+   time_t start,end,current;
+   
+
+   rc = ImeUpdateRegisterUpdate(intf, IME_UPDTYPE_MANUAL_ROLLBACK);
+   ImeUpdateGetStatus(intf,&imeStatus);
+
+
+   if(
+      (rc == IME_SUCCESS) &&
+      (imeStatus.update_state == IME_STATE_ROLLED_BACK) 
+     )
+   {
+      printf("Manual Rollback Succeed\n");
+   }
+   else
+   {
+      printf("Manual Rollback Completed With Error\n");
+   }
+}
+
+
+
+static void ImePrintUsage(void)
+{
+   lprintf(LOG_NOTICE,"help                    - This help menu");   
+   lprintf(LOG_NOTICE,"info                    - Information about the present Intel ME");   
+   lprintf(LOG_NOTICE,"update <file>           - Upgrade the ME firmware from received image <file>");
+   lprintf(LOG_NOTICE,"rollback                - Manual Rollback ME");
+//   lprintf(LOG_NOTICE,"rollback                - Rollback ME Firmware");
+}
+
+
+
+int ipmi_ime_main(struct ipmi_intf * intf, int argc, char ** argv)
+{
+   int rc = IME_SUCCESS;
+   
+   lprintf(LOG_DEBUG,"ipmi_ime_main()");
+   
+
+   if ( (argc == 0) || (strcmp(argv[0], "help") == 0) ) 
+   {
+      ImePrintUsage();
+   }
+   else if ( (argc == 0) || (strcmp(argv[0], "info") == 0) ) 
+   {
+      rc = ImeGetInfo(intf);
+   }
+   else if ( strcmp(argv[0], "update") == 0) 
+   {
+      if(argc == 2)
+      {
+         lprintf(LOG_NOTICE,"Update using file: %s", argv[1]);
+         rc = ImeUpgrade(intf, argv[1]);
+      }
+      else
+      {
+         lprintf(LOG_ERROR,"File must be provided with this option, see help\n");
+         rc = IME_ERROR;
+      }
+   }
+   else if ( (argc == 0) || (strcmp(argv[0], "rollback") == 0) ) 
+   {
+      rc = ImeManualRollback(intf);
+   }
+   else
+   {
+      ImePrintUsage(); 
+   }
+   
+   return rc;
+}
+
+
+
diff --git a/lib/ipmi_kontronoem.c b/lib/ipmi_kontronoem.c
index 80d9bb3..e625ca2 100644
--- a/lib/ipmi_kontronoem.c
+++ b/lib/ipmi_kontronoem.c
@@ -69,6 +69,9 @@ static void ipmi_kontron_nextboot_help(void);
 static int ipmi_kontron_nextboot_set(struct ipmi_intf * intf,
                                      int argc, char **argv);
 
+static int ipmi_kontronoem_send_set_large_buffer(struct ipmi_intf * intf,
+                                                 unsigned char channel,
+                                                 unsigned char size);
 
 int
 ipmi_kontronoem_main(struct ipmi_intf * intf, int argc, char ** argv)
@@ -151,6 +154,103 @@ static void ipmi_kontron_help(void)
    printf("Kontron Commands:  setsn setmfgdate nextboot\n");
 }   
 
+
+int ipmi_kontronoem_set_large_buffer(struct ipmi_intf * intf, unsigned char size)
+{
+   uint8_t error_occurs = 0;
+   uint32_t prev_target_addr = intf->target_addr ;
+
+   if ( intf->target_addr > 0  && (intf->target_addr != intf->my_addr) )
+   {
+      intf->target_addr = intf->my_addr;
+
+       printf("Set local big buffer\r\n");
+       if(ipmi_kontronoem_send_set_large_buffer( intf, 0x0e, size ) == 0)
+       {
+          printf("Set local big buffer:success\r\n");
+       }
+       else
+       {
+          error_occurs = 1;
+       }
+
+       if (error_occurs == 0)
+       {
+          if(ipmi_kontronoem_send_set_large_buffer( intf, 0x00, size ) == 0)
+          {
+             printf("IPMB was set\r\n");
+          }
+          else
+          {
+             /* Revert back the previous set large buffer */
+             error_occurs = 1;
+             ipmi_kontronoem_send_set_large_buffer( intf, 0x0e, 0 );
+          }
+       }
+
+      /* Restore target address */
+       intf->target_addr = prev_target_addr;
+   }
+
+   if (error_occurs == 0)
+   {
+      if(ipmi_kontronoem_send_set_large_buffer( intf, 0x0e, size ) == 0)
+      {
+         printf("Set remote big buffer\r\n");
+      }
+      else
+      {
+         if ( intf->target_addr > 0  && (intf->target_addr != intf->my_addr) )
+         {
+            /* Error occurs revert back the previous set large buffer*/
+            intf->target_addr = intf->my_addr;
+
+            ipmi_kontronoem_send_set_large_buffer( intf, 0x00, 0 );
+            ipmi_kontronoem_send_set_large_buffer( intf, 0x0e, 0 );
+
+            intf->target_addr = prev_target_addr;
+         }
+      }
+   }
+   return error_occurs;
+}
+
+
+int ipmi_kontronoem_send_set_large_buffer(struct ipmi_intf * intf, unsigned char channel,unsigned char size)
+{
+   struct ipmi_rs *rsp;
+   struct ipmi_rq req;
+   uint8_t msg_data[2];
+   int i;
+   
+   memset(msg_data, 0, sizeof(msg_data));
+   msg_data[0] = channel/*0x0e*/;   // Currently running interface
+   msg_data[1] = size;
+   
+   memset(&req, 0, sizeof(req));
+   req.msg.netfn = 0x3E; /* OEM NetFn */
+   req.msg.cmd = 0x82;   /* Set Channel Buffer Length - OEM */
+   req.msg.data = msg_data;
+   req.msg.data_len = 2;
+   
+   req.msg.lun = 0x00;
+      
+   rsp = intf->sendrecv(intf, &req);
+   if (rsp == NULL) 
+   {
+      printf("Cannot send large buffer command\n");
+      return(-1);
+   }
+   if (rsp->ccode > 0) 
+   {
+      printf("Invalid length for the selected interface (%s)\n", 
+               val2str(rsp->ccode, completion_code_vals));
+      return(-1);
+   }
+   return 0;
+}
+
+
 /* ipmi_fru_set_serial_number -  Set the Serial Number in FRU
  *
  * @intf:		ipmi interface
diff --git a/lib/ipmi_main.c b/lib/ipmi_main.c
index f4a4a4f..4c7aa71 100644
--- a/lib/ipmi_main.c
+++ b/lib/ipmi_main.c
@@ -67,13 +67,14 @@
 #include <ipmitool/ipmi_pef.h>
 #include <ipmitool/ipmi_oem.h>
 #include <ipmitool/ipmi_ekanalyzer.h>
+#include <ipmitool/ipmi_picmg.h>
 
 #ifdef HAVE_CONFIG_H
 # include <config.h>
 #endif
 
 #ifdef ENABLE_ALL_OPTIONS
-# define OPTION_STRING	"I:hVvcgsEKao:H:d:P:f:U:p:C:L:A:t:T:m:S:l:b:B:e:k:y:O:"
+# define OPTION_STRING	"I:hVvcgsEKYao:H:d:P:f:U:p:C:L:A:t:T:m:z:S:l:b:B:e:k:y:O:"
 #else
 # define OPTION_STRING	"I:hVvcH:f:U:p:d:S:"
 #endif
@@ -90,6 +91,7 @@ extern int ipmi_shell_main(struct ipmi_intf * intf, int argc, char ** argv);
 extern int ipmi_set_main(struct ipmi_intf * intf, int argc, char ** argv);
 extern int ipmi_exec_main(struct ipmi_intf * intf, int argc, char ** argv);
 
+static struct ipmi_intf * ipmi_main_intf = NULL;
 
 /* ipmi_password_file_read  -  Open file and read password from it
  *
@@ -115,19 +117,19 @@ ipmi_password_file_read(char * filename)
 	fp = ipmi_open_file_read((const char *)filename);
 	if (fp == NULL) {
 		lprintf(LOG_ERR, "Unable to open password file %s",
-			filename);
+				filename);
 		return NULL;
 	}
 
 	/* read in id */
 	if (fgets(pass, 16, fp) == NULL) {
 		lprintf(LOG_ERR, "Unable to read password from file %s",
-			filename);
+				filename);
 		fclose(fp);
 		return NULL;
 	}
 
- 	/* remove trailing whitespace */
+	/* remove trailing whitespace */
 	l = strcspn(pass, " \r\n\t");
 	if (l > 0) {
 		pass[l] = '\0';
@@ -224,9 +226,11 @@ ipmi_option_usage(const char * progname, struct ipmi_cmd * cmdlist, struct ipmi_
 	lprintf(LOG_NOTICE, "       -p port        Remote RMCP port [default=623]");
 	lprintf(LOG_NOTICE, "       -U username    Remote session username");
 	lprintf(LOG_NOTICE, "       -f file        Read remote session password from file");
+	lprintf(LOG_NOTICE, "       -z size        Change Size of Communication Channel (OEM)");
 	lprintf(LOG_NOTICE, "       -S sdr         Use local file for remote SDR cache");
 #ifdef ENABLE_ALL_OPTIONS
 	lprintf(LOG_NOTICE, "       -a             Prompt for remote password");
+	lprintf(LOG_NOTICE, "       -Y             Prompt for the Kg key for IPMIv2 authentication");
 	lprintf(LOG_NOTICE, "       -e char        Set SOL escape character");
 	lprintf(LOG_NOTICE, "       -C ciphersuite Cipher suite to be used by lanplus interface");
 	lprintf(LOG_NOTICE, "       -k key         Use Kg key for IPMIv2 authentication");
@@ -240,6 +244,7 @@ ipmi_option_usage(const char * progname, struct ipmi_cmd * cmdlist, struct ipmi_
 	lprintf(LOG_NOTICE, "       -m address     Set local IPMB address");
 	lprintf(LOG_NOTICE, "       -b channel     Set destination channel for bridged request");
 	lprintf(LOG_NOTICE, "       -t address     Bridge request to remote target address");
+	lprintf(LOG_NOTICE, "       -M address     Set transit local address for bridge request(dual bridge)");
 	lprintf(LOG_NOTICE, "       -B channel     Set transit channel for bridged request (dual bridge)");
 	lprintf(LOG_NOTICE, "       -T address     Set transit address for bridge request (dual bridge)");
 	lprintf(LOG_NOTICE, "       -l lun         Set destination lun for raw commands");
@@ -253,6 +258,24 @@ ipmi_option_usage(const char * progname, struct ipmi_cmd * cmdlist, struct ipmi_
 	if (cmdlist != NULL)
 		ipmi_cmd_print(cmdlist);
 }
+/* ipmi_catch_sigint  -  Handle the interrupt signal (Ctrl-C), close the
+ *                       interface, and exit ipmitool with error (-1)
+ *
+ *                       This insures that the IOL session gets freed
+ *                       for other callers.
+ * 
+ * returns -1
+ */
+void ipmi_catch_sigint()
+{
+   if (ipmi_main_intf != NULL)
+   {
+      printf("\r\nSIGN INT: Close Interface %s\r\n",ipmi_main_intf->desc);
+      ipmi_main_intf->close(ipmi_main_intf);
+   }
+   exit(-1);
+
+}
 
 /* ipmi_parse_hex - convert hexadecimal numbers to ascii string
  *                  Input string must be composed of two-characer hexadecimal numbers.
@@ -298,7 +321,7 @@ ipmi_parse_hex(const char *str)
 			free(out);
 			return NULL;
 		}
-		
+
 		if (*p < 'A') /* it must be 0-9 */
 			b = *p - '0';
 		else /* it's A-F or a-f */
@@ -311,7 +334,7 @@ ipmi_parse_hex(const char *str)
 			shift = 4;
 			q++;
 		}
-    }
+	}
 
 	return out;
 }
@@ -328,18 +351,20 @@ ipmi_parse_hex(const char *str)
  */
 int
 ipmi_main(int argc, char ** argv,
-	  struct ipmi_cmd * cmdlist,
-	  struct ipmi_intf_support * intflist)
+		struct ipmi_cmd * cmdlist,
+		struct ipmi_intf_support * intflist)
 {
-	struct ipmi_intf * intf = NULL;
 	struct ipmi_intf_support * sup;
 	int privlvl = 0;
 	uint8_t target_addr = 0;
 	uint8_t target_channel = 0;
+
 	uint8_t transit_addr = 0;
 	uint8_t transit_channel = 0;
 	uint8_t target_lun     = 0;
-	uint8_t my_addr = 0;
+	uint8_t my_addr = 0x20;
+	uint8_t my_long_packet_size=0;
+	uint8_t my_long_packet_set=0;
 	uint8_t lookupbit = 0x10;	/* use name-only lookup by default */
 	int authtype = -1;
 	char * tmp = NULL;
@@ -354,7 +379,7 @@ ipmi_main(int argc, char ** argv,
 	char * seloem   = NULL;
 	int port = 0;
 	int devnum = 0;
-	int cipher_suite_id = 3; /* See table 22-19 of the IPMIv2 spec */
+	int cipher_suite_id = 1; /* See table 22-19 of the IPMIv2 spec */
 	int argflag, i, found;
 	int rc = -1;
 	char sol_escape_char = SOL_ESCAPE_CHARACTER_DEFAULT;
@@ -362,6 +387,7 @@ ipmi_main(int argc, char ** argv,
 	/* save program name */
 	progname = strrchr(argv[0], '/');
 	progname = ((progname == NULL) ? argv[0] : progname+1);
+	signal(SIGINT, ipmi_catch_sigint);
 
 	while ((argflag = getopt(argc, (char **)argv, OPTION_STRING)) != -1)
 	{
@@ -376,8 +402,8 @@ ipmi_main(int argc, char ** argv,
 				found = 0;
 				for (sup=intflist; sup->name != NULL; sup++) {
 					if (strncmp(sup->name, intfname, strlen(intfname)) == 0 &&
-					    strncmp(sup->name, intfname, strlen(sup->name)) == 0 &&
-					    sup->supported == 1)
+							strncmp(sup->name, intfname, strlen(sup->name)) == 0 &&
+							sup->supported == 1)
 						found = 1;
 				}
 				if (!found) {
@@ -424,7 +450,7 @@ ipmi_main(int argc, char ** argv,
 			password = ipmi_password_file_read(optarg);
 			if (password == NULL)
 				lprintf(LOG_ERR, "Unable to read password "
-					"from file %s", optarg);
+						"from file %s", optarg);
 			break;
 		case 'a':
 #ifdef HAVE_GETPASSPHRASE
@@ -470,6 +496,22 @@ ipmi_main(int argc, char ** argv,
 				goto out_free;
 			}
 			break;
+		case 'Y':
+#ifdef HAVE_GETPASSPHRASE
+			tmp = getpassphrase("Key: ");
+#else
+			tmp = getpass("Key: ");
+#endif
+			if (tmp != NULL) {
+				if (kgkey)
+					free(kgkey);
+				kgkey = strdup(tmp);
+				if (kgkey == NULL) {
+					lprintf(LOG_ERR, "%s: malloc failure", progname);
+					goto out_free;
+				}
+			}
+			break;
 		case 'U':
 			username = strdup(optarg);
 			if (username == NULL) {
@@ -492,7 +534,7 @@ ipmi_main(int argc, char ** argv,
 				goto out_free;
 			}
 			if (strncmp(oemtype, "list", 4) == 0 ||
-			    strncmp(oemtype, "help", 4) == 0) {
+					strncmp(oemtype, "help", 4) == 0) {
 				ipmi_oem_print();
 				goto out_free;
 			}
@@ -585,6 +627,9 @@ ipmi_main(int argc, char ** argv,
 				goto out_free;
 			}
 			break;
+		case 'z':	
+			my_long_packet_size = (uint8_t)strtol(optarg, NULL, 0);
+			break;
 #endif
 		default:
 			ipmi_option_usage(progname, cmdlist, intflist);
@@ -594,7 +639,7 @@ ipmi_main(int argc, char ** argv,
 
 	/* check for command before doing anything */
 	if (argc-optind > 0 &&
-	    strncmp(argv[optind], "help", 4) == 0) {
+			strncmp(argv[optind], "help", 4) == 0) {
 		ipmi_cmd_print(cmdlist);
 		rc = 0;
 		goto out_free;
@@ -609,7 +654,7 @@ ipmi_main(int argc, char ** argv,
 	 * then prompt the user.
 	 */
 	if (hostname != NULL && password == NULL &&
-	    (authtype != IPMI_SESSION_AUTHTYPE_NONE || authtype < 0)) {
+			(authtype != IPMI_SESSION_AUTHTYPE_NONE || authtype < 0)) {
 #ifdef HAVE_GETPASSPHRASE
 		tmp = getpassphrase("Password: ");
 #else
@@ -638,8 +683,8 @@ ipmi_main(int argc, char ** argv,
 	}
 
 	/* load interface */
-	intf = ipmi_intf_load(intfname);
-	if (intf == NULL) {
+	ipmi_main_intf = ipmi_intf_load(intfname);
+	if (ipmi_main_intf == NULL) {
 		lprintf(LOG_ERR, "Error loading interface %s", intfname);
 		goto out_free;
 	}
@@ -649,65 +694,128 @@ ipmi_main(int argc, char ** argv,
 
 	/* run OEM setup if found */
 	if (oemtype != NULL &&
-	    ipmi_oem_setup(intf, oemtype) < 0) {
+	    ipmi_oem_setup(ipmi_main_intf, oemtype) < 0) {
 		lprintf(LOG_ERR, "OEM setup for \"%s\" failed", oemtype);
 		goto out_free;
 	}
 
 	/* set session variables */
 	if (hostname != NULL)
-		ipmi_intf_session_set_hostname(intf, hostname);
+		ipmi_intf_session_set_hostname(ipmi_main_intf, hostname);
 	if (username != NULL)
-		ipmi_intf_session_set_username(intf, username);
+		ipmi_intf_session_set_username(ipmi_main_intf, username);
 	if (password != NULL)
-		ipmi_intf_session_set_password(intf, password);
+		ipmi_intf_session_set_password(ipmi_main_intf, password);
 	if (kgkey != NULL)
-		ipmi_intf_session_set_kgkey(intf, kgkey);
+		ipmi_intf_session_set_kgkey(ipmi_main_intf, kgkey);
 	if (port > 0)
-		ipmi_intf_session_set_port(intf, port);
+		ipmi_intf_session_set_port(ipmi_main_intf, port);
 	if (authtype >= 0)
-		ipmi_intf_session_set_authtype(intf, (uint8_t)authtype);
+		ipmi_intf_session_set_authtype(ipmi_main_intf, (uint8_t)authtype);
 	if (privlvl > 0)
-		ipmi_intf_session_set_privlvl(intf, (uint8_t)privlvl);
+		ipmi_intf_session_set_privlvl(ipmi_main_intf, (uint8_t)privlvl);
 	else
-		ipmi_intf_session_set_privlvl(intf,
+		ipmi_intf_session_set_privlvl(ipmi_main_intf,
 		      IPMI_SESSION_PRIV_ADMIN);	/* default */
 
-	ipmi_intf_session_set_lookupbit(intf, lookupbit);
-	ipmi_intf_session_set_sol_escape_char(intf, sol_escape_char);
-	ipmi_intf_session_set_cipher_suite_id(intf, cipher_suite_id);
+	ipmi_intf_session_set_lookupbit(ipmi_main_intf, lookupbit);
+	ipmi_intf_session_set_sol_escape_char(ipmi_main_intf, sol_escape_char);
+	ipmi_intf_session_set_cipher_suite_id(ipmi_main_intf, cipher_suite_id);
 
 	/* setup destination lun if given */
-	intf->target_lun = target_lun ;
+	ipmi_main_intf->target_lun = target_lun ;
 
 	/* setup destination channel if given */
-	intf->target_channel = target_channel ;
+	ipmi_main_intf->target_channel = target_channel ;
+
+	ipmi_main_intf->devnum = devnum;
+
+	/* setup IPMB local and target address if given */ 
+   if( my_addr ) {
+      ipmi_main_intf->my_addr = my_addr;
+   }
+   else {
+
+	/* Check if PICMG extension is available to use the function GetDeviceLocator
+	 * to retreive i2c address PICMG hack to set right IPMB address, 
+	 * If extension is not supported, should not give any problems
+    *  PICMG Extension Version 2.0 (PICMG 3.0 Revision 1.0 ATCA) to
+    *  PICMG Extension Version 2.3 (PICMG 3.0 Revision 3.0 ATCA)
+	 */      
+      /* First, check if PICMG extension is available and supported */
+      struct ipmi_rq req;
+      struct ipmi_rs *rsp;
+      char msg_data;
+      unsigned char version_accepted = 0;
+
+		lprintf(LOG_INFO, "Running PICMG GetDeviceLocator" );
+		memset(&req, 0, sizeof(req));
+		req.msg.netfn = IPMI_NETFN_PICMG;
+		req.msg.cmd = PICMG_GET_PICMG_PROPERTIES_CMD;             
+		msg_data    = 0x00;                                       
+		req.msg.data = &msg_data; 
+		req.msg.data_len = 1;
+		msg_data = 0;
+
+		rsp = ipmi_main_intf->sendrecv(ipmi_main_intf, &req);
+		if (rsp && !rsp->ccode) {
+			if
+			(  
+				(rsp->data[0] == 0)
+				&&
+            ((rsp->data[1] & 0x0F ) == PICMG_ATCA_MAJOR_VERSION )
+			){
+		      version_accepted = 1;
+		      lprintf(LOG_INFO, "Discovered PICMG Extension %d.%d", 
+                            (rsp->data[1] & 0x0f),(rsp->data[1] >> 4)  );
+		   }
+		}
+		
+		if(version_accepted == 1){
+			lprintf(LOG_DEBUG, "Running PICMG GetDeviceLocator" );
+			memset(&req, 0, sizeof(req));
+			req.msg.netfn = IPMI_NETFN_PICMG;
+			req.msg.cmd = PICMG_GET_ADDRESS_INFO_CMD;
+			msg_data    = 0x00;
+			req.msg.data = &msg_data; 
+			req.msg.data_len = 1;   
+			msg_data = 0;
+
+		   rsp = ipmi_main_intf->sendrecv(ipmi_main_intf, &req);
+		   if (rsp && !rsp->ccode) {            
+            ipmi_main_intf->my_addr = rsp->data[2];
+            ipmi_main_intf->target_addr = ipmi_main_intf->my_addr;
+			   lprintf(LOG_INFO, "Discovered IPMB address = 0x%x", ipmi_main_intf->my_addr);
+		   }
+      }
+      else{
+         lprintf(LOG_INFO, 
+                  "No PICMG Extenstion discovered, keeping IPMB address 0x20");
+      }
+	}
 
-	intf->devnum = devnum;
 
-	/* setup IPMB local and target address if given */
-	intf->my_addr = my_addr ? : IPMI_BMC_SLAVE_ADDR;
-	if (target_addr > 0) {
+	if ( target_addr > 0  && (target_addr != my_addr) ) {
 		/* need to open the interface first */
-		if (intf->open != NULL)
-			intf->open(intf);
-		intf->target_addr = target_addr;
+		if (ipmi_main_intf->open != NULL)
+			ipmi_main_intf->open(ipmi_main_intf);
+		ipmi_main_intf->target_addr = target_addr;
 
       if (transit_addr > 0) {
-         intf->transit_addr    = transit_addr;
-         intf->transit_channel = transit_channel;
+         ipmi_main_intf->transit_addr    = transit_addr;
+         ipmi_main_intf->transit_channel = transit_channel;
       }
       else
       {
-         intf->transit_addr = intf->my_addr;
+         ipmi_main_intf->transit_addr = ipmi_main_intf->my_addr;
       }
 		/* must be admin level to do this over lan */
-		ipmi_intf_session_set_privlvl(intf, IPMI_SESSION_PRIV_ADMIN);
+		ipmi_intf_session_set_privlvl(ipmi_main_intf, IPMI_SESSION_PRIV_ADMIN);
 	}
 
 	/* parse local SDR cache if given */
 	if (sdrcache != NULL) {
-		ipmi_sdr_list_cache_fromfile(intf, sdrcache);
+		ipmi_sdr_list_cache_fromfile(ipmi_main_intf, sdrcache);
 	}
 
 	/* Parse SEL OEM file if given */
@@ -715,22 +823,41 @@ ipmi_main(int argc, char ** argv,
 		ipmi_sel_oem_init(seloem);
 	}
 
-	intf->cmdlist = cmdlist;
+	/* Enable Big Buffer when requested */
+	ipmi_main_intf->channel_buf_size = 0;
+	if( my_long_packet_size != 0 )
+	{
+		printf("Setting large buffer to %i\n", my_long_packet_size);
+		if(ipmi_kontronoem_set_large_buffer( ipmi_main_intf, my_long_packet_size ) == 0)
+		{
+			my_long_packet_set = 1;
+			ipmi_main_intf->channel_buf_size = my_long_packet_size;
+		}
+	}
+
+	ipmi_main_intf->cmdlist = cmdlist;
 
 	/* now we finally run the command */
 	if (argc-optind > 0)
-		rc = ipmi_cmd_run(intf, argv[optind], argc-optind-1, &(argv[optind+1]));
+		rc = ipmi_cmd_run(ipmi_main_intf, argv[optind], argc-optind-1, 
+                        &(argv[optind+1]));
 	else
-		rc = ipmi_cmd_run(intf, NULL, 0, NULL);
+		rc = ipmi_cmd_run(ipmi_main_intf, NULL, 0, NULL);
+
+	if(my_long_packet_set == 1) 
+	{
+		/* Restore defaults */
+		ipmi_kontronoem_set_large_buffer( ipmi_main_intf, 0 );
+	}
 
 	/* clean repository caches */
-	ipmi_cleanup(intf);
+	ipmi_cleanup(ipmi_main_intf);
 
 	/* call interface close function if available */
-	if (intf->opened > 0 && intf->close != NULL)
-		intf->close(intf);
+	if (ipmi_main_intf->opened > 0 && ipmi_main_intf->close != NULL)
+		ipmi_main_intf->close(ipmi_main_intf);
 
- out_free:
+	out_free:
 	log_halt();
 
 	if (intfname != NULL)
diff --git a/lib/ipmi_mc.c b/lib/ipmi_mc.c
index b424ad4..92d140f 100644
--- a/lib/ipmi_mc.c
+++ b/lib/ipmi_mc.c
@@ -61,6 +61,7 @@ ipmi_mc_reset(struct ipmi_intf * intf, int cmd)
 	struct ipmi_rs * rsp;
 	struct ipmi_rq req;
 
+	if( !intf->opened )
 	intf->open(intf);
 
 	memset(&req, 0, sizeof(req));
@@ -82,6 +83,9 @@ ipmi_mc_reset(struct ipmi_intf * intf, int cmd)
 	return 0;
 }
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct bmc_enables_data {
 #if WORDS_BIGENDIAN
 	uint8_t oem2		: 1;
@@ -102,7 +106,10 @@ struct bmc_enables_data {
 	uint8_t oem1		: 1;
 	uint8_t oem2		: 1;
 #endif
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 struct bitfield_data {
 	const char * name;
@@ -350,7 +357,7 @@ ipmi_mc_get_deviceid(struct ipmi_intf * intf)
 		devid->device_id);
 	printf("Device Revision           : %i\n",
 		devid->device_revision & IPM_DEV_DEVICE_ID_REV_MASK);
-	printf("Firmware Revision         : %u.%x\n",
+	printf("Firmware Revision         : %u.%02x\n",
 		devid->fw_rev1 & IPM_DEV_FWREV1_MAJOR_MASK,
 		devid->fw_rev2);
 	printf("IPMI Version              : %x.%x\n",
@@ -359,13 +366,13 @@ ipmi_mc_get_deviceid(struct ipmi_intf * intf)
 	printf("Manufacturer ID           : %lu\n",
 		(long)IPM_DEV_MANUFACTURER_ID(devid->manufacturer_id));
    printf("Manufacturer Name         : %s\n",
-            val2str( (long)IPM_DEV_MANUFACTURER_ID(devid->manufacturer_id), 
+            val2str( (long)IPM_DEV_MANUFACTURER_ID(devid->manufacturer_id),
             ipmi_oem_info) );
 
 	printf("Product ID                : %u (0x%02x%02x)\n",
 		buf2short((uint8_t *)(devid->product_id)),
 		devid->product_id[1], devid->product_id[0]);
- 
+
 	product=oemval2str(IPM_DEV_MANUFACTURER_ID(devid->manufacturer_id),
 							 (devid->product_id[1]<<8)+devid->product_id[0],
 							 ipmi_oem_product_info);
@@ -396,6 +403,12 @@ ipmi_mc_get_deviceid(struct ipmi_intf * intf)
 	return 0;
 }
 
+/* Structure follow the IPMI V.2 Rev 1.0
+ * See Table 20-10 */
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
+
 struct ipmi_guid {
 	uint32_t  time_low;	/* timestamp low field */
 	uint16_t  time_mid;	/* timestamp middle field */
@@ -403,7 +416,10 @@ struct ipmi_guid {
 	uint8_t   clock_seq_hi_variant;/* clock sequence high field and variant */
 	uint8_t   clock_seq_low; /* clock sequence low field */
 	uint8_t   node[6];	/* node */
-} __attribute__((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 /* ipmi_mc_get_guid  -  print this MC GUID
  *
@@ -477,7 +493,7 @@ static int ipmi_mc_get_selftest(struct ipmi_intf * intf)
 
 	rsp = intf->sendrecv(intf, &req);
 	if (!rsp) {
-		lprintf(LOG_ERR, "No response from devices\n"); 
+		lprintf(LOG_ERR, "No response from devices\n");
 		return -1;
 	}
 
@@ -578,14 +594,14 @@ const char *wdt_action_string[8] = {
 	"Reserved",
 	"Reserved"
 };
- 
+
 static int
 ipmi_mc_get_watchdog(struct ipmi_intf * intf)
 {
 	struct ipmi_rs * rsp;
 	struct ipmi_rq req;
 	struct ipm_get_watchdog_rsp * wdt_res;
-	
+
 	memset(&req, 0, sizeof(req));
 	req.msg.netfn = IPMI_NETFN_APP;
 	req.msg.cmd = BMC_GET_WATCHDOG_TIMER;
@@ -602,7 +618,7 @@ ipmi_mc_get_watchdog(struct ipmi_intf * intf)
 			val2str(rsp->ccode, completion_code_vals));
 		return -1;
 	}
-	
+
 	wdt_res = (struct ipm_get_watchdog_rsp *) rsp->data;
 	
 	printf("Watchdog Timer Use:     %s (0x%02x)\n", 
@@ -618,8 +634,8 @@ ipmi_mc_get_watchdog(struct ipmi_intf * intf)
 	printf("Present Countdown:      %i sec\n", 
 	    (((wdt_res->present_countdown_msb << 8) | wdt_res->present_countdown_lsb)) / 10);
 	
-	
-	return 0;	
+
+	return 0;
 }
 
 /* ipmi_mc_shutoff_watchdog
@@ -635,7 +651,7 @@ ipmi_mc_shutoff_watchdog(struct ipmi_intf * intf)
 	struct ipmi_rs * rsp;
 	struct ipmi_rq req;
 	unsigned char msg_data[6];
-	
+
 	memset(&req, 0, sizeof(req));
 	req.msg.netfn = IPMI_NETFN_APP;
 	req.msg.cmd   = BMC_SET_WATCHDOG_TIMER;
@@ -645,15 +661,15 @@ ipmi_mc_shutoff_watchdog(struct ipmi_intf * intf)
 	/*
 	 * The only set cmd we're allowing is to shut off the timer.
 	 * Turning on the timer should be the job of the ipmi watchdog driver.
-	 * See 'modinfo ipmi_watchdog' for more info. (NOTE: the reset 
+	 * See 'modinfo ipmi_watchdog' for more info. (NOTE: the reset
 	 * command will restart the timer if it's already been initialized.)
 	 *
 	 * Out-of-band watchdog set commands can still be sent via the raw
 	 * command interface but this is a very dangerous thing to do since
 	 * a periodic "poke"/reset over a network is unreliable.  This is
-	 * not a recommended way to use the IPMI watchdog commands. 
+	 * not a recommended way to use the IPMI watchdog commands.
 	 */
-	
+
 	msg_data[0] = IPM_WATCHDOG_SMS_OS;
 	msg_data[1] = IPM_WATCHDOG_NO_ACTION;
 	msg_data[2] = 0x00;  // pretimeout interval
@@ -672,9 +688,9 @@ ipmi_mc_shutoff_watchdog(struct ipmi_intf * intf)
 			val2str(rsp->ccode, completion_code_vals));
 		return -1;
 	}
-		
+
 	lprintf(LOG_ERR, "Watchdog Timer Shutoff successful -- timer stopped");
-	return 0;	
+	return 0;
 }
 
 
@@ -690,7 +706,7 @@ ipmi_mc_rst_watchdog(struct ipmi_intf * intf)
 {
 	struct ipmi_rs * rsp;
 	struct ipmi_rq req;
-	
+
 	memset(&req, 0, sizeof(req));
 	req.msg.netfn = IPMI_NETFN_APP;
 	req.msg.cmd   = BMC_RESET_WATCHDOG_TIMER;
@@ -704,14 +720,14 @@ ipmi_mc_rst_watchdog(struct ipmi_intf * intf)
 
 	if (rsp->ccode) {
 		lprintf(LOG_ERR, "Reset Watchdog Timer command failed: %s",
-			(rsp->ccode == IPM_WATCHDOG_RESET_ERROR) ? 
+			(rsp->ccode == IPM_WATCHDOG_RESET_ERROR) ?
 				"Attempt to reset unitialized watchdog" :
 				val2str(rsp->ccode, completion_code_vals));
 		return -1;
 	}
-		
+
 	lprintf(LOG_ERR, "IPMI Watchdog Timer Reset -  countdown restarted!");
-	return 0;	
+	return 0;
 }
 
 /* ipmi_mc_main  -  top-level handler for MC functions
@@ -727,7 +743,7 @@ int
 ipmi_mc_main(struct ipmi_intf * intf, int argc, char ** argv)
 {
 	int rc = 0;
-	
+
 	if (argc < 1 || strncmp(argv[0], "help", 4) == 0) {
 		printf_mc_usage();
 	}
@@ -762,7 +778,7 @@ ipmi_mc_main(struct ipmi_intf * intf, int argc, char ** argv)
 	}
 	else if (!strncmp(argv[0], "watchdog", 8)) {
 		if (argc < 2 || strncmp(argv[1], "help", 4) == 0) {
-			print_watchdog_usage(); 
+			print_watchdog_usage();
 		}
 		else if (strncmp(argv[1], "get", 3) == 0) {
 			rc = ipmi_mc_get_watchdog(intf);
@@ -774,7 +790,7 @@ ipmi_mc_main(struct ipmi_intf * intf, int argc, char ** argv)
 			rc = ipmi_mc_rst_watchdog(intf);
 		}
 		else {
-			print_watchdog_usage(); 
+			print_watchdog_usage();
 		}
 	}
 	else {
diff --git a/lib/ipmi_pef.c b/lib/ipmi_pef.c
index fa96688..c8a8919 100644
--- a/lib/ipmi_pef.c
+++ b/lib/ipmi_pef.c
@@ -191,7 +191,10 @@ ipmi_pef_msg_exchange(struct ipmi_intf * intf, struct ipmi_rq * req, char * txt)
 	struct ipmi_rs * rsp = intf->sendrecv(intf, req);
 	if (!rsp)
 		return(NULL);
-	if (rsp->ccode) {
+	if (rsp->ccode == 0x80)	{
+		return(NULL);   /* Do not output error, just unsupported parameters */
+	}
+	else if (rsp->ccode) {
 		lprintf(LOG_ERR, " **Error %x in '%s' command",
 			rsp ? rsp->ccode : 0, txt);
 		return(NULL);
@@ -803,6 +806,7 @@ ipmi_pef_get_info(struct ipmi_intf * intf)
 	if (!rsp)
 		return;
 	pcap = (struct pef_capabilities *)rsp->data;
+
 	ipmi_pef_print_1xd("Version", pcap->version);
 	ipmi_pef_print_dec("PEF table size", pcap->tblsize);
 	ipmi_pef_print_dec("Alert policy table size", tbl_size);
diff --git a/lib/ipmi_picmg.c b/lib/ipmi_picmg.c
index 23a684c..8c2d6c2 100644
--- a/lib/ipmi_picmg.c
+++ b/lib/ipmi_picmg.c
@@ -34,6 +34,7 @@
 #include <ipmitool/ipmi_intf.h>
 #include <ipmitool/ipmi_picmg.h>
 #include <ipmitool/ipmi_fru.h>		/* for access to link descriptor defines */
+#include <ipmitool/ipmi_strings.h>
 #include <ipmitool/log.h>
 
 #define PICMG_EXTENSION_ATCA_MAJOR_VERSION  2
@@ -53,8 +54,21 @@
 #define PICMG_EKEY_AMC_MAX_CHANNEL  16
 #define PICMG_EKEY_AMC_MAX_DEVICE   15 /* 4 bits */
 
+
+typedef enum picmg_bused_resource_mode {
+	PICMG_BUSED_RESOURCE_SUMMARY,
+} t_picmg_bused_resource_mode ;
+
+
+typedef enum picmg_card_type {
+	PICMG_CARD_TYPE_CPCI,
+	PICMG_CARD_TYPE_ATCA,
+	PICMG_CARD_TYPE_AMC,
+	PICMG_CARD_TYPE_RESERVED
+} t_picmg_card_type ;
+
 /* This is the version of the PICMG Extenstion */
-static unsigned char PicmgExtMajorVersion;
+static t_picmg_card_type PicmgCardType = PICMG_CARD_TYPE_RESERVED;
 
 void
 ipmi_picmg_help (void)
@@ -80,7 +94,11 @@ ipmi_picmg_help (void)
 	printf(" power get            - get power level info\n");
 	printf(" power set            - set power level\n");
 	printf(" clk get              - get clk state\n");
+	printf(" clk getdenied        - get all(up to 16) denied[disabled] clock descriptions\n");
+	printf(" clk getgranted       - get all(up to 16) granted[enabled] clock descriptions\n");
+	printf(" clk getall           - get all(up to 16) clock descriptions\n");
 	printf(" clk set              - set clk state\n");
+	printf(" busres summary       - display brief bused resource status info \n");
 }
 
 
@@ -181,6 +199,7 @@ ipmi_picmg_getaddr(struct ipmi_intf * intf, int argc, char ** argv)
 int
 ipmi_picmg_properties(struct ipmi_intf * intf, int show )
 {
+	unsigned char PicmgExtMajorVersion;
 	struct ipmi_rs * rsp;
 	struct ipmi_rq req;
 	unsigned char msg_data;
@@ -211,6 +230,16 @@ ipmi_picmg_properties(struct ipmi_intf * intf, int show )
       to know how to format some commands */
 	PicmgExtMajorVersion = rsp->data[1]&0x0f;
 
+	if( PicmgExtMajorVersion == PICMG_CPCI_MAJOR_VERSION  ) { 
+		PicmgCardType = PICMG_CARD_TYPE_CPCI;
+   }
+	else if(  PicmgExtMajorVersion == PICMG_ATCA_MAJOR_VERSION) {
+		PicmgCardType = PICMG_CARD_TYPE_ATCA;
+   }
+	else if(  PicmgExtMajorVersion == PICMG_AMC_MAJOR_VERSION) {
+		PicmgCardType = PICMG_CARD_TYPE_AMC;
+   }
+    
 	return 0;
 }
 
@@ -526,7 +555,7 @@ ipmi_picmg_amc_portstate_get(struct ipmi_intf * intf,int device,int channel,
 	req.msg.data	  = msg_data;
 
 	/* FIXME : add check for AMC or carrier device */
-	if(device == -1 || PicmgExtMajorVersion != 2){
+	if(device == -1 || PicmgCardType != PICMG_CARD_TYPE_ATCA ){
 		req.msg.data_len = 2;	/* for amc only channel */
 	}else{
 		req.msg.data_len = 3;	/* for carrier channel and device */
@@ -595,7 +624,7 @@ ipmi_picmg_amc_portstate_get(struct ipmi_intf * intf,int device,int channel,
 					)
 				)
 				{
-					if(device == -1 || PicmgExtMajorVersion != 2){
+					if(device == -1 || PicmgCardType != PICMG_CARD_TYPE_ATCA ){
 						printf("   Link device :         AMC\n");
 					}else{
                   printf("   Link device :         0x%02x\n", device );
@@ -979,6 +1008,60 @@ ipmi_picmg_set_power_level(struct ipmi_intf * intf, int argc, char ** argv)
 }
 
 int
+ipmi_picmg_bused_resource(struct ipmi_intf * intf, t_picmg_bused_resource_mode mode)
+{
+	struct ipmi_rs * rsp;
+	struct ipmi_rq req;
+
+	unsigned char msg_data[6];
+	memset(&req, 0, sizeof(req));
+
+   int status = 0;
+   switch ( mode ) {
+      case PICMG_BUSED_RESOURCE_SUMMARY:
+      {
+         t_picmg_busres_resource_id resource;
+         t_picmg_busres_board_cmd_types cmd =PICMG_BUSRES_BOARD_CMD_QUERY;
+
+         req.msg.netfn	  = IPMI_NETFN_PICMG;
+         req.msg.cmd	     = PICMG_BUSED_RESOURCE_CMD;
+         req.msg.data	  = msg_data;
+         req.msg.data_len = 3;
+
+         /* IF BOARD
+            query for all resources
+         */
+         for( resource=PICMG_BUSRES_METAL_TEST_BUS_1;resource<=PICMG_BUSRES_SYNC_CLOCK_GROUP_3;resource+=(t_picmg_busres_resource_id)1 ) {
+            msg_data[0] = 0x00;					/* PICMG identifier */
+            msg_data[1] = (unsigned char) cmd;
+            msg_data[2] = (unsigned char) resource;
+            rsp = intf->sendrecv(intf, &req);
+
+            if (!rsp) {
+               printf("bused resource control: no response\n");
+               return -1;
+            }
+
+            if (rsp->ccode) {
+               printf("bused resource control: returned CC code 0x%02x\n", rsp->ccode);
+               return -1;
+            } else {
+               printf("Resource 0x%02x '%-26s' : 0x%02x [%s] \n" , 
+                       resource, val2str(resource,picmg_busres_id_vals),
+                       rsp->data[1], oemval2str(cmd,rsp->data[1],
+                      picmg_busres_board_status_vals));
+            }
+         }
+      }
+      break;
+      default :
+      break;
+   }
+
+   return status;
+}
+
+int
 ipmi_picmg_fru_control(struct ipmi_intf * intf, int argc, char ** argv)
 {
 	struct ipmi_rs * rsp;
@@ -997,7 +1080,8 @@ ipmi_picmg_fru_control(struct ipmi_intf * intf, int argc, char ** argv)
 	msg_data[1] = atoi(argv[0]);				/* FRU-ID	  */
 	msg_data[2] = atoi(argv[1]);				/* control option  */
 
-	printf("0: 0x%02x   1: 0x%02x\n\r", msg_data[1], msg_data[2]);
+	printf("FRU Device Id: %d FRU Control Option: %s\n\r", msg_data[1],  \
+				val2str( msg_data[2], picmg_frucontrol_vals));
 
 	rsp = intf->sendrecv(intf, &req);
 
@@ -1009,6 +1093,8 @@ ipmi_picmg_fru_control(struct ipmi_intf * intf, int argc, char ** argv)
 	if (rsp->ccode) {
 		printf("frucontrol: returned CC code 0x%02x\n", rsp->ccode);
 		return -1;
+	} else {
+      printf("frucontrol: ok\n");
 	}
 
 
@@ -1018,7 +1104,7 @@ ipmi_picmg_fru_control(struct ipmi_intf * intf, int argc, char ** argv)
 
 
 int
-ipmi_picmg_clk_get(struct ipmi_intf * intf, int argc, char ** argv)
+ipmi_picmg_clk_get(struct ipmi_intf * intf, int clk_id,int clk_res,int mode)
 {
 	int i;
 	struct ipmi_rs * rsp;
@@ -1034,14 +1120,15 @@ ipmi_picmg_clk_get(struct ipmi_intf * intf, int argc, char ** argv)
 	req.msg.netfn = IPMI_NETFN_PICMG;
 	req.msg.cmd   = PICMG_AMC_GET_CLK_STATE_CMD;
 	req.msg.data  = msg_data;
-	req.msg.data_len = 2;
 
 	msg_data[0] = 0x00;									/* PICMG identifier	 */
-	msg_data[1] = atoi(argv[0]);						/* clk id				 */
+	msg_data[1] = clk_id;
 
-	if(argc>2){
-		msg_data[2] = atoi(argv[1]);					/* resource id			 */
-		req.msg.data_len = 3;
+	if(clk_res == -1 || PicmgCardType != PICMG_CARD_TYPE_ATCA ){
+		req.msg.data_len = 2;	/* for amc only channel */
+	}else{
+		req.msg.data_len = 3;	/* for carrier channel and device */
+      msg_data[2] = clk_res;
 	}
 
 	rsp = intf->sendrecv(intf, &req);
@@ -1051,31 +1138,68 @@ ipmi_picmg_clk_get(struct ipmi_intf * intf, int argc, char ** argv)
 		return -1;
 	}
 
-	if (rsp->ccode) {
+	if (rsp->ccode && (mode == PICMG_EKEY_MODE_QUERY) ) {
 		printf("returned CC code 0x%02x\n", rsp->ccode);
 		return -1;
 	}
 
-	enabled	 = (rsp->data[1]&0x8)!=0;
-	direction = (rsp->data[1]&0x4)!=0;
-
-	printf("CLK setting: 0x%02x\n", rsp->data[1]);
-	printf(" - state:     %s\n", (enabled)?"enabled":"disabled");
-	printf(" - direction: %s\n", (direction)?"Source":"Receiver");
-	printf(" - PLL ctrl:  0x%x\n", rsp->data[1]&0x3);
-
-   if(enabled){
-      unsigned long freq = 0;
-      freq = (  rsp->data[5] <<  0
-              | rsp->data[6] <<  8
-              | rsp->data[7] << 16
-              | rsp->data[8] << 24 );
-      printf("  - Index:  %d\n", rsp->data[2]);
-      printf("  - Family: %d\n", rsp->data[3]);
-      printf("  - AccLVL: %d\n", rsp->data[4]);
-      printf("  - Freq:   %d\n", freq);
-   }
-
+	if (rsp->ccode == 0 ) {
+		enabled	 = (rsp->data[1]&0x8)!=0;
+		direction = (rsp->data[1]&0x4)!=0;
+
+		if
+		( 
+			mode == PICMG_EKEY_MODE_QUERY
+ 			||
+ 			mode == PICMG_EKEY_MODE_PRINT_ALL
+ 			||
+ 			(
+ 				mode == PICMG_EKEY_MODE_PRINT_DISABLED
+ 				&&
+ 				enabled == 0
+ 			)
+ 			||
+ 			(
+ 				mode == PICMG_EKEY_MODE_PRINT_ENABLED
+ 				&&
+ 				enabled == 1
+         )	
+		) {
+			if( PicmgCardType != PICMG_CARD_TYPE_AMC ) {
+				printf("CLK resource id   : %3d [ %s ]\n", clk_res ,
+					oemval2str( ((clk_res>>6)&0x03), (clk_res&0x0F),
+														picmg_clk_resource_vals));				
+			} else {
+				printf("CLK resource id   : N/A [ AMC Module ]\n");
+				clk_res = 0x40; /* Set */
+			} 
+         printf("CLK id            : %3d [ %s ]\n", clk_id,
+					oemval2str( ((clk_res>>6)&0x03), clk_id ,
+														picmg_clk_id_vals));				
+
+
+			printf("CLK setting       : 0x%02x\n", rsp->data[1]);
+			printf(" - state:     %s\n", (enabled)?"enabled":"disabled");
+			printf(" - direction: %s\n", (direction)?"Source":"Receiver");
+			printf(" - PLL ctrl:  0x%x\n", rsp->data[1]&0x3);
+
+		   if(enabled){
+		      unsigned long freq = 0;
+		      freq = (  rsp->data[5] <<  0
+		              | rsp->data[6] <<  8
+		              | rsp->data[7] << 16
+		              | rsp->data[8] << 24 );
+		      printf("  - Index:  %3d\n", rsp->data[2]);
+		      printf("  - Family: %3d [ %s ] \n", rsp->data[3], 
+						val2str( rsp->data[3], picmg_clk_family_vals));
+		      printf("  - AccLVL: %3d [ %s ] \n", rsp->data[4], 
+						oemval2str( rsp->data[3], rsp->data[4],
+											picmg_clk_accuracy_vals));
+		
+		      printf("  - Freq:   %d\n", freq);
+		   }
+		}
+	}
 	return 0;
 }
 
@@ -1095,7 +1219,6 @@ ipmi_picmg_clk_set(struct ipmi_intf * intf, int argc, char ** argv)
 	req.msg.netfn = IPMI_NETFN_PICMG;
 	req.msg.cmd	  = PICMG_AMC_SET_CLK_STATE_CMD;
 	req.msg.data  = msg_data;
-	req.msg.data_len = 11;
 
 	msg_data[0] = 0x00;									/* PICMG identifier	 */
 	msg_data[1] = strtoul(argv[0], NULL,0);				/* clk id				 */
@@ -1110,12 +1233,25 @@ ipmi_picmg_clk_set(struct ipmi_intf * intf, int argc, char ** argv)
 	msg_data[8] = (freq >>16)& 0xFF;		/* freq					 */
 	msg_data[9] = (freq >>24)& 0xFF;		/* freq					 */
 
-	msg_data[10] = strtoul(argv[6	], NULL,0);	/* resource id			 */
+	req.msg.data_len = 10;
+   if( PicmgCardType == PICMG_CARD_TYPE_ATCA  )
+   {
+      if( argc > 7)
+      {
+         req.msg.data_len = 11;
+         msg_data[10] = strtoul(argv[6], NULL,0);	/* resource id			 */
+      }
+      else
+      {
+         printf("missing resource id for atca board\n");
+         return -1;
+      }
+   }
 
 #if 1
 printf("## ID:      %d\n", msg_data[1]);
 printf("## index:   %d\n", msg_data[2]);
-printf("## setting: 0x02x\n", msg_data[3]);
+printf("## setting: 0x%02x\n", msg_data[3]);
 printf("## family:  %d\n", msg_data[4]);
 printf("## acc:     %d\n", msg_data[5]);
 printf("## freq:    %d\n", freq );
@@ -1160,7 +1296,15 @@ ipmi_picmg_main (struct ipmi_intf * intf, int argc, char ** argv)
 	else if (!strncmp(argv[0], "addrinfo", 8)) {
 		rc = ipmi_picmg_getaddr(intf, argc-1, &argv[1]);
 	}
-
+	else if (!strncmp(argv[0], "busres", 6)) {
+		if (argc > 1) {
+			if (!strncmp(argv[1], "summary", 7)) {
+				ipmi_picmg_bused_resource(intf, PICMG_BUSED_RESOURCE_SUMMARY );
+			}
+		} else {
+				printf("usage: busres summary\n");
+      }
+	}
 	/* fru control command */
 	else if (!strncmp(argv[0], "frucontrol", 10)) {
 		if (argc > 2) {
@@ -1169,17 +1313,16 @@ ipmi_picmg_main (struct ipmi_intf * intf, int argc, char ** argv)
 		else {
 			printf("usage: frucontrol <FRU-ID> <OPTION>\n");
 			printf("   OPTION:\n");
-			printf("      0x00      - Cold Reset\n");
-			printf("      0x01      - Warm Reset\n");
-			printf("      0x02      - Graceful Reboot\n");
-			printf("      0x03      - Issue Diagnostic Interrupt\n");
-			printf("      0x04      - Quiesce [AMC only]\n");
-			printf("      0x05-0xFF - Cold Reset\n");
+			printf("      0      - Cold Reset\n");
+			printf("      1      - Warm Reset\n");
+			printf("      2      - Graceful Reboot\n");
+			printf("      3      - Issue Diagnostic Interrupt\n");
+			printf("      4      - Quiesce [AMC only]\n");
+			printf("      5-255  - Reserved\n");
 
 			return -1;
 		}
 
-		printf("frucontrol\n\r");
 	}
 
 	/* fru activation command */
@@ -1279,7 +1422,7 @@ ipmi_picmg_main (struct ipmi_intf * intf, int argc, char ** argv)
 					channel   = atoi(argv[3]);
 					lprintf(LOG_DEBUG,"PICMG: requesting interface %d",iface);
 					lprintf(LOG_DEBUG,"PICMG: requesting channel %d",channel);
-	
+
 					rc = ipmi_picmg_portstate_get(intf,iface,channel,
 					            PICMG_EKEY_MODE_QUERY );
 				}
@@ -1305,7 +1448,7 @@ ipmi_picmg_main (struct ipmi_intf * intf, int argc, char ** argv)
 						lprintf(LOG_DEBUG,"PICMG: group %d",group);
 						lprintf(LOG_DEBUG,"PICMG: enable %d",enable);
 
-						rc = ipmi_picmg_portstate_set(intf, interface, 
+						rc = ipmi_picmg_portstate_set(intf, interface,
 						    channel, port, type, typeext  ,group ,enable);
 					}
 					else {
@@ -1333,7 +1476,7 @@ ipmi_picmg_main (struct ipmi_intf * intf, int argc, char ** argv)
 
 				if(!strncmp(argv[1], "getall", 6)){
 					int maxDevice = PICMG_EKEY_AMC_MAX_DEVICE;
-					if( PicmgExtMajorVersion != 2){
+					if( PicmgCardType != PICMG_CARD_TYPE_ATCA ){
 						maxDevice = 0;
 					}
 					for(device=0;device<=maxDevice;device++){
@@ -1345,7 +1488,7 @@ ipmi_picmg_main (struct ipmi_intf * intf, int argc, char ** argv)
 				}
 				else if(!strncmp(argv[1], "getgranted", 10)){
 					int maxDevice = PICMG_EKEY_AMC_MAX_DEVICE;
-					if( PicmgExtMajorVersion != 2){
+					if( PicmgCardType != PICMG_CARD_TYPE_ATCA ){
 						maxDevice = 0;
 					}
 					for(device=0;device<=maxDevice;device++){
@@ -1357,7 +1500,7 @@ ipmi_picmg_main (struct ipmi_intf * intf, int argc, char ** argv)
 				}
 				else if(!strncmp(argv[1], "getdenied", 9)){
 					int maxDevice = PICMG_EKEY_AMC_MAX_DEVICE;
-					if( PicmgExtMajorVersion != 2){
+					if( PicmgCardType != PICMG_CARD_TYPE_ATCA ){
 						maxDevice = 0;
 					}
 					for(device=0;device<=maxDevice;device++){
@@ -1509,7 +1652,7 @@ ipmi_picmg_main (struct ipmi_intf * intf, int argc, char ** argv)
 					printf("            0x1-0x14 : Power level\n");
 					printf("            0xFF :     do not change\n");
 					printf("\n");
-					printf("   <present-desired> 0: do not change present levelsn");
+					printf("   <present-desired> 0: do not change present levels\n");
 					printf("                     1: copy desired to present level\n");
 
 					return -1;
@@ -1528,15 +1671,53 @@ ipmi_picmg_main (struct ipmi_intf * intf, int argc, char ** argv)
 	else if (!strncmp(argv[0], "clk", 3)) {
 		if (argc > 1) {
 			if (!strncmp(argv[1], "get", 3)) {
-				if (argc > 2) {
-					unsigned char clk_id;
-					unsigned char clk_res;
+				int clk_id;
+				int clk_res = -1;            
+				int max_res = 15;
 
-					rc = ipmi_picmg_clk_get(intf, argc-1, &(argv[2]));
+				if( PicmgCardType == PICMG_CARD_TYPE_AMC ) {
+					max_res = 0;
 				}
-				else {
-					printf("clk get <CLK-ID> [<DEV-ID>]\n");
 
+				if(!strncmp(argv[1], "getall", 6)) {
+					if( verbose ) { printf("Getting all clock state\n") ;}	
+					for(clk_res=0;clk_res<=max_res;clk_res++) {
+						for(clk_id=0;clk_id<=15;clk_id++) {
+								rc = ipmi_picmg_clk_get(intf,clk_id,clk_res,
+								        PICMG_EKEY_MODE_PRINT_ALL);
+						}
+					}
+				}
+				else if(!strncmp(argv[1], "getdenied", 6)) {
+					if( verbose ) { printf("Getting disabled clocks\n") ;}	
+					for(clk_res=0;clk_res<=max_res;clk_res++) {
+						for(clk_id=0;clk_id<=15;clk_id++) {
+								rc = ipmi_picmg_clk_get(intf,clk_id,clk_res,
+								        PICMG_EKEY_MODE_PRINT_DISABLED);
+						}
+					}
+				}
+				else if(!strncmp(argv[1], "getgranted", 6)) {
+					if( verbose ) { printf("Getting enabled clocks\n") ;}	
+					for(clk_res=0;clk_res<=max_res;clk_res++) {
+						for(clk_id=0;clk_id<=15;clk_id++) {
+								rc = ipmi_picmg_clk_get(intf,clk_id,clk_res,
+								        PICMG_EKEY_MODE_PRINT_ENABLED);
+						}
+					}
+				}
+				else if (argc > 2) {
+					clk_id = atoi(argv[2]);
+					if (argc > 3) {
+						clk_res = atoi(argv[3]);
+					}
+
+					rc = ipmi_picmg_clk_get(intf, clk_id, clk_res,
+							PICMG_EKEY_MODE_QUERY );
+				}
+				else {
+					printf("clk get ");
+					printf("<CLK-ID> [<DEV-ID>] |getall|getgranted|getdenied\n");
 					return -1;
 				}
 			}
@@ -1551,12 +1732,12 @@ ipmi_picmg_main (struct ipmi_intf * intf, int argc, char ** argv)
 				}
 			}
 			else {
-				printf("<set>|<get>\n");
+				printf("<set>|<get>|<getall>|<getgranted>|<getdenied>\n");
 				return -1;
 			}
 		}
 		else {
-			printf("<set>|<get>\n");
+			printf("<set>|<get>|<getall>|<getgranted>|<getdenied>\n");
 			return -1;
 		}
 	}
diff --git a/lib/ipmi_sdr.c b/lib/ipmi_sdr.c
index e06a4bd..e55f291 100644
--- a/lib/ipmi_sdr.c
+++ b/lib/ipmi_sdr.c
@@ -1172,25 +1172,23 @@ ipmi_sdr_print_sensor_full(struct ipmi_intf *intf,
 			/* Sensor Scanning Disabled */
 			validread = 0;
 			if (rsp->data[0] != 0) { 	 
-				/* we might still get a valid reading */ 	 
+				/* we might still get a valid reading , but even 0 might be a valid reading */
 				if (sensor->linearization>=SDR_SENSOR_L_NONLINEAR && sensor->linearization<=0x7F)
 					ipmi_sensor_get_sensor_reading_factors(intf, sensor, rsp->data[0]);
 				val = sdr_convert_sensor_reading(sensor, 	 
 					rsp->data[0]); 	 
-				if (val != 0.0) 	 
+				if (val != 0.0) /* .. an 0.0 might as well be valid */ 	 
 					validread = 1; 	 
 			}
-		} else if (rsp->data[0] != 0) {
+		} else {
 			/* Non linear sensors might provide updated reading factors */
 			if (sensor->linearization>=SDR_SENSOR_L_NONLINEAR && sensor->linearization<=0x7F) {
 				if (ipmi_sensor_get_sensor_reading_factors(intf, sensor, rsp->data[0]) < 0){
 					validread = 0;
 				}
 			}
-			/* convert RAW reading into units */
-			if (rsp->data[0] != 0) {
-				val = sdr_convert_sensor_reading(sensor, rsp->data[0]);
-			}
+			/* convert RAW reading into units */			
+         val = sdr_convert_sensor_reading(sensor, rsp->data[0]);
 		}
 	}
 
@@ -1390,6 +1388,8 @@ ipmi_sdr_print_sensor_full(struct ipmi_intf *intf,
 						   DISCRETE_SENSOR,
 						   target,
 						   lun);
+		printf(" OEM                   : %X\n",
+		       sensor->oem);
 		printf("\n");
 
 		return 0;	/* done */
@@ -1613,7 +1613,8 @@ ipmi_sdr_print_discrete_state_mini(const char *separator,
 	}
 
 	for (; evt->type != NULL; evt++) {
-		if (evt->code != typ)
+		if ((evt->code != typ) ||
+			(evt->data != 0xFF))
 			continue;
 
 		if (evt->offset > 7) {
@@ -1664,7 +1665,8 @@ ipmi_sdr_print_discrete_state(const char *desc,
 	}
 
 	for (; evt->type != NULL; evt++) {
-		if (evt->code != typ)
+		if ((evt->code != typ) ||
+			(evt->data != 0xFF))
 			continue;
 
 		if (pre == 0) {
@@ -1795,6 +1797,8 @@ ipmi_sdr_print_sensor_compact(struct ipmi_intf *intf,
 						   DISCRETE_SENSOR,
 						   target,
 						   lun);
+		printf(" OEM                   : %X\n",
+		       sensor->oem);
 		printf("\n");
 	} else {
 		int dostate = 1;
@@ -2282,6 +2286,64 @@ ipmi_sdr_print_sensor_oem(struct ipmi_intf *intf, struct sdr_record_oem *oem)
 	return rc;
 }
 
+/* ipmi_sdr_print_name_from_rawentry  -  Print SDR name  from raw data
+ *
+ * @intf:	ipmi interface
+ * @type:	sensor type
+ * @raw:	raw sensor data
+ *
+ * returns 0 on success
+ * returns -1 on error
+ */
+int
+ipmi_sdr_print_name_from_rawentry(struct ipmi_intf *intf,uint16_t id, 
+                                  uint8_t type,uint8_t * raw)
+{
+   union {
+      struct sdr_record_full_sensor *full;
+      struct sdr_record_compact_sensor *compact;
+      struct sdr_record_eventonly_sensor *eventonly;
+      struct sdr_record_generic_locator *genloc;
+      struct sdr_record_fru_locator *fruloc;
+      struct sdr_record_mc_locator *mcloc;
+      struct sdr_record_entity_assoc *entassoc;
+      struct sdr_record_oem *oem;
+   } record;
+
+   int rc =0;
+   char desc[17];
+   memset(desc, ' ', sizeof (desc));
+
+   switch ( type) {
+      case SDR_RECORD_TYPE_FULL_SENSOR:
+      record.full = (struct sdr_record_full_sensor *) raw;
+      snprintf(desc, (record.full->id_code & 0x1f) +1, "%s",
+               (const char *)record.full->id_string);
+      break;
+      case SDR_RECORD_TYPE_COMPACT_SENSOR:
+      record.compact = (struct sdr_record_compact_sensor *) raw	;
+      snprintf(desc, (record.compact->id_code & 0x1f)  +1, "%s",
+               (const char *)record.compact->id_string);
+      break;
+      case SDR_RECORD_TYPE_EVENTONLY_SENSOR:
+      record.eventonly  = (struct sdr_record_eventonly_sensor *) raw ;
+      snprintf(desc, (record.eventonly->id_code & 0x1f)  +1, "%s",
+               (const char *)record.eventonly->id_string);
+      break;            
+      case SDR_RECORD_TYPE_MC_DEVICE_LOCATOR:
+      record.mcloc  = (struct sdr_record_mc_locator *) raw ;
+      snprintf(desc, (record.mcloc->id_code & 0x1f)  +1, "%s",
+               (const char *)record.mcloc->id_string);		
+      break;
+      default:
+      rc = -1;
+      break;
+   }   
+
+      lprintf(LOG_INFO, "ID: 0x%04x , NAME: %-16s", id, desc);
+   return rc;
+}
+
 /* ipmi_sdr_print_rawentry  -  Print SDR entry from raw data
  *
  * @intf:	ipmi interface
@@ -2455,6 +2517,7 @@ ipmi_sdr_print_sdr(struct ipmi_intf *intf, uint8_t type)
 
 		rec = ipmi_sdr_get_record(intf, header, sdr_list_itr);
 		if (rec == NULL) {
+			lprintf(LOG_ERR, "ipmitool: ipmi_sdr_get_record() failed");
 			rc = -1;
 			continue;
 		}
@@ -2502,6 +2565,8 @@ ipmi_sdr_print_sdr(struct ipmi_intf *intf, uint8_t type)
 			continue;
 		}
 
+                lprintf(LOG_DEBUG, "SDR record ID   : 0x%04x", sdrr->id);
+
 		if (type == header->type || type == 0xff ||
 		    (type == 0xfe &&
 		     (header->type == SDR_RECORD_TYPE_FULL_SENSOR ||
@@ -2658,6 +2723,17 @@ ipmi_sdr_start(struct ipmi_intf *intf, int use_builtin)
 
 		lprintf(LOG_DEBUG, "SDR free space: %d", sdr_info.free);
 		lprintf(LOG_DEBUG, "SDR records   : %d", sdr_info.count);
+
+		/* Build SDRR if there is no record in repository */
+		if( sdr_info.count == 0 ) {
+		   lprintf(LOG_DEBUG, "Rebuilding SDRR...");
+
+		   if( ipmi_sdr_add_from_sensors( intf, 0 ) != 0 ) {
+		      lprintf(LOG_ERR, "Could not build SDRR!");
+		      free(itr);
+		      return NULL;
+		   }
+		}
 	} else {
 		struct sdr_device_info_rs sdr_info;
 		/* get device sdr info */
@@ -4328,7 +4404,14 @@ ipmi_sdr_main(struct ipmi_intf *intf, int argc, char **argv)
 		lprintf(LOG_ERR,
 			"                     sensors       Creates the SDR repository for the current configuration");
 		lprintf(LOG_ERR,
+			"                     nosat        Creates the SDR repository for the current configuration, without satellite scan");
+
+		lprintf(LOG_ERR,
 			"                     file <file>   Load SDR repository from a file");
+		lprintf(LOG_ERR,
+			"                     range <range> Load SDR repository from a provided list or range");
+		lprintf(LOG_ERR,
+			"                                    - Use , for list or - for range (Ex.: 0x28,0x32,0x40-0x44) ");
 	} else if (strncmp(argv[0], "list", 4) == 0
 		   || strncmp(argv[0], "elist", 5) == 0) {
 
@@ -4381,9 +4464,12 @@ ipmi_sdr_main(struct ipmi_intf *intf, int argc, char **argv)
 		if (argc <= 1) {
 			lprintf(LOG_ERR, "usage: sdr fill sensors");
 			lprintf(LOG_ERR, "usage: sdr fill file <filename>");
+			lprintf(LOG_ERR, "usage: sdr fill range <, and - separated> ");
 			rc = -1;
 		} else if (strncmp(argv[1], "sensors", 7) == 0) {
 			rc = ipmi_sdr_add_from_sensors(intf, 21);
+		} else if (strncmp(argv[1], "nosats", 6) == 0) {
+			rc = ipmi_sdr_add_from_sensors(intf, 0);
 		} else if (strncmp(argv[1], "file", 4) == 0) {
 			if (argc < 3) {
 				lprintf(LOG_ERR, "sdr fill: Missing filename");
@@ -4391,6 +4477,13 @@ ipmi_sdr_main(struct ipmi_intf *intf, int argc, char **argv)
 			} else {
 				rc = ipmi_sdr_add_from_file(intf, argv[2]);
 			}
+		} else if (strncmp(argv[1], "range", 4) == 0) {
+			if (argc < 3) {
+				lprintf(LOG_ERR, "sdr range: Missing range - Use , for list or - for range (Ex.: 0x28,0x32,0x40-0x44)");
+				rc = -1;
+			} else {
+				rc = ipmi_sdr_add_from_list(intf, argv[2]);
+			}
 		}
 	} else {
 		lprintf(LOG_ERR, "Invalid SDR command: %s", argv[0]);
diff --git a/lib/ipmi_sdradd.c b/lib/ipmi_sdradd.c
index ec2cadf..1ac0d24 100644
--- a/lib/ipmi_sdradd.c
+++ b/lib/ipmi_sdradd.c
@@ -52,6 +52,9 @@
 
 #define ADD_PARTIAL_SDR 0x25
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct sdr_add_rq {
   uint16_t reserve_id;  /* reservation ID */
   uint16_t id;          /* record ID */
@@ -60,9 +63,16 @@ struct sdr_add_rq {
 #define PARTIAL_ADD (0)
 #define LAST_RECORD (1)
   uint8_t data[1];      /* SDR record data */
-} __attribute__ ((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
-static int sdr_max_write_len = 24;
+/* This was formerly initialized to 24, reduced this to 19 so the overall
+   message fits into the recommended 32-byte limit */
+static int sdr_max_write_len = 19;
+int ipmi_parse_range_list(const char *rangeList, unsigned char *pHexList);
+int ipmi_hex_to_dec( char * rangeList, unsigned char * pDecValue);
 
 static int
 partial_send(struct ipmi_intf *intf, struct ipmi_rq *req, uint16_t *id)
@@ -93,11 +103,15 @@ ipmi_sdr_add_record(struct ipmi_intf *intf, struct sdr_record_list *sdrr)
   int rc = 0;
 
   /* actually no SDR to program */
-  if (len < 1 || !sdrr->raw)
+  if (len < 1 || !sdrr->raw) {
+    lprintf(LOG_ERR, "ipmitool: bad record , skipped");
     return 0;
+  }
 
-  if (ipmi_sdr_get_reservation(intf, 0, &reserve_id))
+  if (ipmi_sdr_get_reservation(intf, 0, &reserve_id)) {
+    lprintf(LOG_ERR, "ipmitool: reservation failed");
     return -1;
+  }
 
   sdr_rq = (struct sdr_add_rq *)malloc(sizeof(*sdr_rq) + sdr_max_write_len);
   if (sdr_rq == NULL) {
@@ -123,6 +137,7 @@ ipmi_sdr_add_record(struct ipmi_intf *intf, struct sdr_record_list *sdrr)
   req.msg.data_len = 5 + sizeof(*sdr_rq) - 1;
 
   if (partial_send(intf, &req, &id)) {
+     lprintf(LOG_ERR, "ipmitool: partial send error");
     free(sdr_rq);
     return -1;
   }
@@ -131,9 +146,8 @@ ipmi_sdr_add_record(struct ipmi_intf *intf, struct sdr_record_list *sdrr)
 
   /* sdr entry */
   while (i < len) {
-    int data_len = 0;
-
-    if (len - i < sdr_max_write_len) {
+     int data_len = 0;
+     if ( (len - i) <= sdr_max_write_len) {
       /* last crunch */
       data_len = len - i;
       sdr_rq->in_progress = LAST_RECORD;
@@ -147,11 +161,13 @@ ipmi_sdr_add_record(struct ipmi_intf *intf, struct sdr_record_list *sdrr)
     req.msg.data_len = data_len + sizeof(*sdr_rq) - 1;
 
     if ((rc = partial_send(intf, &req, &id)) != 0) {
+       lprintf(LOG_ERR, "ipmitool: partial add failed");
       break;
     }
 
     i += data_len;
   }
+
   free(sdr_rq);
   return rc;
 }
@@ -238,11 +254,13 @@ sdrr_get_records(struct ipmi_intf *intf, struct ipmi_sdr_iterator *itr,
       return -1;
     }
     memset(sdrr, 0, sizeof (struct sdr_record_list));
+   
     sdrr->id = header->id;
     sdrr->version = header->version;
     sdrr->type = header->type;
     sdrr->length = header->length;
     sdrr->raw = ipmi_sdr_get_record(intf, header, itr);
+    (void)ipmi_sdr_print_name_from_rawentry(intf,  sdrr->id, sdrr->type,sdrr->raw);
 
     /* put in the record queue */
     if (queue->head == NULL)
@@ -266,6 +284,8 @@ sdr_copy_to_sdrr(struct ipmi_intf *intf, int use_builtin,
 
   /* generate list of records for this target */
   intf->target_addr = from_addr;
+
+  /* initialize iterator */
   itr = ipmi_sdr_start(intf, use_builtin);
   if (itr == 0)
     return 0;
@@ -273,6 +293,7 @@ sdr_copy_to_sdrr(struct ipmi_intf *intf, int use_builtin,
   printf("Load SDRs from 0x%x\n", from_addr);
   rc = sdrr_get_records(intf, itr, &sdrr_queue);
   ipmi_sdr_end(intf, itr);
+  /* ... */
 
   /* write the SDRs to the destination SDR Repository */
   intf->target_addr = to_addr;
@@ -304,14 +325,241 @@ ipmi_sdr_add_from_sensors(struct ipmi_intf *intf, int maxslot)
   rc = sdr_copy_to_sdrr(intf, 1, myaddr, myaddr);
 
   /* Now fill the SDRR with remote sensors */
-  for (i = 0, slave_addr = 0xB0; i < maxslot; i++, slave_addr += 2) {
-    /* Hole in the PICMG 2.9 mapping */
-    if (slave_addr == 0xC2) slave_addr += 2;
-    if(sdr_copy_to_sdrr(intf, 0, slave_addr, myaddr) < 0)
+  if( maxslot != 0 ) {
+     for (i = 0, slave_addr = 0xB0; i < maxslot; i++, slave_addr += 2) {
+        /* Hole in the PICMG 2.9 mapping */
+        if (slave_addr == 0xC2) slave_addr += 2;
+        if(sdr_copy_to_sdrr(intf, 0, slave_addr, myaddr) < 0)
+        {
+           rc = -1;
+        }
+     }
+  }
+  return rc;
+}
+
+int ipmi_hex_to_dec( char * strchar, unsigned char * pDecValue)
+{
+  int rc = -1;
+  unsigned char retValue = 0; 
+
+  if(
+     (strlen(strchar) == 4) 
+     &&
+     (strchar[0] == '0') 
+     && 
+     (strchar[1] == 'x') 
+    ) 
+  {
+      rc = 0;
+
+      if((strchar[2] >= '0') && (strchar[2] <= '9')) 
+      {
+        retValue += ((strchar[2]-'0') * 16);
+      }
+      else if((strchar[2] >= 'a') && (strchar[2] <= 'f')) 
+      {
+        retValue += (((strchar[2]-'a') + 10) * 16);
+      }
+      else if((strchar[2] >= 'A') && (strchar[2] <= 'F')) 
+      {
+        retValue += (((strchar[2]-'A') + 10) * 16);
+      }
+      else
+      {
+        rc = -1;
+      }
+
+      if((strchar[3] >= '0') && (strchar[3] <= '9')) 
+      {
+        retValue += ((strchar[3]-'0'));
+      }
+      else if((strchar[3] >= 'a') && (strchar[3] <= 'f')) 
+      {
+        retValue += (((strchar[3]-'a') + 10));
+      }
+      else if((strchar[3] >= 'A') && (strchar[3] <= 'F')) 
+      {
+        retValue += (((strchar[3]-'A') + 10));
+      }
+      else
+      {
+        rc = -1;
+      }
+  }
+
+  if(rc == 0) 
+  {
+    * pDecValue = retValue;
+  }
+  else
+  {
+    lprintf(LOG_ERR, "Must be Hex value of 4 characters (Ex.: 0x24)\n");
+  }
+
+  return rc;
+}
+
+
+
+#define MAX_NUM_SLOT  128
+int ipmi_parse_range_list(const char *rangeList, unsigned char * pHexList)
+{
+  int rc = -1;
+
+  unsigned char listOffset = 0;
+  char * nextString;
+  char * rangeString;
+  char * inProcessString = (char *) rangeList;
+
+  /* Discard empty string */
+  if(strlen(rangeList) == 0) 
+  {
+    return rc;
+  }
+
+  /* First, cut to comma separated string */
+  nextString = strstr( rangeList, "," );
+
+  if(nextString != rangeList) 
+  {
+    unsigned char isLast;
+    /* We get a valid string so far */
+    rc = 0;
+
+    do
     {
-      rc = -1;
+      if(nextString != NULL) 
+      {
+        (*nextString)= 0;
+        nextString   ++;
+        isLast = 0;
+      }
+      else
+      {
+        isLast = 1;
+      }
+
+      /* At this point, it is a single entry or a range */
+      rangeString = strstr( inProcessString, "-" );
+      if(rangeString == NULL) 
+      {
+        unsigned char decValue = 0;
+
+        /* Single entry */
+        rc = ipmi_hex_to_dec( inProcessString, &decValue); 
+        
+        if(rc == 0)
+        {  
+          if((decValue % 2) == 0)
+          {
+            pHexList[listOffset++] = decValue;
+          }
+          else
+          {
+            lprintf(LOG_ERR, "I2c address provided value must be even.\n");
+          }
+        }
+      }
+      else
+      {
+        unsigned char startValue = 0;
+        unsigned char endValue = 0;
+
+
+        (*rangeString)= 0; /* Cut string*/
+        rangeString ++;
+
+        /* Range */
+        rc = ipmi_hex_to_dec( inProcessString, &startValue); 
+        if(rc == 0) 
+          rc = ipmi_hex_to_dec( rangeString, &endValue); 
+
+        if(rc == 0)
+        {  
+          if(((startValue % 2) == 0) && ((endValue % 2) == 0))
+          {
+            do
+            {
+              pHexList[listOffset++] = startValue;
+              startValue += 2;
+            }
+            while(startValue != endValue);
+            pHexList[listOffset++] = endValue;
+          }
+          else
+          {
+            lprintf(LOG_ERR, "I2c address provided value must be even.\n");
+          }
+        }
+      }
+
+      if(isLast == 0) 
+      {
+        /* Setup for next string */
+        inProcessString = nextString;
+        nextString = strstr( rangeList, "," );
+      }
+    }while ((isLast == 0) && (rc == 0)); 
+  }
+
+  return rc;
+}
+
+int
+ipmi_sdr_add_from_list(struct ipmi_intf *intf, const char *rangeList)
+{
+  int i;
+  int rc = 0;
+  int slave_addr;
+  int myaddr = intf->target_addr;
+  unsigned char listValue[MAX_NUM_SLOT];
+
+  memset( listValue, 0, MAX_NUM_SLOT );
+
+  /* Build list from string */
+  if(ipmi_parse_range_list(rangeList, listValue) != 0)
+  {
+    lprintf(LOG_ERR, "Range - List invalid, cannot be parsed.");
+    return -1;
+  }
+
+  {
+    unsigned char counter = 0;
+    printf("List to scan: (Built-in) ");
+    while(listValue[counter] != 0) 
+    {
+      printf("%02x ", listValue[counter]);
+      counter++;
+    }
+    printf("\n");
+  }
+
+  printf("Clearing SDR Repository\n");
+  if (ipmi_sdr_repo_clear(intf)) {
+    lprintf(LOG_ERR, "Cannot erase SDRR. Give up.");
+    return -1;
+  }
+
+  /* First fill the SDRR from local built-in sensors */
+  printf("Sanning built-in sensors..\n");
+  rc = sdr_copy_to_sdrr(intf, 1, myaddr, myaddr);
+
+  /* Now fill the SDRR with provided sensors list */
+  {
+    unsigned char counter = 0;
+    while((rc == 0) && (listValue[counter] != 0)) 
+    {
+      slave_addr = listValue[counter];
+      printf("Scanning %02Xh..\n", slave_addr);
+      if(sdr_copy_to_sdrr(intf, 0, slave_addr, myaddr) < 0)
+      {
+         rc = -1;
+      }
+      counter++;
     }
   }
+
   return rc;
 }
 
diff --git a/lib/ipmi_sel.c b/lib/ipmi_sel.c
index cb8243e..bfb27c4 100644
--- a/lib/ipmi_sel.c
+++ b/lib/ipmi_sel.c
@@ -440,7 +440,7 @@ get_kontron_evt_desc(struct ipmi_intf * intf, struct sel_event_record * rec)
 		}
 	}
 
-	return "Unsupported event";
+	return NULL;
 }
 
 char *
@@ -956,11 +956,18 @@ ipmi_sel_print_std_entry(struct ipmi_intf * intf, struct sel_event_record * evt)
 	if (evt->record_type < 0xe0)
 	{
 		if ((evt->sel_type.standard_type.timestamp < 0x20000000)||(evt->sel_type.oem_ts_type.timestamp <  0x20000000)){
-			printf("Pre-Init Time-stamp");
+			printf(" Pre-Init "); 
+
+			if (csv_output)
+				printf(",");
+			else
+				printf(" |");
+
+			printf("%010d", evt->sel_type.standard_type.timestamp );
 			if (csv_output)
-				printf(",,");
+				printf(",");
 			else
-				printf("   | ");
+				printf("| ");
 		}
 		else {
 			if (evt->record_type < 0xc0)
@@ -1248,8 +1255,9 @@ ipmi_sel_print_extended_entry_verbose(struct ipmi_intf * intf, struct sel_event_
 					  evt->sel_type.standard_type.gen_id,
 					  evt->sel_type.standard_type.sensor_num,
 					  evt->sel_type.standard_type.sensor_type);
-	if (sdr == NULL) {
-		ipmi_sel_print_std_entry_verbose(intf, evt);
+	if (sdr == NULL) 
+	{
+	    ipmi_sel_print_std_entry_verbose(intf, evt);
 		return;
 	}
 
@@ -1378,9 +1386,10 @@ ipmi_sel_print_extended_entry_verbose(struct ipmi_intf * intf, struct sel_event_
 	} else if (evt->sel_type.standard_type.event_type >= 0x2 && evt->sel_type.standard_type.event_type <= 0xc) {
 		/* Generic Discrete */
 	} else if (evt->sel_type.standard_type.event_type == 0x6f) {
+
 		/* Sensor-Specific Discrete */
-		if (evt->sel_type.standard_type.sensor_type == 0xC &&
-		    evt->sel_type.standard_type.sensor_num  == 0 &&
+		if (evt->sel_type.standard_type.sensor_type == 0xC &&		   
+		    evt->sel_type.standard_type.sensor_num  == 0 &&			 /**** THIS LOOK TO BE OEM ****/
 		    (evt->sel_type.standard_type.event_data[0] & 0x30) == 0x20)
 		{
 			/* break down memory ECC reporting if we can */
@@ -1388,10 +1397,18 @@ ipmi_sel_print_extended_entry_verbose(struct ipmi_intf * intf, struct sel_event_
 			       evt->sel_type.standard_type.event_data[2] & 0x0f,
 			       (evt->sel_type.standard_type.event_data[2] & 0xf0) >> 4);
 		}
-		else
+		else if(
+				evt->sel_type.standard_type.sensor_type == 0x2b &&   /* Version change */
+				evt->sel_type.standard_type.event_data[0] == 0xC1	 /* Data in Data 2 */
+			   )
+			    
+		{
+			//evt->sel_type.standard_type.event_data[1]
+		}
+		else 
 		{
 			/* FIXME : Add sensor specific discrete types */
-			printf(" Event Interpretation Missing\n");
+			printf(" Event Interpretation  : Missing\n");
 		}
 	} else if (evt->sel_type.standard_type.event_type >= 0x70 && evt->sel_type.standard_type.event_type <= 0x7f) {
 		/* OEM */
diff --git a/lib/ipmi_sensor.c b/lib/ipmi_sensor.c
index 7e7615a..ab76b47 100644
--- a/lib/ipmi_sensor.c
+++ b/lib/ipmi_sensor.c
@@ -266,9 +266,9 @@ ipmi_sensor_print_full_analog(struct ipmi_intf *intf,
 		}
 
 		/* convert RAW reading into units */
-		val = (rsp->data[0] > 0)
-		    ? sdr_convert_sensor_reading(sensor, rsp->data[0])
-		    : 0;
+      /* a raw reading of 0 is perfectly valid, and might be converted to a positive or
+         negative value, as any other raw values */
+		val = sdr_convert_sensor_reading(sensor, rsp->data[0]);
 		status = (char *) ipmi_sdr_get_status(sensor, rsp->data[2]);
 	}
 
@@ -386,8 +386,7 @@ ipmi_sensor_print_full_analog(struct ipmi_intf *intf,
 				       status ? : "");
 
 				if (thresh_available) {
-					if (rsp->
-					    data[0] & LOWER_NON_RECOV_SPECIFIED)
+					if (rsp->data[0] & LOWER_NON_RECOV_SPECIFIED)
 						printf
 						    (" Lower Non-Recoverable : %.3f\n",
 						     sdr_convert_sensor_reading
@@ -403,8 +402,7 @@ ipmi_sensor_print_full_analog(struct ipmi_intf *intf,
 					else
 						printf
 						    (" Lower Critical        : na\n");
-					if (rsp->
-					    data[0] & LOWER_NON_CRIT_SPECIFIED)
+					if (rsp->data[0] & LOWER_NON_CRIT_SPECIFIED)
 						printf
 						    (" Lower Non-Critical    : %.3f\n",
 						     sdr_convert_sensor_reading
@@ -412,8 +410,7 @@ ipmi_sensor_print_full_analog(struct ipmi_intf *intf,
 					else
 						printf
 						    (" Lower Non-Critical    : na\n");
-					if (rsp->
-					    data[0] & UPPER_NON_CRIT_SPECIFIED)
+					if (rsp->data[0] & UPPER_NON_CRIT_SPECIFIED)
 						printf
 						    (" Upper Non-Critical    : %.3f\n",
 						     sdr_convert_sensor_reading
@@ -429,8 +426,7 @@ ipmi_sensor_print_full_analog(struct ipmi_intf *intf,
 					else
 						printf
 						    (" Upper Critical        : na\n");
-					if (rsp->
-					    data[0] & UPPER_NON_RECOV_SPECIFIED)
+					if (rsp->data[0] & UPPER_NON_RECOV_SPECIFIED)
 						printf
 						    (" Upper Non-Recoverable : %.3f\n",
 						     sdr_convert_sensor_reading
@@ -438,6 +434,28 @@ ipmi_sensor_print_full_analog(struct ipmi_intf *intf,
 					else
 						printf
 						    (" Upper Non-Recoverable : na\n");
+
+					if (
+							sensor->threshold.hysteresis.positive == 0x00
+							|| 
+							sensor->threshold.hysteresis.positive == 0xff
+				       )
+						printf(" Positive Hysteresis   : Unspecified\n");
+					else
+						printf(" Positive Hysteresis   : %.3f\n", 
+									sdr_convert_sensor_hysterisis
+										(sensor,sensor->threshold.hysteresis.positive));
+
+					if (
+							sensor->threshold.hysteresis.negative == 0x00
+							|| 
+							sensor->threshold.hysteresis.negative == 0xff
+					   )
+						printf(" Negative Hysteresis   : Unspecified\n");
+					else
+						printf(" Negative Hysteresis   : %.3f\n", 
+									sdr_convert_sensor_hysterisis
+										(sensor,sensor->threshold.hysteresis.negative));
 				} else {
 					printf(" Sensor Threshold Settings not available\n");
 				}
@@ -552,6 +570,12 @@ ipmi_sensor_print_compact(struct ipmi_intf *intf,
 												      sensor->event_type,
 												      rsp->data[2],
 												      rsp->data[3]);
+            printf(" Raw Data: %X", rsp->data[1]);
+            if(rsp->data_len > 2)
+            	printf(" %X", rsp->data[2]);
+            if(rsp->data_len > 3)
+            	printf(" %X", rsp->data[3]);
+            printf("\n");
             printf("\n");
          } else {
 	   printf(" Unable to read sensor: Device Not Present\n\n");
diff --git a/lib/ipmi_strings.c b/lib/ipmi_strings.c
index 162015c..3bbdf38 100644
--- a/lib/ipmi_strings.c
+++ b/lib/ipmi_strings.c
@@ -94,8 +94,10 @@ const struct oemvalstr ipmi_oem_product_info[] = {
    { IPMI_OEM_KONTRON,5504, "AM4300 AdvancedMC" },
    { IPMI_OEM_KONTRON,5507, "AM4301 AdvancedMC" },
    { IPMI_OEM_KONTRON,5508, "AM4330 AdvancedMC" },
+   { IPMI_OEM_KONTRON,5520, "KTC5520/EATX" },
    { IPMI_OEM_KONTRON,5703, "RTM8020" },
    { IPMI_OEM_KONTRON,5704, "RTM8030" },
+   { IPMI_OEM_KONTRON,5705, "RTM8050" },
    { IPMI_OEM_KONTRON,6000, "CP6000" },
    { IPMI_OEM_KONTRON,6006, "DT-64" },
    { IPMI_OEM_KONTRON,6010, "CP6010" },
@@ -107,10 +109,11 @@ const struct oemvalstr ipmi_oem_product_info[] = {
    { IPMI_OEM_KONTRON,5004, "AT8020" },
    { IPMI_OEM_KONTRON,5006, "AT8030 IPMC" },
    { IPMI_OEM_KONTRON,2025, "AT8030 MMC" },
+   { IPMI_OEM_KONTRON,5007, "AT8050" },
    { IPMI_OEM_KONTRON,5301, "AT8400" },
    { IPMI_OEM_KONTRON,5303, "AT8901" },
 
-   { 0xffff        , 0xffff , NULL },
+   { 0xffffff        , 0xffff , NULL },
  };
 
 const struct oemvalstr ipmi_oem_sdr_type_vals[] = {
@@ -123,11 +126,24 @@ const struct oemvalstr ipmi_oem_sdr_type_vals[] = {
    { IPMI_OEM_KONTRON , 0xC6 , "OEM POST Value Sensor" },
    { IPMI_OEM_KONTRON , 0xC7 , "OEM FWUM Status" },
    { IPMI_OEM_KONTRON , 0xC8 , "OEM Switch Mngt Software Status" },
+   { IPMI_OEM_KONTRON , 0xC9 , "OEM OEM Diagnostic Status" },
+   { IPMI_OEM_KONTRON , 0xCA , "OEM Component Firmware Upgrade" },
+   { IPMI_OEM_KONTRON , 0xCB , "OEM FRU Over Current" },
+   { IPMI_OEM_KONTRON , 0xCC , "OEM FRU Sensor Error" },
+   { IPMI_OEM_KONTRON , 0xCD , "OEM FRU Power Denied" },
+   { IPMI_OEM_KONTRON , 0xCE , "OEM Reserved" },
+   { IPMI_OEM_KONTRON , 0xCF , "OEM Board Reset" },
+   { IPMI_OEM_KONTRON , 0xD0 , "OEM Clock Resource Control" },
+   { IPMI_OEM_KONTRON , 0xD1 , "OEM Power State" },
+   { IPMI_OEM_KONTRON , 0xD2 , "OEM FRU Mngt Power Failure" },
+   { IPMI_OEM_KONTRON , 0xD3 , "OEM Jumper Status" },
+   { IPMI_OEM_KONTRON , 0xF2 , "OEM RTM Module Hotswap" },
 
    { IPMI_OEM_PICMG   , 0xF0 , "PICMG FRU Hotswap" },
    { IPMI_OEM_PICMG   , 0xF1 , "PICMG IPMB0 Link State" },
+   { IPMI_OEM_PICMG   , 0xF2 , "PICMG Module Hotswap" },
 
-   { 0xffff,            0x00,  NULL }
+   { 0xffffff,            0x00,  NULL }
 };
 
 const struct valstr ipmi_netfn_vals[] = {
@@ -371,6 +387,7 @@ const struct valstr completion_code_vals[] = {
 	{ 0xd3, "Destination unavailable" },
 	{ 0xd4, "Insufficient privilege level" },
 	{ 0xd5, "Command not supported in present state" },
+	{ 0xd6, "Cannot execute command, command disabled" },
 	{ 0xff, "Unspecified error" },
 	{ 0x00, NULL }
 };
@@ -407,3 +424,137 @@ const struct valstr ipmi_encryption_algorithms[] = {
 	{ IPMI_CRYPT_XRC4_40,     "xrc4_40"     },
 	{ 0x00, NULL }
 };
+
+const struct valstr picmg_frucontrol_vals[] = {
+	{ 0, "Cold Reset" },
+	{ 1, "Warm Reset"  },
+	{ 2, "Graceful Reboot" },
+	{ 3, "Issue Diagnostic Interrupt" },
+	{ 4, "Quiesce" },
+	{ 5, NULL },
+};
+
+const struct valstr picmg_clk_family_vals[] = {
+	{ 0x00, "Unspecified" },
+	{ 0x01, "SONET/SDH/PDH" },
+	{ 0x02, "Reserved for PCI Express" },
+	{ 0x03, "Reserved" }, /* from 03h to C8h */
+	{ 0xC9, "Vendor defined clock family" }, /* from C9h to FFh */
+	{ 0x00, NULL },
+};
+
+const struct oemvalstr picmg_clk_accuracy_vals[] = {
+	{ 0x01, 10, "PRS" },
+	{ 0x01, 20, "STU" },
+	{ 0x01, 30, "ST2" },
+	{ 0x01, 40, "TNC" },
+	{ 0x01, 50, "ST3E" },
+	{ 0x01, 60, "ST3" },
+	{ 0x01, 70, "SMC" },
+	{ 0x01, 80, "ST4" },
+	{ 0x01, 90, "DUS" },
+   { 0x02, 0xE0, "PCI Express Generation 2" },
+   { 0x02, 0xF0, "PCI Express Generation 1" },
+   { 0xffffff, 0x00,  NULL }
+};
+
+const struct oemvalstr picmg_clk_resource_vals[] = {
+	{ 0x0, 0, "On-Carrier Device 0" },
+	{ 0x0, 1, "On-Carrier Device 1" },
+	{ 0x1, 1, "AMC Site 1 - A1" },
+	{ 0x1, 2, "AMC Site 1 - A2" },
+	{ 0x1, 3, "AMC Site 1 - A3" },
+	{ 0x1, 4, "AMC Site 1 - A4" },
+	{ 0x1, 5, "AMC Site 1 - B1" },
+	{ 0x1, 6, "AMC Site 1 - B2" },
+	{ 0x1, 7, "AMC Site 1 - B3" },
+	{ 0x1, 8, "AMC Site 1 - B4" },
+   { 0x2, 0, "ATCA Backplane" },
+   { 0xffffff, 0x00,  NULL }
+};
+
+const struct oemvalstr picmg_clk_id_vals[] = {
+	{ 0x0, 0, "Clock 0" },
+	{ 0x0, 1, "Clock 1" },
+	{ 0x0, 2, "Clock 2" },
+	{ 0x0, 3, "Clock 3" },
+	{ 0x0, 4, "Clock 4" },
+	{ 0x0, 5, "Clock 5" },
+	{ 0x0, 6, "Clock 6" },
+	{ 0x0, 7, "Clock 7" },
+	{ 0x0, 8, "Clock 8" },
+	{ 0x0, 9, "Clock 9" },
+	{ 0x0, 10, "Clock 10" },
+	{ 0x0, 11, "Clock 11" },
+	{ 0x0, 12, "Clock 12" },
+	{ 0x0, 13, "Clock 13" },
+	{ 0x0, 14, "Clock 14" },
+	{ 0x0, 15, "Clock 15" },
+	{ 0x1, 1, "TCLKA" },
+	{ 0x1, 2, "TCLKB" },
+	{ 0x1, 3, "TCLKC" },
+	{ 0x1, 4, "TCLKD" },
+	{ 0x1, 5, "FLCKA" },
+   { 0x2, 1, "CLK1A" },
+   { 0x2, 2, "CLK1A" },
+   { 0x2, 3, "CLK1A" },
+   { 0x2, 4, "CLK1A" },
+   { 0x2, 5, "CLK1A" },
+   { 0x2, 6, "CLK1A" },
+   { 0x2, 7, "CLK1A" },
+   { 0x2, 8, "CLK1A" },
+   { 0x2, 9, "CLK1A" },
+   { 0xffffff, 0x00,  NULL }
+};
+
+const struct valstr picmg_busres_id_vals[] = {
+   { 0x0, "Metallic Test Bus pair #1" },
+   { 0x1, "Metallic Test Bus pair #2" },
+   { 0x2, "Synch clock group 1 (CLK1)" },
+   { 0x3, "Synch clock group 2 (CLK2)" },
+   { 0x4, "Synch clock group 3 (CLK3)" },
+	{ 0x5, NULL }
+};
+const struct valstr picmg_busres_board_cmd_vals[] = {
+  { 0x0, "Query" },
+  { 0x1, "Release" },
+  { 0x2, "Force" },
+  { 0x3, "Bus Free" },
+  { 0x4, NULL }
+};
+
+const struct valstr picmg_busres_shmc_cmd_vals[] = {
+  { 0x0, "Request" },
+  { 0x1, "Relinquish" },
+  { 0x2, "Notify" },
+  { 0x3, NULL }
+};
+
+const struct oemvalstr picmg_busres_board_status_vals[] = {
+ { 0x0, 0x0, "In control" },
+ { 0x0, 0x1, "No control" },
+ { 0x1, 0x0, "Ack" },
+ { 0x1, 0x1, "Refused" },
+ { 0x1, 0x2, "No control" },
+ { 0x2, 0x0, "Ack" },
+ { 0x2, 0x1, "No control" },
+ { 0x3, 0x0, "Accept" },
+ { 0x3, 0x1, "Not Needed" },
+ { 0xffffff, 0x00,  NULL }
+};
+
+const struct oemvalstr picmg_busres_shmc_status_vals[] = {
+ { 0x0, 0x0, "Grant" },
+ { 0x0, 0x1, "Busy" },
+ { 0x0, 0x2, "Defer" },
+ { 0x0, 0x3, "Deny" },
+
+ { 0x1, 0x0, "Ack" },
+ { 0x1, 0x1, "Error" },
+
+ { 0x2, 0x0, "Ack" },
+ { 0x2, 0x1, "Error" },
+ { 0x2, 0x2, "Deny" },
+
+ { 0xffffff, 0x00,  NULL }
+};
diff --git a/lib/log.c b/lib/log.c
index b8fa561..39421d9 100644
--- a/lib/log.c
+++ b/lib/log.c
@@ -104,7 +104,7 @@ void log_init(const char * name, int isdaemon, int verbose)
 	if (logpriv)
 		return;
 
-	logpriv = malloc(sizeof(*logpriv));
+	logpriv = malloc(sizeof(struct logpriv_s));
 	if (!logpriv)
 		return;
 
diff --git a/src/ipmievd.c b/src/ipmievd.c
index e726da8..6fe1537 100644
--- a/src/ipmievd.c
+++ b/src/ipmievd.c
@@ -48,7 +48,9 @@
 
 #ifdef HAVE_PATHS_H
 # include <paths.h>
-#else
+#endif
+
+#ifndef _PATH_VARRUN 
 # define _PATH_VARRUN "/var/run/"
 #endif
 
diff --git a/src/ipmitool.c b/src/ipmitool.c
index 7523b1a..28b9424 100644
--- a/src/ipmitool.c
+++ b/src/ipmitool.c
@@ -61,7 +61,9 @@
 #include <ipmitool/ipmi_kontronoem.h>
 #include <ipmitool/ipmi_firewall.h>
 #include <ipmitool/ipmi_hpmfwupg.h>
+#include <ipmitool/ipmi_delloem.h>
 #include <ipmitool/ipmi_ekanalyzer.h>
+#include <ipmitool/ipmi_ime.h>
 
 #ifdef HAVE_CONFIG_H
 # include <config.h>
@@ -105,6 +107,7 @@ struct ipmi_cmd ipmitool_cmd_list[] = {
 	{ ipmi_picmg_main,   "picmg",   "Run a PICMG/ATCA extended cmd"},
 	{ ipmi_fwum_main,    "fwum",	"Update IPMC using Kontron OEM Firmware Update Manager" },
 	{ ipmi_firewall_main,"firewall","Configure Firmware Firewall" },
+	{ ipmi_delloem_main, "delloem", "OEM Commands for Dell systems" },
 #ifdef HAVE_READLINE
 	{ ipmi_shell_main,   "shell",   "Launch interactive IPMI shell" },
 #endif
@@ -113,6 +116,7 @@ struct ipmi_cmd ipmitool_cmd_list[] = {
 	{ ipmi_echo_main,    "echo",    NULL }, /* for echoing lines to stdout in scripts */
 	{ ipmi_hpmfwupg_main,"hpm", "Update HPM components using PICMG HPM.1 file"},
 	{ ipmi_ekanalyzer_main,"ekanalyzer", "run FRU-Ekeying analyzer using FRU files"},
+	{ ipmi_ime_main,          "ime", "Update Intel Manageability Engine Firmware"},
 	{ NULL },
 };
 
diff --git a/src/plugins/free/free.c b/src/plugins/free/free.c
index db80d06..86d6a76 100644
--- a/src/plugins/free/free.c
+++ b/src/plugins/free/free.c
@@ -61,6 +61,8 @@ extern int verbose;
 
 static int ipmi_free_open(struct ipmi_intf * intf)
 {
+        int kcs_ret = -1, ssif_ret = -1;
+
         if (getuid() != 0) {
                 fprintf(stderr, "Permission denied, must be root\n");
                 return -1;
@@ -199,7 +201,7 @@ static void ipmi_free_close(struct ipmi_intf * intf)
 
 static struct ipmi_rs * ipmi_free_send_cmd(struct ipmi_intf * intf, struct ipmi_rq * req)
 {
-        u_int8_t lun = 0;
+        u_int8_t lun = req->msg.lun;
         u_int8_t cmd = req->msg.cmd;
         u_int8_t netfn = req->msg.netfn;
         u_int8_t rq_buf[IPMI_BUF_SIZE];
@@ -232,25 +234,65 @@ static struct ipmi_rs * ipmi_free_send_cmd(struct ipmi_intf * intf, struct ipmi_
         if (req->msg.data)
                memcpy(rq_buf + 1, req->msg.data, req->msg.data_len);
 
-        if ((rs_len = ipmi_cmd_raw(dev,
-                                   lun, 
-                                   netfn,                    
-                                   rq_buf, 
-                                   req->msg.data_len + 1,
-                                   rs_buf, 
-                                   rs_buf_len)) < 0) {
+        if (intf->target_addr != 0
+            && intf->target_addr != IPMI_BMC_SLAVE_ADDR) {
+#if IPMI_INTF_FREE_BRIDGING
+                if ((rs_len = ipmi_cmd_raw_ipmb(dev,
+                                                intf->target_channel,
+                                                intf->target_addr,
+                                                lun, 
+                                                netfn,                    
+                                                rq_buf, 
+                                                req->msg.data_len + 1,
+                                                rs_buf, 
+                                                rs_buf_len)) < 0) {
+			if (verbose > 3)
+                      	        fprintf(stderr,
+                                	"ipmi_cmd_raw_ipmb: %s\n",
+                                	ipmi_ctx_strerror(ipmi_ctx_errnum(dev)));
+			/* Compared to FreeIPMI, user is expected to input
+			 * the target channel on the command line, it is not automatically
+			 * discovered.  So that is the likely cause of an error.
+			 *
+			 * Instead of returning an error, return a bad response so output
+			 * of ipmitool commands looks like other interfaces
+			 */
+			rs_len = 2;
+			rs_buf[0] = 0;
+			rs_buf[0] = 0xC1; /* invalid command */
+                }
+#else  /* !IPMI_INTF_FREE_BRIDGING */
+                if (verbose > 3)
+                        fprintf(stderr, "sensor bridging not supported in this driver version");
+		/* instead of returning an error, return a bad response so output
+	 	 * of ipmitool commands looks like other interfaces
+		 */
+		rs_len = 2;
+		rs_buf[0] = 0;
+		rs_buf[0] = 0xC1; /* invalid command */
+#endif  /* !IPMI_INTF_FREE_BRIDGING */
+        }
+        else {
+                if ((rs_len = ipmi_cmd_raw(dev,
+                                           lun, 
+                                           netfn,                    
+                                           rq_buf, 
+                                           req->msg.data_len + 1,
+                                           rs_buf, 
+                                           rs_buf_len)) < 0) {
 #if IPMI_INTF_FREE_0_3_0
-                perror("ipmi_cmd_raw");
+                        perror("ipmi_cmd_raw");
 #elif IPMI_INTF_FREE_0_4_0 || IPMI_INTF_FREE_0_5_0
-                fprintf(stderr,
-                        "ipmi_cmd_raw: %s\n",
-                        ipmi_device_strerror(ipmi_device_errnum(dev)));
+                        fprintf(stderr,
+                                "ipmi_cmd_raw: %s\n",
+                                ipmi_device_strerror(ipmi_device_errnum(dev)));
 #elif IPMI_INTF_FREE_0_6_0
-                fprintf(stderr,
-                        "ipmi_cmd_raw: %s\n",
-                        ipmi_ctx_strerror(ipmi_ctx_errnum(dev)));
+                        fprintf(stderr,
+                                "ipmi_cmd_raw: %s\n",
+                                ipmi_ctx_strerror(ipmi_ctx_errnum(dev)));
 #endif
-                return NULL;
+                        return NULL;
+                }
         }
 
         memset(&rsp, 0, sizeof(struct ipmi_rs));
diff --git a/src/plugins/lan/asf.h b/src/plugins/lan/asf.h
index e946f5b..ab36d6f 100644
--- a/src/plugins/lan/asf.h
+++ b/src/plugins/lan/asf.h
@@ -56,13 +56,19 @@ static const struct valstr asf_type_vals[] __attribute__((unused)) = {
 };
 
 /* ASF message header */
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct asf_hdr {
 	uint32_t	iana;
 	uint8_t		type;
 	uint8_t		tag;
 	uint8_t		__reserved;
 	uint8_t		len;
-} __attribute__((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 int handle_asf(struct ipmi_intf * intf, uint8_t * data, int data_len);
 
diff --git a/src/plugins/lan/lan.c b/src/plugins/lan/lan.c
index 667eaf6..96e7377 100644
--- a/src/plugins/lan/lan.c
+++ b/src/plugins/lan/lan.c
@@ -105,7 +105,7 @@ struct ipmi_intf ipmi_lan_intf = {
 };
 
 static struct ipmi_rq_entry *
-ipmi_req_add_entry(struct ipmi_intf * intf, struct ipmi_rq * req)
+ipmi_req_add_entry(struct ipmi_intf * intf, struct ipmi_rq * req, uint8_t req_seq)
 {
 	struct ipmi_rq_entry * e;
 
@@ -119,6 +119,7 @@ ipmi_req_add_entry(struct ipmi_intf * intf, struct ipmi_rq * req)
 	memcpy(&e->req, req, sizeof(struct ipmi_rq));
 
 	e->intf = intf;
+	e->rq_seq = req_seq;
 
 	if (ipmi_req_entries == NULL)
 		ipmi_req_entries = e;
@@ -664,7 +665,7 @@ ipmi_lan_poll_recv(struct ipmi_intf * intf)
  * +--------------------+
  */
 static struct ipmi_rq_entry *
-ipmi_lan_build_cmd(struct ipmi_intf * intf, struct ipmi_rq * req)
+ipmi_lan_build_cmd(struct ipmi_intf * intf, struct ipmi_rq * req, int isRetry)
 {
 	struct rmcp_hdr rmcp = {
 		.ver		= RMCP_VERSION_1,
@@ -684,10 +685,13 @@ ipmi_lan_build_cmd(struct ipmi_intf * intf, struct ipmi_rq * req)
 	if (our_address == 0)
 		our_address = IPMI_BMC_SLAVE_ADDR;
 
+	if (isRetry == 0)
+		curr_seq++;
+
 	if (curr_seq >= 64)
 		curr_seq = 0;
 
-	entry = ipmi_req_add_entry(intf, req);
+	entry = ipmi_req_add_entry(intf, req, curr_seq);
 	if (entry == NULL)
 		return NULL;
 
@@ -757,7 +761,7 @@ ipmi_lan_build_cmd(struct ipmi_intf * intf, struct ipmi_rq * req)
 			tmp = len - cs;
 			msg[len++] = ipmi_csum(msg+cs, tmp);
 			cs3 = len;
-			msg[len++] = IPMI_BMC_SLAVE_ADDR;
+			msg[len++] = intf->my_addr;
 			msg[len++] = curr_seq << 2;
 			msg[len++] = 0x34;			/* Send Message rqst */
 			msg[len++] = (0x40|intf->target_channel); /* Track request */
@@ -774,14 +778,15 @@ ipmi_lan_build_cmd(struct ipmi_intf * intf, struct ipmi_rq * req)
 
 	if (!entry->bridging_level)
 		msg[len++] = IPMI_REMOTE_SWID;
-	else  /* Bridged message */
+   /* Bridged message */ 
+	else if (entry->bridging_level) 
 		msg[len++] = intf->my_addr;
-
-	entry->rq_seq = curr_seq++;
+   
+	entry->rq_seq = curr_seq;
 	msg[len++] = entry->rq_seq << 2;
 	msg[len++] = req->msg.cmd;
 
-	lprintf(LOG_DEBUG+1, ">> IPMI Request Session Header");
+	lprintf(LOG_DEBUG+1, ">> IPMI Request Session Header (level %d)", entry->bridging_level);
 	lprintf(LOG_DEBUG+1, ">>   Authtype   : %s",
 	       val2str(s->authtype, ipmi_authtype_session_vals));
 	lprintf(LOG_DEBUG+1, ">>   Sequence   : 0x%08lx", (long)s->in_seq);
@@ -851,6 +856,7 @@ ipmi_lan_send_cmd(struct ipmi_intf * intf, struct ipmi_rq * req)
 	struct ipmi_rq_entry * entry;
 	struct ipmi_rs * rsp = NULL;
 	int try = 0;
+	int isRetry = 0;
 
 	lprintf(LOG_DEBUG, "ipmi_lan_send_cmd:opened=[%d], open=[%d]",
 		intf->opened, intf->open);
@@ -865,7 +871,9 @@ ipmi_lan_send_cmd(struct ipmi_intf * intf, struct ipmi_rq * req)
 	}
 
 	for (;;) {
-		entry = ipmi_lan_build_cmd(intf, req);
+		isRetry = ( try > 0 ) ? 1 : 0;
+
+		entry = ipmi_lan_build_cmd(intf, req, isRetry);
 		if (entry == NULL) {
 			lprintf(LOG_ERR, "Aborting send command, unable to build");
 			return NULL;
@@ -888,6 +896,14 @@ ipmi_lan_send_cmd(struct ipmi_intf * intf, struct ipmi_rq * req)
 		usleep(100);
 
 		rsp = ipmi_lan_poll_recv(intf);
+
+		/* Duplicate Request ccode most likely indicates a response to
+		   a previous retry. Ignore and keep polling. */
+		if((rsp != NULL) && (rsp->ccode == 0xcf)) {
+			rsp = NULL;
+			rsp = ipmi_lan_poll_recv(intf);
+		}
+		
 		if (rsp)
 			break;
 
diff --git a/src/plugins/lan/rmcp.h b/src/plugins/lan/rmcp.h
index 260bcc7..b979d92 100644
--- a/src/plugins/lan/rmcp.h
+++ b/src/plugins/lan/rmcp.h
@@ -64,14 +64,23 @@ static const struct valstr rmcp_class_vals[] __attribute__((unused)) = {
 	{ 0,			NULL }
 };
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 /* RMCP message header */
 struct rmcp_hdr {
 	uint8_t ver;
 	uint8_t __reserved;
 	uint8_t seq;
 	uint8_t class;
-} __attribute__((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct rmcp_pong {
 	struct rmcp_hdr rmcp;
 	struct asf_hdr asf;
@@ -80,7 +89,10 @@ struct rmcp_pong {
 	uint8_t sup_entities;
 	uint8_t sup_interact;
 	uint8_t reserved[6];
-} __attribute__((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 int handle_rmcp(struct ipmi_intf * intf, uint8_t * data, int data_len);
 
diff --git a/src/plugins/lanplus/asf.h b/src/plugins/lanplus/asf.h
index 8e0a14b..7a30418 100644
--- a/src/plugins/lanplus/asf.h
+++ b/src/plugins/lanplus/asf.h
@@ -56,13 +56,19 @@ static const struct valstr asf_type_vals[] __attribute__((unused)) = {
 };
 
 /* ASF message header */
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct asf_hdr {
 	uint32_t iana;
 	uint8_t type;
 	uint8_t tag;
 	uint8_t __reserved;
 	uint8_t len;
-} __attribute__((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 int handle_asf(struct ipmi_intf * intf, uint8_t * data, int data_len);
 
diff --git a/src/plugins/lanplus/lanplus.c b/src/plugins/lanplus/lanplus.c
index cccb4d4..474cbb0 100644
--- a/src/plugins/lanplus/lanplus.c
+++ b/src/plugins/lanplus/lanplus.c
@@ -645,8 +645,8 @@ ipmi_lan_poll_recv(struct ipmi_intf * intf)
 		 * 7) An Invalid packet (one that doesn't match a request)
 		 * -------------------------------------------------------------------
 		 */
-		read_session_data(rsp, &offset, intf->session);
 
+		read_session_data(rsp, &offset, intf->session);
 
 		if (lanplus_has_valid_auth_code(rsp, intf->session) == 0)
 		{
@@ -714,17 +714,27 @@ ipmi_lan_poll_recv(struct ipmi_intf * intf)
 			/* Are we expecting this packet? */
 			entry = ipmi_req_lookup_entry(rsp->payload.ipmi_response.rq_seq,
 								rsp->payload.ipmi_response.cmd);
+
 			if (entry != NULL) {
 				lprintf(LOG_DEBUG+2, "IPMI Request Match found");
 				if (
 				      intf->target_addr != intf->my_addr 
 				      &&
-					   bridgePossible
-                  &&
-                  rsp->data_len 
-                  &&
-						rsp->payload.ipmi_response.cmd == 0x34
-					) 
+					  bridgePossible
+                      &&
+                      rsp->data_len 
+                      &&
+					  rsp->payload.ipmi_response.cmd == 0x34
+					  &&
+					  (
+						rsp->payload.ipmi_response.netfn == 0x06
+						||
+    					rsp->payload.ipmi_response.netfn == 0x07
+					  )
+					  &&
+					  rsp->payload.ipmi_response.rs_lun == 0
+
+				   ) 
 				{
                /* Check completion code */
                if (rsp->data[offset-1] == 0)
@@ -752,6 +762,7 @@ ipmi_lan_poll_recv(struct ipmi_intf * intf)
 							"bridge command response");
 					}
 				}
+
 				ipmi_req_remove_entry(rsp->payload.ipmi_response.rq_seq,
 								rsp->payload.ipmi_response.cmd);
 			} else {
@@ -1843,7 +1854,8 @@ ipmi_lanplus_build_v2x_msg(
 static struct ipmi_rq_entry *
 ipmi_lanplus_build_v2x_ipmi_cmd(
 								struct ipmi_intf * intf,
-								struct ipmi_rq * req)
+								struct ipmi_rq * req,
+								int isRetry)
 {
 	struct ipmi_v2_payload v2_payload;
 	struct ipmi_rq_entry * entry;
@@ -1856,7 +1868,8 @@ ipmi_lanplus_build_v2x_ipmi_cmd(
 	 */
 	static uint8_t curr_seq = 0;
 
-	curr_seq += 1;
+	if( isRetry == 0 )
+		curr_seq += 1;
 
 	if (curr_seq >= 64)
 		curr_seq = 0;
@@ -2092,9 +2105,10 @@ ipmi_lanplus_send_payload(
 		return NULL;
 
 	while (try < session->retry) {
-		ltime = time(NULL);
+		//ltime = time(NULL);
 
 		if (xmit) {
+			ltime = time(NULL);
 
 			if (payload->payload_type == IPMI_PAYLOAD_TYPE_IPMI)
 			{
@@ -2134,8 +2148,10 @@ ipmi_lanplus_send_payload(
 				}
 				else
 				{
+					int isRetry = ( try > 0 ? 1 : 0 );
+
 					lprintf(LOG_DEBUG+1, "BUILDING A v2 COMMAND");
-					entry = ipmi_lanplus_build_v2x_ipmi_cmd(intf, ipmi_request);
+					entry = ipmi_lanplus_build_v2x_ipmi_cmd(intf, ipmi_request, isRetry);
 				}
 
 				if (entry == NULL) {
@@ -2269,6 +2285,15 @@ ipmi_lanplus_send_payload(
 		else
 		{
 			rsp = ipmi_lan_poll_recv(intf);
+
+			/* Duplicate Request ccode most likely indicates a response to
+			   a previous retry. Ignore and keep polling. */
+			while ((rsp != NULL) && (rsp->ccode == 0xcf))
+			{
+				rsp = NULL;
+				rsp = ipmi_lan_poll_recv(intf);
+			}
+
 			if (rsp)
 				break;
 		}
diff --git a/src/plugins/lanplus/rmcp.h b/src/plugins/lanplus/rmcp.h
index 898a2b5..51dc44d 100644
--- a/src/plugins/lanplus/rmcp.h
+++ b/src/plugins/lanplus/rmcp.h
@@ -64,12 +64,18 @@ static const struct valstr rmcp_class_vals[] __attribute__((unused)) = {
 };
 
 /* RMCP message header */
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
 struct rmcp_hdr {
 	uint8_t ver;
 	uint8_t __reserved;
 	uint8_t seq;
 	uint8_t class;
-} __attribute__((packed));
+} ATTRIBUTE_PACKING;
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
 
 int handle_rmcp(struct ipmi_intf * intf, uint8_t * data, int data_len);
 
diff --git a/src/plugins/open/open.c b/src/plugins/open/open.c
index a283dc5..e40476c 100644
--- a/src/plugins/open/open.c
+++ b/src/plugins/open/open.c
@@ -44,7 +44,6 @@
 #include <ipmitool/ipmi_intf.h>
 #include <ipmitool/helper.h>
 #include <ipmitool/log.h>
-#include <ipmitool/ipmi_picmg.h>
 
 #if defined(HAVE_CONFIG_H)
 # include <config.h>
@@ -68,9 +67,7 @@ static int
 ipmi_openipmi_open(struct ipmi_intf * intf)
 {
 	int i = 0;
-	struct ipmi_rq req;
-	struct ipmi_rs *rsp;
-	char msg_data;
+
 	char ipmi_dev[16];
 	char ipmi_devfs[16];
 	char ipmi_devfs2[16];
@@ -101,7 +98,10 @@ ipmi_openipmi_open(struct ipmi_intf * intf)
 		lperror(LOG_ERR, "Could not enable event receiver");
 		return -1;
 	}
+ 
+	intf->opened = 1;
 
+   /* This is never set to 0, the default is IPMI_BMC_SLAVE_ADDR */
 	if (intf->my_addr != 0) {
 		unsigned int a = intf->my_addr;
 		if (ioctl(intf->fd, IPMICTL_SET_MY_ADDRESS_CMD, &a) < 0) {
@@ -110,73 +110,7 @@ ipmi_openipmi_open(struct ipmi_intf * intf)
 		}
 
 		lprintf(LOG_DEBUG, "Set IPMB address to 0x%x",
-			intf->my_addr);
-	}
-	intf->opened = 1;
-
-	/* Check if PICMG extension is available to use the function GetDeviceLocator
-	 * to retreive i2c address PICMG hack to set right IPMB address, 
-	 * If extension is not supported, should not give any problems
-    *  PICMG Extension Version 2.0 (PICMG 3.0 Revision 1.0 ATCA) to
-    *  PICMG Extension Version 2.3 (PICMG 3.0 Revision 3.0 ATCA)
-	 */
-	if (intf->my_addr == IPMI_BMC_SLAVE_ADDR) {
-      
-      /* First, check if PICMG extension is available and supported */
-      unsigned char version_accepted = 0;
-
-		lprintf(LOG_DEBUG, "Running PICMG GetDeviceLocator" );
-		memset(&req, 0, sizeof(req));
-		req.msg.netfn = IPMI_NETFN_PICMG;
-		req.msg.cmd = PICMG_GET_PICMG_PROPERTIES_CMD;             
-		msg_data    = 0x00;                                       
-		req.msg.data = &msg_data; 
-		req.msg.data_len = 1;
-		msg_data = 0;
-
-		rsp = intf->sendrecv(intf, &req);
-		if (rsp && !rsp->ccode) {
-			if
-			(  
-				(rsp->data[0] == 0)
-				&&
-				(
-					(rsp->data[1] == 0x02)
-					||
-					(rsp->data[1] == 0x12) 
-					||
-					(rsp->data[1] == 0x22) 
-					||
-					(rsp->data[1] == 0x32) 
-				)
-			){
-		      version_accepted = 1;
-		      lprintf(LOG_DEBUG, "Discovered PICMG Extension %d.%d", 
-                            (rsp->data[1] & 0x0f),(rsp->data[1] >> 4)  );
-		   }
-		}
-		
-		if(version_accepted == 1){
-			lprintf(LOG_DEBUG, "Running PICMG GetDeviceLocator" );
-			memset(&req, 0, sizeof(req));
-			req.msg.netfn = IPMI_NETFN_PICMG;
-			req.msg.cmd = PICMG_GET_ADDRESS_INFO_CMD;
-			msg_data    = 0x00;
-			req.msg.data = &msg_data; 
-			req.msg.data_len = 1;   
-			msg_data = 0;
-
-		   rsp = intf->sendrecv(intf, &req);
-		   if (rsp && !rsp->ccode) {
-			   intf->my_addr = rsp->data[2];
-			   intf->target_addr = intf->my_addr;
-			   lprintf(LOG_DEBUG, "Discovered IPMB address = 0x%x", intf->my_addr);
-		   }
-      }
-      else{
-         lprintf(LOG_DEBUG, 
-                  "No PICMG Extenstion discovered, keeping IPMB address 0x20");
-      }
+			intf->my_addr );
 	}
 
 	return intf->fd;
@@ -211,8 +145,13 @@ ipmi_openipmi_send_cmd(struct ipmi_intf * intf, struct ipmi_rq * req)
 	static int curr_seq = 0;
 	fd_set rset;
 
+	uint8_t * data = NULL;
+	int data_len = 0;
+
+
 	if (intf == NULL || req == NULL)
 		return NULL;
+
 	if (intf->opened == 0 && intf->open != NULL)
 		if (intf->open(intf) < 0)
 			return NULL;
@@ -231,56 +170,130 @@ ipmi_openipmi_send_cmd(struct ipmi_intf * intf, struct ipmi_rq * req)
 	    intf->target_addr != intf->my_addr) {
 		/* use IPMB address if needed */
 		ipmb_addr.slave_addr = intf->target_addr;
-      ipmb_addr.lun = req->msg.lun;
+		ipmb_addr.lun = req->msg.lun;
 		lprintf(LOG_DEBUG, "Sending request to "
-			"IPMB target @ 0x%x", intf->target_addr);
-#ifdef ENABLE_INTF_OPEN_DUAL_BRIDGE
-      if(intf->transit_addr != 0 &&
-	    intf->transit_addr != intf->my_addr) {
-         ipmb_addr.transit_slave_addr = intf->transit_addr;
-         lprintf(LOG_DEBUG, "Sending through transit "
-			   "IPMB target @ 0x%x", intf->transit_addr);
-      }
-#endif
+			"IPMB target @ 0x%x (from 0x%x)", intf->target_addr,intf->my_addr);
+
+		if(intf->transit_addr != 0 && intf->transit_addr != intf->my_addr) { 
+		   uint8_t index = 0;
+      
+		   lprintf(LOG_DEBUG, "Encapsulating data sent to "
+			   "end target [0x%02x,0x%02x] using transit [0x%02x,0x%02x] from 0x%x ",
+			   (0x40 | intf->target_channel),
+			   intf->target_addr,
+			   intf->transit_channel,
+			   intf->transit_addr,
+			   intf->my_addr
+			   );      
+
+		   /* Convert Message to 'Send Message' */
+		   /* Supplied req : req , internal req : _req  */
+
+		   if (verbose > 4) {
+		      fprintf(stderr, "Converting message:\n");
+		      fprintf(stderr, "  netfn     = 0x%x\n",  req->msg.netfn );
+		      fprintf(stderr, "  cmd       = 0x%x\n", req->msg.cmd);
+		      if (recv.msg.data && recv.msg.data_len) {
+			 fprintf(stderr, "  data_len  = %d\n", req->msg.data_len);
+			 fprintf(stderr, "  data      = %s\n",
+				 buf2str(req->msg.data,req->msg.data_len));
+		      }
+		   }
+
+		   /* Modify target address to use 'transit' instead */
+		   ipmb_addr.slave_addr = intf->transit_addr;
+		   ipmb_addr.channel    = intf->transit_channel;
+
+		   /* FIXME backup "My address" */
+		   data_len = req->msg.data_len + 8;
+		   data = malloc(data_len);
+		   if (data == NULL) {
+		      lprintf(LOG_ERR, "ipmitool: malloc failure");
+		      return NULL;
+		   }
+
+		   memset(data, 0, data_len);
+
+		   data[index++] = (0x40|intf->target_channel);
+		   data[index++] = intf->target_addr;
+		   data[index++] = (  req->msg.netfn << 2 ) |  req->msg.lun ;
+		   data[index++] = ipmi_csum(data+1, 2);
+		   data[index++] = 0xFF;    /* normally 0x20 , overwritten by IPMC  */
+		   data[index++] = ( (0)  << 2) | 0 ;           /* FIXME */
+		   data[index++] = req->msg.cmd;
+		   memcpy( (data+index) , req->msg.data, req->msg.data_len);
+		   index += req->msg.data_len;
+		   data[index++] = ipmi_csum( (data+4),(req->msg.data_len + 3)  );
+          
+		   if (verbose > 4) {
+		      fprintf(stderr, "Encapsulated message:\n");
+		      fprintf(stderr, "  netfn     = 0x%x\n", IPMI_NETFN_APP  );
+		      fprintf(stderr, "  cmd       = 0x%x\n", 0x34 );
+		      if (data && data_len) {
+			 fprintf(stderr, "  data_len  = %d\n", data_len);
+			 fprintf(stderr, "  data      = %s\n",
+				 buf2str(data,data_len));
+		      }
+		   }
+		}
 		_req.addr = (unsigned char *) &ipmb_addr;
 		_req.addr_len = sizeof(ipmb_addr);
 	} else {
-		/* otherwise use system interface */
-		lprintf(LOG_DEBUG+2, "Sending request to "
-			"System Interface");
-		bmc_addr.lun = req->msg.lun;
-		_req.addr = (unsigned char *) &bmc_addr;
-		_req.addr_len = sizeof(bmc_addr);
+	   /* otherwise use system interface */
+	   lprintf(LOG_DEBUG+2, "Sending request to "
+		   "System Interface");
+	   bmc_addr.lun = req->msg.lun;
+	   _req.addr = (unsigned char *) &bmc_addr;
+	   _req.addr_len = sizeof(bmc_addr);
 	}
 
 	_req.msgid = curr_seq++;
-	_req.msg.netfn = req->msg.netfn;
-	_req.msg.cmd = req->msg.cmd;
-	_req.msg.data = req->msg.data;
-	_req.msg.data_len = req->msg.data_len;
 
+	/* In case of a bridge request */
+	if( data != NULL && data_len != 0 ) {
+	   _req.msg.data = data;
+	   _req.msg.data_len = data_len;
+	   _req.msg.netfn = IPMI_NETFN_APP;
+	   _req.msg.cmd   = 0x34;
+
+	} else {
+	   _req.msg.data = req->msg.data;
+	   _req.msg.data_len = req->msg.data_len;
+	   _req.msg.netfn = req->msg.netfn;
+	   _req.msg.cmd = req->msg.cmd;
+	}
+   
 	if (ioctl(intf->fd, IPMICTL_SEND_COMMAND, &_req) < 0) {
-		lperror(LOG_ERR, "Unable to send command");
-		return NULL;
+	   lperror(LOG_ERR, "Unable to send command");
+	   if (data != NULL)
+	      free(data);
+	   return NULL;
 	}
 
 	/*
 	 * wait for and retrieve response
 	 */
 
-	if (intf->noanswer)
-		return NULL;
+	if (intf->noanswer) {
+	   if (data != NULL)
+	      free(data);
+	   return NULL;
+	}
 
 	FD_ZERO(&rset);
 	FD_SET(intf->fd, &rset);
 
 	if (select(intf->fd+1, &rset, NULL, NULL, NULL) < 0) {
-		lperror(LOG_ERR, "I/O Error");
-		return NULL;
+	   lperror(LOG_ERR, "I/O Error");
+	   if (data != NULL)
+	      free(data);
+	   return NULL;
 	}
 	if (FD_ISSET(intf->fd, &rset) == 0) {
-		lprintf(LOG_ERR, "No data available");
-		return NULL;
+	   lprintf(LOG_ERR, "No data available");
+	   if (data != NULL)
+	      free(data);
+	   return NULL;
 	}
 
 	recv.addr = (unsigned char *) &addr;
@@ -290,23 +303,56 @@ ipmi_openipmi_send_cmd(struct ipmi_intf * intf, struct ipmi_rq * req)
 
 	/* get data */
 	if (ioctl(intf->fd, IPMICTL_RECEIVE_MSG_TRUNC, &recv) < 0) {
-		lperror(LOG_ERR, "Error receiving message");
-		if (errno != EMSGSIZE)
-			return NULL;
+	   lperror(LOG_ERR, "Error receiving message");
+	   if (errno != EMSGSIZE) {
+	      if (data != NULL)
+		 free(data);
+	      return NULL;
+	   }
 	}
 
 	if (verbose > 4) {
-		fprintf(stderr, "Got message:");
-		fprintf(stderr, "  type      = %d\n", recv.recv_type);
-		fprintf(stderr, "  channel   = 0x%x\n", addr.channel);
-		fprintf(stderr, "  msgid     = %ld\n", recv.msgid);
-		fprintf(stderr, "  netfn     = 0x%x\n", recv.msg.netfn);
-		fprintf(stderr, "  cmd       = 0x%x\n", recv.msg.cmd);
-		if (recv.msg.data && recv.msg.data_len) {
-			fprintf(stderr, "  data_len  = %d\n", recv.msg.data_len);
-			fprintf(stderr, "  data      = %s\n",
-				buf2str(recv.msg.data, recv.msg.data_len));
-		}
+	   fprintf(stderr, "Got message:");
+	   fprintf(stderr, "  type      = %d\n", recv.recv_type);
+	   fprintf(stderr, "  channel   = 0x%x\n", addr.channel);
+	   fprintf(stderr, "  msgid     = %ld\n", recv.msgid);
+	   fprintf(stderr, "  netfn     = 0x%x\n", recv.msg.netfn);
+	   fprintf(stderr, "  cmd       = 0x%x\n", recv.msg.cmd);
+	   if (recv.msg.data && recv.msg.data_len) {
+	      fprintf(stderr, "  data_len  = %d\n", recv.msg.data_len);
+	      fprintf(stderr, "  data      = %s\n",
+		      buf2str(recv.msg.data, recv.msg.data_len));
+	   }
+	}
+
+	if(intf->transit_addr != 0 && intf->transit_addr != intf->my_addr) {
+	   uint8_t index = 0;
+     
+	   /* ipmb_addr.transit_slave_addr = intf->transit_addr; */
+	   lprintf(LOG_DEBUG, "Decapsulating data received from transit "
+		   "IPMB target @ 0x%x", intf->transit_addr);
+
+	   /* comp code */
+	   /* Check data */
+
+	   if( recv.msg.data[0] == 0 ) {
+	      recv.msg.netfn = recv.msg.data[2] >> 2;
+	      recv.msg.cmd   = recv.msg.data[6];
+
+	      recv.msg.data = memmove(recv.msg.data ,recv.msg.data+7 , recv.msg.data_len - 7);
+	      recv.msg.data_len -=8;
+       
+	      if (verbose > 4) {   
+		 fprintf(stderr, "Decapsulated  message:\n");
+		 fprintf(stderr, "  netfn     = 0x%x\n",   recv.msg.netfn );
+		 fprintf(stderr, "  cmd       = 0x%x\n",  recv.msg.cmd);
+		 if (recv.msg.data && recv.msg.data_len) {
+		    fprintf(stderr, "  data_len  = %d\n",  recv.msg.data_len);
+		    fprintf(stderr, "  data      = %s\n",
+			    buf2str(recv.msg.data,recv.msg.data_len));
+		 }
+	      }
+	   }
 	}
 
 	/* save completion code */
@@ -315,10 +361,13 @@ ipmi_openipmi_send_cmd(struct ipmi_intf * intf, struct ipmi_rq * req)
 
 	/* save response data for caller */
 	if (rsp.ccode == 0 && rsp.data_len > 0) {
-		memmove(rsp.data, rsp.data + 1, rsp.data_len);
-		rsp.data[recv.msg.data_len] = 0;
+	   memmove(rsp.data, rsp.data + 1, rsp.data_len);
+	   rsp.data[recv.msg.data_len] = 0;
 	}
 
+	if (data != NULL)
+	   free(data);
+
 	return &rsp;
 }
 
diff --git a/src/plugins/open/open.h b/src/plugins/open/open.h
index 55e3794..5d7aa5b 100644
--- a/src/plugins/open/open.h
+++ b/src/plugins/open/open.h
@@ -89,10 +89,6 @@ struct ipmi_ipmb_addr {
 	short channel;
 	unsigned char slave_addr;
 	unsigned char lun;
-#ifdef ENABLE_INTF_OPEN_DUAL_BRIDGE
-	short transit_channel;
-	unsigned char transit_slave_addr;
-#endif
 };
 
 #define IPMI_IOC_MAGIC			'i'
